/*
* AUTOGENERATED FILE. DO NOT EDIT IT
* Generated by "generate_jsb.py -c opengl_jsb.ini" on 2013-03-05
* Script version: v0.6
*/
#include "js_bindings_config.h"
#ifdef JSB_INCLUDE_OPENGL

#include "jsb_opengl_manual.h"

#include "jsfriendapi.h"
//#include "jsb_config.h"
#include "js_bindings_core.h"
#include "js_manual_conversions.h"
#include "jsb_opengl_functions.h"

// Arguments: GLenum
// Ret value: void
JSBool JSB_glActiveTexture(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0;

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glActiveTexture((GLenum)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLuint, GLuint
// Ret value: void
JSBool JSB_glAttachShader(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glAttachShader((GLuint)arg0 , (GLuint)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLuint, GLuint, char*
// Ret value: void
JSBool JSB_glBindAttribLocation(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; const char* arg2; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg1 );
	ok &= jsval_to_charptr(cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glBindAttribLocation((GLuint)arg0 , (GLuint)arg1 , (char*)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLuint
// Ret value: void
JSBool JSB_glBindBuffer(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glBindBuffer((GLenum)arg0 , (GLuint)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLuint
// Ret value: void
JSBool JSB_glBindFramebuffer(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glBindFramebuffer((GLenum)arg0 , (GLuint)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLuint
// Ret value: void
JSBool JSB_glBindRenderbuffer(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glBindRenderbuffer((GLenum)arg0 , (GLuint)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLuint
// Ret value: void
JSBool JSB_glBindTexture(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glBindTexture((GLenum)arg0 , (GLuint)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLclampf, GLclampf, GLclampf, GLclampf
// Ret value: void
JSBool JSB_glBlendColor(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= jsval_to_int32( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glBlendColor((GLclampf)arg0 , (GLclampf)arg1 , (GLclampf)arg2 , (GLclampf)arg3  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum
// Ret value: void
JSBool JSB_glBlendEquation(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glBlendEquation((GLenum)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLenum
// Ret value: void
JSBool JSB_glBlendEquationSeparate(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glBlendEquationSeparate((GLenum)arg0 , (GLenum)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLenum
// Ret value: void
JSBool JSB_glBlendFunc(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glBlendFunc((GLenum)arg0 , (GLenum)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLenum, GLenum, GLenum
// Ret value: void
JSBool JSB_glBlendFuncSeparate(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; uint32_t arg2; uint32_t arg3; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg1 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg2 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glBlendFuncSeparate((GLenum)arg0 , (GLenum)arg1 , (GLenum)arg2 , (GLenum)arg3  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, ArrayBufferView, GLenum
// Ret value: void
JSBool JSB_glBufferData(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; void* arg1; uint32_t arg2; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	GLsizei count;
	ok &= JSB_get_arraybufferview_dataptr( cx, *argvp++, &count, &arg1);
	ok &= jsval_to_uint32( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glBufferData((GLenum)arg0 , count, (GLvoid*)arg1 , (GLenum)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLintptr, ArrayBufferView
// Ret value: void
JSBool JSB_glBufferSubData(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; int32_t arg1; void* arg2; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	GLsizei count;
	ok &= JSB_get_arraybufferview_dataptr( cx, *argvp++, &count, &arg2);
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glBufferSubData((GLenum)arg0 , (GLintptr)arg1 , count, (GLvoid*)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum
// Ret value: GLenum
JSBool JSB_glCheckFramebufferStatus(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	GLenum ret_val;

	ret_val = glCheckFramebufferStatus((GLenum)arg0  );
	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));
	return JS_TRUE;
}

// Arguments: GLbitfield
// Ret value: void
JSBool JSB_glClear(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glClear((GLbitfield)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLclampf, GLclampf, GLclampf, GLclampf
// Ret value: void
JSBool JSB_glClearColor(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= jsval_to_int32( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glClearColor((GLclampf)arg0 , (GLclampf)arg1 , (GLclampf)arg2 , (GLclampf)arg3  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLclampf
// Ret value: void
JSBool JSB_glClearDepthf(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glClearDepthf((GLclampf)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint
// Ret value: void
JSBool JSB_glClearStencil(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glClearStencil((GLint)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLboolean, GLboolean, GLboolean, GLboolean
// Ret value: void
JSBool JSB_glColorMask(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint16_t arg0; uint16_t arg1; uint16_t arg2; uint16_t arg3; 

	ok &= jsval_to_uint16( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint16( cx, *argvp++, &arg1 );
	ok &= jsval_to_uint16( cx, *argvp++, &arg2 );
	ok &= jsval_to_uint16( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glColorMask((GLboolean)arg0 , (GLboolean)arg1 , (GLboolean)arg2 , (GLboolean)arg3  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLuint
// Ret value: void
JSBool JSB_glCompileShader(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glCompileShader((GLuint)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLint, GLenum, GLsizei, GLsizei, GLint, GLsizei, ArrayBufferView
// Ret value: void
JSBool JSB_glCompressedTexImage2D(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 8, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; int32_t arg1; uint32_t arg2; int32_t arg3; int32_t arg4; int32_t arg5; int32_t arg6; void* arg7; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg2 );
	ok &= jsval_to_int32( cx, *argvp++, &arg3 );
	ok &= jsval_to_int32( cx, *argvp++, &arg4 );
	ok &= jsval_to_int32( cx, *argvp++, &arg5 );
	ok &= jsval_to_int32( cx, *argvp++, &arg6 );
	GLsizei count;
	ok &= JSB_get_arraybufferview_dataptr( cx, *argvp++, &count, &arg7);
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glCompressedTexImage2D((GLenum)arg0 , (GLint)arg1 , (GLenum)arg2 , (GLsizei)arg3 , (GLsizei)arg4 , (GLint)arg5 , (GLsizei)arg6 , (GLvoid*)arg7  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLsizei, ArrayBufferView
// Ret value: void
JSBool JSB_glCompressedTexSubImage2D(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 9, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; int32_t arg4; int32_t arg5; uint32_t arg6; int32_t arg7; void* arg8; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= jsval_to_int32( cx, *argvp++, &arg3 );
	ok &= jsval_to_int32( cx, *argvp++, &arg4 );
	ok &= jsval_to_int32( cx, *argvp++, &arg5 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg6 );
	ok &= jsval_to_int32( cx, *argvp++, &arg7 );
	GLsizei count;
	ok &= JSB_get_arraybufferview_dataptr( cx, *argvp++, &count, &arg8);
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glCompressedTexSubImage2D((GLenum)arg0 , (GLint)arg1 , (GLint)arg2 , (GLint)arg3 , (GLsizei)arg4 , (GLsizei)arg5 , (GLenum)arg6 , (GLsizei)arg7 , (GLvoid*)arg8  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint
// Ret value: void
JSBool JSB_glCopyTexImage2D(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 8, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; int32_t arg1; uint32_t arg2; int32_t arg3; int32_t arg4; int32_t arg5; int32_t arg6; int32_t arg7; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg2 );
	ok &= jsval_to_int32( cx, *argvp++, &arg3 );
	ok &= jsval_to_int32( cx, *argvp++, &arg4 );
	ok &= jsval_to_int32( cx, *argvp++, &arg5 );
	ok &= jsval_to_int32( cx, *argvp++, &arg6 );
	ok &= jsval_to_int32( cx, *argvp++, &arg7 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glCopyTexImage2D((GLenum)arg0 , (GLint)arg1 , (GLenum)arg2 , (GLint)arg3 , (GLint)arg4 , (GLsizei)arg5 , (GLsizei)arg6 , (GLint)arg7  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei
// Ret value: void
JSBool JSB_glCopyTexSubImage2D(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 8, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; int32_t arg4; int32_t arg5; int32_t arg6; int32_t arg7; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= jsval_to_int32( cx, *argvp++, &arg3 );
	ok &= jsval_to_int32( cx, *argvp++, &arg4 );
	ok &= jsval_to_int32( cx, *argvp++, &arg5 );
	ok &= jsval_to_int32( cx, *argvp++, &arg6 );
	ok &= jsval_to_int32( cx, *argvp++, &arg7 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glCopyTexSubImage2D((GLenum)arg0 , (GLint)arg1 , (GLint)arg2 , (GLint)arg3 , (GLint)arg4 , (GLint)arg5 , (GLsizei)arg6 , (GLsizei)arg7  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: GLuint
JSBool JSB_glCreateProgram(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLuint ret_val;

	ret_val = glCreateProgram( );
	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));
	return JS_TRUE;
}

// Arguments: GLenum
// Ret value: GLuint
JSBool JSB_glCreateShader(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	GLuint ret_val;

	ret_val = glCreateShader((GLenum)arg0  );
	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));
	return JS_TRUE;
}

// Arguments: GLenum
// Ret value: void
JSBool JSB_glCullFace(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glCullFace((GLenum)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLuint
// Ret value: void
JSBool JSB_glDeleteProgram(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glDeleteProgram((GLuint)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLuint
// Ret value: void
JSBool JSB_glDeleteShader(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glDeleteShader((GLuint)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum
// Ret value: void
JSBool JSB_glDepthFunc(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glDepthFunc((GLenum)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLboolean
// Ret value: void
JSBool JSB_glDepthMask(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint16_t arg0; 

	ok &= jsval_to_uint16( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glDepthMask((GLboolean)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLclampf, GLclampf
// Ret value: void
JSBool JSB_glDepthRangef(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glDepthRangef((GLclampf)arg0 , (GLclampf)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLuint, GLuint
// Ret value: void
JSBool JSB_glDetachShader(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glDetachShader((GLuint)arg0 , (GLuint)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum
// Ret value: void
JSBool JSB_glDisable(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glDisable((GLenum)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLuint
// Ret value: void
JSBool JSB_glDisableVertexAttribArray(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glDisableVertexAttribArray((GLuint)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLint, GLsizei
// Ret value: void
JSBool JSB_glDrawArrays(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; int32_t arg1; int32_t arg2; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= jsval_to_int32( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glDrawArrays((GLenum)arg0 , (GLint)arg1 , (GLsizei)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLsizei, GLenum, ArrayBufferView
// Ret value: void
JSBool JSB_glDrawElements(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; int32_t arg1; uint32_t arg2; void* arg3; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg2 );
	GLsizei count;
	ok &= JSB_get_arraybufferview_dataptr( cx, *argvp++, &count, &arg3);
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glDrawElements((GLenum)arg0 , (GLsizei)arg1 , (GLenum)arg2 , (GLvoid*)arg3  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum
// Ret value: void
JSBool JSB_glEnable(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glEnable((GLenum)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLuint
// Ret value: void
JSBool JSB_glEnableVertexAttribArray(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glEnableVertexAttribArray((GLuint)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void
JSBool JSB_glFinish(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	glFinish( );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void
JSBool JSB_glFlush(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	glFlush( );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLenum, GLenum, GLuint
// Ret value: void
JSBool JSB_glFramebufferRenderbuffer(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; uint32_t arg2; uint32_t arg3; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg1 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg2 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glFramebufferRenderbuffer((GLenum)arg0 , (GLenum)arg1 , (GLenum)arg2 , (GLuint)arg3  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLenum, GLenum, GLuint, GLint
// Ret value: void
JSBool JSB_glFramebufferTexture2D(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 5, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; uint32_t arg2; uint32_t arg3; int32_t arg4; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg1 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg2 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg3 );
	ok &= jsval_to_int32( cx, *argvp++, &arg4 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glFramebufferTexture2D((GLenum)arg0 , (GLenum)arg1 , (GLenum)arg2 , (GLuint)arg3 , (GLint)arg4  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum
// Ret value: void
JSBool JSB_glFrontFace(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glFrontFace((GLenum)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum
// Ret value: void
JSBool JSB_glGenerateMipmap(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glGenerateMipmap((GLenum)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLuint, char*
// Ret value: int
JSBool JSB_glGetAttribLocation(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; const char* arg1; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_charptr( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	int ret_val;

	ret_val = glGetAttribLocation((GLuint)arg0 , (char*)arg1  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: GLenum
JSBool JSB_glGetError(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );
	GLenum ret_val;

	ret_val = glGetError( );
	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));
	return JS_TRUE;
}

// Arguments: GLuint, char*
// Ret value: int
JSBool JSB_glGetUniformLocation(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; const char* arg1; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_charptr( cx, *argvp++, &arg1 );
    printf("%s ", arg1);
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	int ret_val;

	ret_val = glGetUniformLocation((GLuint)arg0 , (char*)arg1  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));
	return JS_TRUE;
}

// Arguments: GLenum, GLenum
// Ret value: void
JSBool JSB_glHint(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glHint((GLenum)arg0 , (GLenum)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLuint
// Ret value: GLboolean
JSBool JSB_glIsBuffer(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	GLboolean ret_val;

	ret_val = glIsBuffer((GLuint)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));
	return JS_TRUE;
}

// Arguments: GLenum
// Ret value: GLboolean
JSBool JSB_glIsEnabled(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	GLboolean ret_val;

	ret_val = glIsEnabled((GLenum)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));
	return JS_TRUE;
}

// Arguments: GLuint
// Ret value: GLboolean
JSBool JSB_glIsFramebuffer(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	GLboolean ret_val;

	ret_val = glIsFramebuffer((GLuint)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));
	return JS_TRUE;
}

// Arguments: GLuint
// Ret value: GLboolean
JSBool JSB_glIsProgram(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	GLboolean ret_val;

	ret_val = glIsProgram((GLuint)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));
	return JS_TRUE;
}

// Arguments: GLuint
// Ret value: GLboolean
JSBool JSB_glIsRenderbuffer(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	GLboolean ret_val;

	ret_val = glIsRenderbuffer((GLuint)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));
	return JS_TRUE;
}

// Arguments: GLuint
// Ret value: GLboolean
JSBool JSB_glIsShader(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	GLboolean ret_val;

	ret_val = glIsShader((GLuint)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));
	return JS_TRUE;
}

// Arguments: GLuint
// Ret value: GLboolean
JSBool JSB_glIsTexture(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	GLboolean ret_val;

	ret_val = glIsTexture((GLuint)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));
	return JS_TRUE;
}

// Arguments: GLfloat
// Ret value: void
JSBool JSB_glLineWidth(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glLineWidth((GLfloat)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLuint
// Ret value: void
JSBool JSB_glLinkProgram(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glLinkProgram((GLuint)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLint
// Ret value: void
JSBool JSB_glPixelStorei(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; int32_t arg1; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glPixelStorei((GLenum)arg0 , (GLint)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLfloat, GLfloat
// Ret value: void
JSBool JSB_glPolygonOffset(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glPolygonOffset((GLfloat)arg0 , (GLfloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, ArrayBufferView
// Ret value: void
JSBool JSB_glReadPixels(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 7, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; uint32_t arg4; uint32_t arg5; void* arg6; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= jsval_to_int32( cx, *argvp++, &arg3 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg4 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg5 );
	GLsizei count;
	ok &= JSB_get_arraybufferview_dataptr( cx, *argvp++, &count, &arg6);
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glReadPixels((GLint)arg0 , (GLint)arg1 , (GLsizei)arg2 , (GLsizei)arg3 , (GLenum)arg4 , (GLenum)arg5 , (GLvoid*)arg6  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void
JSBool JSB_glReleaseShaderCompiler(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	glReleaseShaderCompiler( );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLenum, GLsizei, GLsizei
// Ret value: void
JSBool JSB_glRenderbufferStorage(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; int32_t arg2; int32_t arg3; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg1 );
	ok &= jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= jsval_to_int32( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glRenderbufferStorage((GLenum)arg0 , (GLenum)arg1 , (GLsizei)arg2 , (GLsizei)arg3  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLclampf, GLboolean
// Ret value: void
JSBool JSB_glSampleCoverage(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; uint16_t arg1; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint16( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glSampleCoverage((GLclampf)arg0 , (GLboolean)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLint, GLsizei, GLsizei
// Ret value: void
JSBool JSB_glScissor(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= jsval_to_int32( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glScissor((GLint)arg0 , (GLint)arg1 , (GLsizei)arg2 , (GLsizei)arg3  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLint, GLuint
// Ret value: void
JSBool JSB_glStencilFunc(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; int32_t arg1; uint32_t arg2; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glStencilFunc((GLenum)arg0 , (GLint)arg1 , (GLuint)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLenum, GLint, GLuint
// Ret value: void
JSBool JSB_glStencilFuncSeparate(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; int32_t arg2; uint32_t arg3; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg1 );
	ok &= jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glStencilFuncSeparate((GLenum)arg0 , (GLenum)arg1 , (GLint)arg2 , (GLuint)arg3  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLuint
// Ret value: void
JSBool JSB_glStencilMask(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glStencilMask((GLuint)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLuint
// Ret value: void
JSBool JSB_glStencilMaskSeparate(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glStencilMaskSeparate((GLenum)arg0 , (GLuint)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLenum, GLenum
// Ret value: void
JSBool JSB_glStencilOp(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; uint32_t arg2; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg1 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glStencilOp((GLenum)arg0 , (GLenum)arg1 , (GLenum)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLenum, GLenum, GLenum
// Ret value: void
JSBool JSB_glStencilOpSeparate(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; uint32_t arg2; uint32_t arg3; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg1 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg2 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glStencilOpSeparate((GLenum)arg0 , (GLenum)arg1 , (GLenum)arg2 , (GLenum)arg3  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, ArrayBufferView
// Ret value: void
JSBool JSB_glTexImage2D(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 9, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; int32_t arg4; int32_t arg5; uint32_t arg6; uint32_t arg7; void* arg8; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= jsval_to_int32( cx, *argvp++, &arg3 );
	ok &= jsval_to_int32( cx, *argvp++, &arg4 );
	ok &= jsval_to_int32( cx, *argvp++, &arg5 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg6 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg7 );
	GLsizei count;
	ok &= JSB_get_arraybufferview_dataptr( cx, *argvp++, &count, &arg8);
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glTexImage2D((GLenum)arg0 , (GLint)arg1 , (GLint)arg2 , (GLsizei)arg3 , (GLsizei)arg4 , (GLint)arg5 , (GLenum)arg6 , (GLenum)arg7 , (GLvoid*)arg8  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLenum, GLfloat
// Ret value: void
JSBool JSB_glTexParameterf(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; int32_t arg2; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg1 );
	ok &= jsval_to_int32( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glTexParameterf((GLenum)arg0 , (GLenum)arg1 , (GLfloat)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLenum, GLint
// Ret value: void
JSBool JSB_glTexParameteri(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; uint32_t arg1; int32_t arg2; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg1 );
	ok &= jsval_to_int32( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glTexParameteri((GLenum)arg0 , (GLenum)arg1 , (GLint)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, ArrayBufferView
// Ret value: void
JSBool JSB_glTexSubImage2D(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 9, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; int32_t arg4; int32_t arg5; uint32_t arg6; uint32_t arg7; void* arg8; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= jsval_to_int32( cx, *argvp++, &arg3 );
	ok &= jsval_to_int32( cx, *argvp++, &arg4 );
	ok &= jsval_to_int32( cx, *argvp++, &arg5 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg6 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg7 );
	GLsizei count;
	ok &= JSB_get_arraybufferview_dataptr( cx, *argvp++, &count, &arg8);
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glTexSubImage2D((GLenum)arg0 , (GLint)arg1 , (GLint)arg2 , (GLint)arg3 , (GLsizei)arg4 , (GLsizei)arg5 , (GLenum)arg6 , (GLenum)arg7 , (GLvoid*)arg8  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLfloat
// Ret value: void
JSBool JSB_glUniform1f(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glUniform1f((GLint)arg0 , (GLfloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLsizei, TypedArray/Sequence
// Ret value: void
JSBool JSB_glUniform1fv(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; void* arg2; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	GLsizei count;
	ok &= JSB_jsval_typedarray_to_dataptr( cx, *argvp++, &count, &arg2, js::ArrayBufferView::TYPE_FLOAT32);
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glUniform1fv((GLint)arg0 , (GLsizei)arg1 , (GLfloat*)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLint
// Ret value: void
JSBool JSB_glUniform1i(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glUniform1i((GLint)arg0 , (GLint)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLsizei, TypedArray/Sequence
// Ret value: void
JSBool JSB_glUniform1iv(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; void* arg2; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	GLsizei count;
	ok &= JSB_jsval_typedarray_to_dataptr( cx, *argvp++, &count, &arg2, js::ArrayBufferView::TYPE_INT32);
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glUniform1iv((GLint)arg0 , (GLsizei)arg1 , (GLint*)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLfloat, GLfloat
// Ret value: void
JSBool JSB_glUniform2f(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; int32_t arg2; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= jsval_to_int32( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glUniform2f((GLint)arg0 , (GLfloat)arg1 , (GLfloat)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLsizei, TypedArray/Sequence
// Ret value: void
JSBool JSB_glUniform2fv(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; void* arg2; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	GLsizei count;
	ok &= JSB_jsval_typedarray_to_dataptr( cx, *argvp++, &count, &arg2, js::ArrayBufferView::TYPE_FLOAT32);
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glUniform2fv((GLint)arg0 , (GLsizei)arg1 , (GLfloat*)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLint, GLint
// Ret value: void
JSBool JSB_glUniform2i(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; int32_t arg2; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= jsval_to_int32( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glUniform2i((GLint)arg0 , (GLint)arg1 , (GLint)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLsizei, TypedArray/Sequence
// Ret value: void
JSBool JSB_glUniform2iv(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; void* arg2; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	GLsizei count;
	ok &= JSB_jsval_typedarray_to_dataptr( cx, *argvp++, &count, &arg2, js::ArrayBufferView::TYPE_INT32);
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glUniform2iv((GLint)arg0 , (GLsizei)arg1 , (GLint*)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLfloat, GLfloat, GLfloat
// Ret value: void
JSBool JSB_glUniform3f(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= jsval_to_int32( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glUniform3f((GLint)arg0 , (GLfloat)arg1 , (GLfloat)arg2 , (GLfloat)arg3  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLsizei, TypedArray/Sequence
// Ret value: void
JSBool JSB_glUniform3fv(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; void* arg2; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	GLsizei count;
	ok &= JSB_jsval_typedarray_to_dataptr( cx, *argvp++, &count, &arg2, js::ArrayBufferView::TYPE_FLOAT32);
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glUniform3fv((GLint)arg0 , (GLsizei)arg1 , (GLfloat*)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLint, GLint, GLint
// Ret value: void
JSBool JSB_glUniform3i(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= jsval_to_int32( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glUniform3i((GLint)arg0 , (GLint)arg1 , (GLint)arg2 , (GLint)arg3  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLsizei, TypedArray/Sequence
// Ret value: void
JSBool JSB_glUniform3iv(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; void* arg2; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	GLsizei count;
	ok &= JSB_jsval_typedarray_to_dataptr( cx, *argvp++, &count, &arg2, js::ArrayBufferView::TYPE_INT32);
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glUniform3iv((GLint)arg0 , (GLsizei)arg1 , (GLint*)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLfloat, GLfloat, GLfloat, GLfloat
// Ret value: void
JSBool JSB_glUniform4f(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 5, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; int32_t arg4; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= jsval_to_int32( cx, *argvp++, &arg3 );
	ok &= jsval_to_int32( cx, *argvp++, &arg4 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glUniform4f((GLint)arg0 , (GLfloat)arg1 , (GLfloat)arg2 , (GLfloat)arg3 , (GLfloat)arg4  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLsizei, TypedArray/Sequence
// Ret value: void
JSBool JSB_glUniform4fv(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; void* arg2; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	GLsizei count;
	ok &= JSB_jsval_typedarray_to_dataptr( cx, *argvp++, &count, &arg2, js::ArrayBufferView::TYPE_FLOAT32);
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glUniform4fv((GLint)arg0 , (GLsizei)arg1 , (GLfloat*)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLint, GLint, GLint, GLint
// Ret value: void
JSBool JSB_glUniform4i(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 5, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; int32_t arg4; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= jsval_to_int32( cx, *argvp++, &arg3 );
	ok &= jsval_to_int32( cx, *argvp++, &arg4 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glUniform4i((GLint)arg0 , (GLint)arg1 , (GLint)arg2 , (GLint)arg3 , (GLint)arg4  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLsizei, TypedArray/Sequence
// Ret value: void
JSBool JSB_glUniform4iv(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; void* arg2; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	GLsizei count;
	ok &= JSB_jsval_typedarray_to_dataptr( cx, *argvp++, &count, &arg2, js::ArrayBufferView::TYPE_INT32);
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glUniform4iv((GLint)arg0 , (GLsizei)arg1 , (GLint*)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLboolean, TypedArray/Sequence
// Ret value: void
JSBool JSB_glUniformMatrix2fv(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; uint16_t arg1; void* arg2; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint16( cx, *argvp++, &arg1 );
	GLsizei count;
	ok &= JSB_jsval_typedarray_to_dataptr( cx, *argvp++, &count, &arg2, js::ArrayBufferView::TYPE_FLOAT32);
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glUniformMatrix2fv(arg0, 1, (GLboolean)arg1 , (GLfloat*)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLboolean, TypedArray/Sequence
// Ret value: void
JSBool JSB_glUniformMatrix3fv(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; uint16_t arg1; void* arg2; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint16( cx, *argvp++, &arg1 );
	GLsizei count;
	ok &= JSB_jsval_typedarray_to_dataptr( cx, *argvp++, &count, &arg2, js::ArrayBufferView::TYPE_FLOAT32);
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glUniformMatrix3fv(arg0, 1, (GLboolean)arg1 , (GLfloat*)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLboolean, TypedArray/Sequence
// Ret value: void
JSBool JSB_glUniformMatrix4fv(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; uint16_t arg1; void* arg2; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_uint16( cx, *argvp++, &arg1 );
	GLsizei count;
	ok &= JSB_jsval_typedarray_to_dataptr( cx, *argvp++, &count, &arg2, js::ArrayBufferView::TYPE_FLOAT32);
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glUniformMatrix4fv(arg0, 1, (GLboolean)arg1 , (GLfloat*)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLuint
// Ret value: void
JSBool JSB_glUseProgram(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glUseProgram((GLuint)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLuint
// Ret value: void
JSBool JSB_glValidateProgram(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glValidateProgram((GLuint)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLuint, GLfloat
// Ret value: void
JSBool JSB_glVertexAttrib1f(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; int32_t arg1; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glVertexAttrib1f((GLuint)arg0 , (GLfloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLuint, TypedArray/Sequence
// Ret value: void
JSBool JSB_glVertexAttrib1fv(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; void* arg1; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	GLsizei count;
	ok &= JSB_jsval_typedarray_to_dataptr( cx, *argvp++, &count, &arg1, js::ArrayBufferView::TYPE_FLOAT32);
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glVertexAttrib1fv((GLuint)arg0 , (GLfloat*)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLuint, GLfloat, GLfloat
// Ret value: void
JSBool JSB_glVertexAttrib2f(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; int32_t arg1; int32_t arg2; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= jsval_to_int32( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glVertexAttrib2f((GLuint)arg0 , (GLfloat)arg1 , (GLfloat)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLuint, TypedArray/Sequence
// Ret value: void
JSBool JSB_glVertexAttrib2fv(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; void* arg1; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	GLsizei count;
	ok &= JSB_jsval_typedarray_to_dataptr( cx, *argvp++, &count, &arg1, js::ArrayBufferView::TYPE_FLOAT32);
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glVertexAttrib2fv((GLuint)arg0 , (GLfloat*)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLuint, GLfloat, GLfloat, GLfloat
// Ret value: void
JSBool JSB_glVertexAttrib3f(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= jsval_to_int32( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glVertexAttrib3f((GLuint)arg0 , (GLfloat)arg1 , (GLfloat)arg2 , (GLfloat)arg3  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLuint, TypedArray/Sequence
// Ret value: void
JSBool JSB_glVertexAttrib3fv(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; void* arg1; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	GLsizei count;
	ok &= JSB_jsval_typedarray_to_dataptr( cx, *argvp++, &count, &arg1, js::ArrayBufferView::TYPE_FLOAT32);
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glVertexAttrib3fv((GLuint)arg0 , (GLfloat*)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLuint, GLfloat, GLfloat, GLfloat, GLfloat
// Ret value: void
JSBool JSB_glVertexAttrib4f(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 5, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; int32_t arg4; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= jsval_to_int32( cx, *argvp++, &arg3 );
	ok &= jsval_to_int32( cx, *argvp++, &arg4 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glVertexAttrib4f((GLuint)arg0 , (GLfloat)arg1 , (GLfloat)arg2 , (GLfloat)arg3 , (GLfloat)arg4  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLuint, TypedArray/Sequence
// Ret value: void
JSBool JSB_glVertexAttrib4fv(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; void* arg1; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	GLsizei count;
	ok &= JSB_jsval_typedarray_to_dataptr( cx, *argvp++, &count, &arg1, js::ArrayBufferView::TYPE_FLOAT32);
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glVertexAttrib4fv((GLuint)arg0 , (GLfloat*)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLuint, GLint, GLenum, GLboolean, GLsizei, GLvoid*
// Ret value: void
JSBool JSB_glVertexAttribPointer(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 6, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg0; int32_t arg1; uint32_t arg2; uint16_t arg3; int32_t arg4; int32_t arg5; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg2 );
	ok &= jsval_to_uint16( cx, *argvp++, &arg3 );
	ok &= jsval_to_int32( cx, *argvp++, &arg4 );
	ok &= jsval_to_int32( cx, *argvp++, &arg5 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glVertexAttribPointer((GLuint)arg0 , (GLint)arg1 , (GLenum)arg2 , (GLboolean)arg3 , (GLsizei)arg4 , (GLvoid*)arg5  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: GLint, GLint, GLsizei, GLsizei
// Ret value: void
JSBool JSB_glViewport(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 4, cx, JS_FALSE, "Invalid number of arguments" );
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; 

	ok &= jsval_to_int32( cx, *argvp++, &arg0 );
	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	ok &= jsval_to_int32( cx, *argvp++, &arg2 );
	ok &= jsval_to_int32( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	glViewport((GLint)arg0 , (GLint)arg1 , (GLsizei)arg2 , (GLsizei)arg3  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}


#endif // JSB_INCLUDE_OPENGL

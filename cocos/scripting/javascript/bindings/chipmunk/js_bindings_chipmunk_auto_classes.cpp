/*
* AUTOGENERATED FILE. DO NOT EDIT IT
* Generated by "generate_js_bindings.py -c chipmunk_jsb.ini" on 2012-11-07
* Script version: v0.3
*/
#include "js_bindings_config.h"
#ifdef JSB_INCLUDE_CHIPMUNK

#include "js_bindings_chipmunk_manual.h"

#include "jsfriendapi.h"
#include "js_bindings_config.h"
#include "js_manual_conversions.h"
#include "js_bindings_chipmunk_functions.h"

/*
 * cpConstraint
 */
#pragma mark - cpConstraint

JSClass* JSB_cpConstraint_class = NULL;
JSObject* JSB_cpConstraint_object = NULL;

// Constructor
JSBool JSB_cpConstraint_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSB_PRECONDITION2(argc==0, cx, JS_FALSE, "Invalid number of arguments");
	JSB_PRECONDITION2(false, cx, JS_TRUE, "No constructor");

	return JS_TRUE;
}

// Destructor
void JSB_cpConstraint_finalize(JSFreeOp *fop, JSObject *jsthis)
{
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	if( proxy ) {
		CCLOGINFO("jsbindings: finalizing JS object %p (cpConstraint), handle: %p", jsthis, proxy->handle);

		jsb_del_jsobject_for_proxy(proxy->handle);
		if(proxy->flags == JSB_C_FLAG_CALL_FREE)
			cpConstraintFree( (cpConstraint*)proxy->handle);
		jsb_del_c_proxy_for_jsobject(jsthis);
	} else {
		CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpConstraint)", jsthis);
	}
}

// Arguments: 
// Ret value: void
JSBool JSB_cpConstraint_activateBodies(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->handle;

	cpConstraintActivateBodies((cpConstraint*)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void
JSBool JSB_cpConstraint_destroy(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->handle;

	cpConstraintDestroy((cpConstraint*)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpBody*
JSBool JSB_cpConstraint_getA(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->handle;
	cpBody* ret_val;

	ret_val = cpConstraintGetA((cpConstraint*)arg0  );

	jsval ret_jsval = c_class_to_jsval( cx, ret_val, JSB_cpBody_object, JSB_cpBody_class, "cpBody" );
	JS_SET_RVAL(cx, vp, ret_jsval);
    
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpBody*
JSBool JSB_cpConstraint_getB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->handle;
	cpBody* ret_val;

	ret_val = cpConstraintGetB((cpConstraint*)arg0  );

	jsval ret_jsval = c_class_to_jsval( cx, ret_val, JSB_cpBody_object, JSB_cpBody_class, "cpBody" );
	JS_SET_RVAL(cx, vp, ret_jsval);
    
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpConstraint_getErrorBias(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpConstraintGetErrorBias((cpConstraint*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpConstraint_getImpulse(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpConstraintGetImpulse((cpConstraint*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpConstraint_getMaxBias(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpConstraintGetMaxBias((cpConstraint*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpConstraint_getMaxForce(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpConstraintGetMaxForce((cpConstraint*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpSpace*
JSBool JSB_cpConstraint_getSpace(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->handle;
	cpSpace* ret_val;

	ret_val = cpConstraintGetSpace((cpConstraint*)arg0  );

	jsval ret_jsval = c_class_to_jsval( cx, ret_val, JSB_cpSpace_object, JSB_cpSpace_class, "cpSpace" );
	JS_SET_RVAL(cx, vp, ret_jsval);
    
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpConstraint_setErrorBias(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpConstraintSetErrorBias((cpConstraint*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpConstraint_setMaxBias(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpConstraintSetMaxBias((cpConstraint*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpConstraint_setMaxForce(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpConstraint* arg0 = (cpConstraint*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpConstraintSetMaxForce((cpConstraint*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

void JSB_cpConstraint_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_cpConstraint_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_cpConstraint_class->name = name;
	JSB_cpConstraint_class->addProperty = JS_PropertyStub;
	JSB_cpConstraint_class->delProperty = JS_DeletePropertyStub;
	JSB_cpConstraint_class->getProperty = JS_PropertyStub;
	JSB_cpConstraint_class->setProperty = JS_StrictPropertyStub;
	JSB_cpConstraint_class->enumerate = JS_EnumerateStub;
	JSB_cpConstraint_class->resolve = JS_ResolveStub;
	JSB_cpConstraint_class->convert = JS_ConvertStub;
	JSB_cpConstraint_class->finalize = JSB_cpConstraint_finalize;
	JSB_cpConstraint_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("activateBodies", JSB_cpConstraint_activateBodies, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("destroy", JSB_cpConstraint_destroy, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getA", JSB_cpConstraint_getA, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getB", JSB_cpConstraint_getB, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getErrorBias", JSB_cpConstraint_getErrorBias, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getImpulse", JSB_cpConstraint_getImpulse, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getMaxBias", JSB_cpConstraint_getMaxBias, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getMaxForce", JSB_cpConstraint_getMaxForce, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getSpace", JSB_cpConstraint_getSpace, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setErrorBias", JSB_cpConstraint_setErrorBias, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setMaxBias", JSB_cpConstraint_setMaxBias, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setMaxForce", JSB_cpConstraint_setMaxForce, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_cpConstraint_object = JS_InitClass(cx, globalObj, JSB_cpBase_object, JSB_cpConstraint_class, JSB_cpConstraint_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

/*
 * cpGrooveJoint
 */
#pragma mark - cpGrooveJoint

JSClass* JSB_cpGrooveJoint_class = NULL;
JSObject* JSB_cpGrooveJoint_object = NULL;
// Arguments: cpBody*, cpBody*, cpVect, cpVect, cpVect
// Constructor
JSBool JSB_cpGrooveJoint_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSB_PRECONDITION2(argc==5, cx, JS_FALSE, "Invalid number of arguments");
	JSObject *jsobj = JS_NewObject(cx, JSB_cpGrooveJoint_class, JSB_cpGrooveJoint_object, NULL);
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpBody* arg0; cpBody* arg1; cpVect arg2; cpVect arg3; cpVect arg4; 

	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg0, NULL );
	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg1, NULL );
	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg2 );
	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg3 );
	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg4 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	void* 	ret_val = cpGrooveJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpVect)arg2 , (cpVect)arg3 , (cpVect)arg4  );

	jsb_set_jsobject_for_proxy(jsobj, ret_val);
	jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Destructor
void JSB_cpGrooveJoint_finalize(JSFreeOp *fop, JSObject *jsthis)
{
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	if( proxy ) {
		CCLOGINFO("jsbindings: finalizing JS object %p (cpGrooveJoint), handle: %p", jsthis, proxy->handle);

		jsb_del_jsobject_for_proxy(proxy->handle);
		if(proxy->flags == JSB_C_FLAG_CALL_FREE)
			cpConstraintFree( (cpConstraint*)proxy->handle);
		jsb_del_c_proxy_for_jsobject(jsthis);
	} else {
		CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpGrooveJoint)", jsthis);
	}
}

// Arguments: 
// Ret value: cpVect
JSBool JSB_cpGrooveJoint_getAnchr2(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpGrooveJoint* arg0 = (cpGrooveJoint*) proxy->handle;
	cpVect ret_val;

	ret_val = cpGrooveJointGetAnchr2((cpConstraint*)arg0  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpVect
JSBool JSB_cpGrooveJoint_getGrooveA(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpGrooveJoint* arg0 = (cpGrooveJoint*) proxy->handle;
	cpVect ret_val;

	ret_val = cpGrooveJointGetGrooveA((cpConstraint*)arg0  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpVect
JSBool JSB_cpGrooveJoint_getGrooveB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpGrooveJoint* arg0 = (cpGrooveJoint*) proxy->handle;
	cpVect ret_val;

	ret_val = cpGrooveJointGetGrooveB((cpConstraint*)arg0  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: void
JSBool JSB_cpGrooveJoint_setAnchr2(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpGrooveJoint* arg0 = (cpGrooveJoint*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpGrooveJointSetAnchr2((cpConstraint*)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: void
JSBool JSB_cpGrooveJoint_setGrooveA(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpGrooveJoint* arg0 = (cpGrooveJoint*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpGrooveJointSetGrooveA((cpConstraint*)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: void
JSBool JSB_cpGrooveJoint_setGrooveB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpGrooveJoint* arg0 = (cpGrooveJoint*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpGrooveJointSetGrooveB((cpConstraint*)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

void JSB_cpGrooveJoint_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_cpGrooveJoint_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_cpGrooveJoint_class->name = name;
	JSB_cpGrooveJoint_class->addProperty = JS_PropertyStub;
	JSB_cpGrooveJoint_class->delProperty = JS_DeletePropertyStub;
	JSB_cpGrooveJoint_class->getProperty = JS_PropertyStub;
	JSB_cpGrooveJoint_class->setProperty = JS_StrictPropertyStub;
	JSB_cpGrooveJoint_class->enumerate = JS_EnumerateStub;
	JSB_cpGrooveJoint_class->resolve = JS_ResolveStub;
	JSB_cpGrooveJoint_class->convert = JS_ConvertStub;
	JSB_cpGrooveJoint_class->finalize = JSB_cpGrooveJoint_finalize;
	JSB_cpGrooveJoint_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAnchr2", JSB_cpGrooveJoint_getAnchr2, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getGrooveA", JSB_cpGrooveJoint_getGrooveA, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getGrooveB", JSB_cpGrooveJoint_getGrooveB, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setAnchr2", JSB_cpGrooveJoint_setAnchr2, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setGrooveA", JSB_cpGrooveJoint_setGrooveA, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setGrooveB", JSB_cpGrooveJoint_setGrooveB, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_cpGrooveJoint_object = JS_InitClass(cx, globalObj, JSB_cpConstraint_object, JSB_cpGrooveJoint_class, JSB_cpGrooveJoint_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

/*
 * cpSimpleMotor
 */
#pragma mark - cpSimpleMotor

JSClass* JSB_cpSimpleMotor_class = NULL;
JSObject* JSB_cpSimpleMotor_object = NULL;
// Arguments: cpBody*, cpBody*, cpFloat
// Constructor
JSBool JSB_cpSimpleMotor_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSB_PRECONDITION2(argc==3, cx, JS_FALSE, "Invalid number of arguments");
	JSObject *jsobj = JS_NewObject(cx, JSB_cpSimpleMotor_class, JSB_cpSimpleMotor_object, NULL);
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpBody* arg0; cpBody* arg1; double arg2; 

	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg0, NULL );
	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg1, NULL );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	void* 	ret_val = cpSimpleMotorNew((cpBody*)arg0 , (cpBody*)arg1 , (cpFloat)arg2  );

	jsb_set_jsobject_for_proxy(jsobj, ret_val);
	jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Destructor
void JSB_cpSimpleMotor_finalize(JSFreeOp *fop, JSObject *jsthis)
{
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	if( proxy ) {
		CCLOGINFO("jsbindings: finalizing JS object %p (cpSimpleMotor), handle: %p", jsthis, proxy->handle);

		jsb_del_jsobject_for_proxy(proxy->handle);
		if(proxy->flags == JSB_C_FLAG_CALL_FREE)
			cpConstraintFree( (cpConstraint*)proxy->handle);
		jsb_del_c_proxy_for_jsobject(jsthis);
	} else {
		CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpSimpleMotor)", jsthis);
	}
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpSimpleMotor_getRate(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSimpleMotor* arg0 = (cpSimpleMotor*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpSimpleMotorGetRate((cpConstraint*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpSimpleMotor_setRate(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSimpleMotor* arg0 = (cpSimpleMotor*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpSimpleMotorSetRate((cpConstraint*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

void JSB_cpSimpleMotor_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_cpSimpleMotor_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_cpSimpleMotor_class->name = name;
	JSB_cpSimpleMotor_class->addProperty = JS_PropertyStub;
	JSB_cpSimpleMotor_class->delProperty = JS_DeletePropertyStub;
	JSB_cpSimpleMotor_class->getProperty = JS_PropertyStub;
	JSB_cpSimpleMotor_class->setProperty = JS_StrictPropertyStub;
	JSB_cpSimpleMotor_class->enumerate = JS_EnumerateStub;
	JSB_cpSimpleMotor_class->resolve = JS_ResolveStub;
	JSB_cpSimpleMotor_class->convert = JS_ConvertStub;
	JSB_cpSimpleMotor_class->finalize = JSB_cpSimpleMotor_finalize;
	JSB_cpSimpleMotor_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getRate", JSB_cpSimpleMotor_getRate, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setRate", JSB_cpSimpleMotor_setRate, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_cpSimpleMotor_object = JS_InitClass(cx, globalObj, JSB_cpConstraint_object, JSB_cpSimpleMotor_class, JSB_cpSimpleMotor_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

/*
 * cpPivotJoint
 */
#pragma mark - cpPivotJoint

JSClass* JSB_cpPivotJoint_class = NULL;
JSObject* JSB_cpPivotJoint_object = NULL;
// Arguments: cpBody*, cpBody*, cpVect
// Constructor
JSBool JSB_cpPivotJoint_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSB_PRECONDITION2(argc==4 || argc==3, cx, JS_FALSE, "Invalid number of arguments");
	JSObject *jsobj = JS_NewObject(cx, JSB_cpPivotJoint_class, JSB_cpPivotJoint_object, NULL);
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpBody* arg0; cpBody* arg1; cpVect arg2; cpVect arg3; void *ret_val;

	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg0, NULL );
	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg1, NULL );
	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg2 );
	if(argc == 4) {
		ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg3 );
		JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
		ret_val = cpPivotJointNew2((cpBody*)arg0 , (cpBody*)arg1 , (cpVect)arg2, (cpVect)arg3  );
	} else {
		JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
		ret_val = cpPivotJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpVect)arg2);
	}

	jsb_set_jsobject_for_proxy(jsobj, ret_val);
	jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}
// Destructor
void JSB_cpPivotJoint_finalize(JSFreeOp *fop, JSObject *jsthis)
{
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	if( proxy ) {
		CCLOGINFO("jsbindings: finalizing JS object %p (cpPivotJoint), handle: %p", jsthis, proxy->handle);

		jsb_del_jsobject_for_proxy(proxy->handle);
		if(proxy->flags == JSB_C_FLAG_CALL_FREE)
			cpConstraintFree( (cpConstraint*)proxy->handle);
		jsb_del_c_proxy_for_jsobject(jsthis);
	} else {
		CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpPivotJoint)", jsthis);
	}
}

// Arguments: 
// Ret value: cpVect
JSBool JSB_cpPivotJoint_getAnchr1(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpPivotJoint* arg0 = (cpPivotJoint*) proxy->handle;
	cpVect ret_val;

	ret_val = cpPivotJointGetAnchr1((cpConstraint*)arg0  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpVect
JSBool JSB_cpPivotJoint_getAnchr2(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpPivotJoint* arg0 = (cpPivotJoint*) proxy->handle;
	cpVect ret_val;

	ret_val = cpPivotJointGetAnchr2((cpConstraint*)arg0  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: void
JSBool JSB_cpPivotJoint_setAnchr1(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpPivotJoint* arg0 = (cpPivotJoint*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpPivotJointSetAnchr1((cpConstraint*)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: void
JSBool JSB_cpPivotJoint_setAnchr2(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpPivotJoint* arg0 = (cpPivotJoint*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpPivotJointSetAnchr2((cpConstraint*)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

void JSB_cpPivotJoint_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_cpPivotJoint_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_cpPivotJoint_class->name = name;
	JSB_cpPivotJoint_class->addProperty = JS_PropertyStub;
	JSB_cpPivotJoint_class->delProperty = JS_DeletePropertyStub;
	JSB_cpPivotJoint_class->getProperty = JS_PropertyStub;
	JSB_cpPivotJoint_class->setProperty = JS_StrictPropertyStub;
	JSB_cpPivotJoint_class->enumerate = JS_EnumerateStub;
	JSB_cpPivotJoint_class->resolve = JS_ResolveStub;
	JSB_cpPivotJoint_class->convert = JS_ConvertStub;
	JSB_cpPivotJoint_class->finalize = JSB_cpPivotJoint_finalize;
	JSB_cpPivotJoint_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAnchr1", JSB_cpPivotJoint_getAnchr1, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getAnchr2", JSB_cpPivotJoint_getAnchr2, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setAnchr1", JSB_cpPivotJoint_setAnchr1, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setAnchr2", JSB_cpPivotJoint_setAnchr2, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_cpPivotJoint_object = JS_InitClass(cx, globalObj, JSB_cpConstraint_object, JSB_cpPivotJoint_class, JSB_cpPivotJoint_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

/*
 * cpPinJoint
 */
#pragma mark - cpPinJoint

JSClass* JSB_cpPinJoint_class = NULL;
JSObject* JSB_cpPinJoint_object = NULL;
// Arguments: cpBody*, cpBody*, cpVect, cpVect
// Constructor
JSBool JSB_cpPinJoint_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSB_PRECONDITION2(argc==4, cx, JS_FALSE, "Invalid number of arguments");
	JSObject *jsobj = JS_NewObject(cx, JSB_cpPinJoint_class, JSB_cpPinJoint_object, NULL);
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpBody* arg0; cpBody* arg1; cpVect arg2; cpVect arg3; 

	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg0, NULL );
	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg1, NULL );
	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg2 );
	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	void* 	ret_val = cpPinJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpVect)arg2 , (cpVect)arg3  );

	jsb_set_jsobject_for_proxy(jsobj, ret_val);
	jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Destructor
void JSB_cpPinJoint_finalize(JSFreeOp *fop, JSObject *jsthis)
{
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	if( proxy ) {
		CCLOGINFO("jsbindings: finalizing JS object %p (cpPinJoint), handle: %p", jsthis, proxy->handle);

		jsb_del_jsobject_for_proxy(proxy->handle);
		if(proxy->flags == JSB_C_FLAG_CALL_FREE)
			cpConstraintFree( (cpConstraint*)proxy->handle);
		jsb_del_c_proxy_for_jsobject(jsthis);
	} else {
		CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpPinJoint)", jsthis);
	}
}

// Arguments: 
// Ret value: cpVect
JSBool JSB_cpPinJoint_getAnchr1(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpPinJoint* arg0 = (cpPinJoint*) proxy->handle;
	cpVect ret_val;

	ret_val = cpPinJointGetAnchr1((cpConstraint*)arg0  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpVect
JSBool JSB_cpPinJoint_getAnchr2(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpPinJoint* arg0 = (cpPinJoint*) proxy->handle;
	cpVect ret_val;

	ret_val = cpPinJointGetAnchr2((cpConstraint*)arg0  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpPinJoint_getDist(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpPinJoint* arg0 = (cpPinJoint*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpPinJointGetDist((cpConstraint*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: void
JSBool JSB_cpPinJoint_setAnchr1(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpPinJoint* arg0 = (cpPinJoint*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpPinJointSetAnchr1((cpConstraint*)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: void
JSBool JSB_cpPinJoint_setAnchr2(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpPinJoint* arg0 = (cpPinJoint*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpPinJointSetAnchr2((cpConstraint*)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpPinJoint_setDist(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpPinJoint* arg0 = (cpPinJoint*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpPinJointSetDist((cpConstraint*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

void JSB_cpPinJoint_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_cpPinJoint_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_cpPinJoint_class->name = name;
	JSB_cpPinJoint_class->addProperty = JS_PropertyStub;
	JSB_cpPinJoint_class->delProperty = JS_DeletePropertyStub;
	JSB_cpPinJoint_class->getProperty = JS_PropertyStub;
	JSB_cpPinJoint_class->setProperty = JS_StrictPropertyStub;
	JSB_cpPinJoint_class->enumerate = JS_EnumerateStub;
	JSB_cpPinJoint_class->resolve = JS_ResolveStub;
	JSB_cpPinJoint_class->convert = JS_ConvertStub;
	JSB_cpPinJoint_class->finalize = JSB_cpPinJoint_finalize;
	JSB_cpPinJoint_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAnchr1", JSB_cpPinJoint_getAnchr1, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getAnchr2", JSB_cpPinJoint_getAnchr2, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getDist", JSB_cpPinJoint_getDist, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setAnchr1", JSB_cpPinJoint_setAnchr1, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setAnchr2", JSB_cpPinJoint_setAnchr2, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setDist", JSB_cpPinJoint_setDist, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_cpPinJoint_object = JS_InitClass(cx, globalObj, JSB_cpConstraint_object, JSB_cpPinJoint_class, JSB_cpPinJoint_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

/*
 * cpSlideJoint
 */
#pragma mark - cpSlideJoint

JSClass* JSB_cpSlideJoint_class = NULL;
JSObject* JSB_cpSlideJoint_object = NULL;
// Arguments: cpBody*, cpBody*, cpVect, cpVect, cpFloat, cpFloat
// Constructor
JSBool JSB_cpSlideJoint_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSB_PRECONDITION2(argc==6, cx, JS_FALSE, "Invalid number of arguments");
	JSObject *jsobj = JS_NewObject(cx, JSB_cpSlideJoint_class, JSB_cpSlideJoint_object, NULL);
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpBody* arg0; cpBody* arg1; cpVect arg2; cpVect arg3; double arg4; double arg5; 

	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg0, NULL );
	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg1, NULL );
	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg2 );
	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg3 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg4 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg5 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	void* 	ret_val = cpSlideJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpVect)arg2 , (cpVect)arg3 , (cpFloat)arg4 , (cpFloat)arg5  );

	jsb_set_jsobject_for_proxy(jsobj, ret_val);
	jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Destructor
void JSB_cpSlideJoint_finalize(JSFreeOp *fop, JSObject *jsthis)
{
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	if( proxy ) {
		CCLOGINFO("jsbindings: finalizing JS object %p (cpSlideJoint), handle: %p", jsthis, proxy->handle);

		jsb_del_jsobject_for_proxy(proxy->handle);
		if(proxy->flags == JSB_C_FLAG_CALL_FREE)
			cpConstraintFree( (cpConstraint*)proxy->handle);
		jsb_del_c_proxy_for_jsobject(jsthis);
	} else {
		CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpSlideJoint)", jsthis);
	}
}

// Arguments: 
// Ret value: cpVect
JSBool JSB_cpSlideJoint_getAnchr1(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSlideJoint* arg0 = (cpSlideJoint*) proxy->handle;
	cpVect ret_val;

	ret_val = cpSlideJointGetAnchr1((cpConstraint*)arg0  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpVect
JSBool JSB_cpSlideJoint_getAnchr2(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSlideJoint* arg0 = (cpSlideJoint*) proxy->handle;
	cpVect ret_val;

	ret_val = cpSlideJointGetAnchr2((cpConstraint*)arg0  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpSlideJoint_getMax(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSlideJoint* arg0 = (cpSlideJoint*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpSlideJointGetMax((cpConstraint*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpSlideJoint_getMin(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSlideJoint* arg0 = (cpSlideJoint*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpSlideJointGetMin((cpConstraint*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: void
JSBool JSB_cpSlideJoint_setAnchr1(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSlideJoint* arg0 = (cpSlideJoint*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpSlideJointSetAnchr1((cpConstraint*)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: void
JSBool JSB_cpSlideJoint_setAnchr2(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSlideJoint* arg0 = (cpSlideJoint*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpSlideJointSetAnchr2((cpConstraint*)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpSlideJoint_setMax(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSlideJoint* arg0 = (cpSlideJoint*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpSlideJointSetMax((cpConstraint*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpSlideJoint_setMin(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSlideJoint* arg0 = (cpSlideJoint*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpSlideJointSetMin((cpConstraint*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

void JSB_cpSlideJoint_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_cpSlideJoint_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_cpSlideJoint_class->name = name;
	JSB_cpSlideJoint_class->addProperty = JS_PropertyStub;
	JSB_cpSlideJoint_class->delProperty = JS_DeletePropertyStub;
	JSB_cpSlideJoint_class->getProperty = JS_PropertyStub;
	JSB_cpSlideJoint_class->setProperty = JS_StrictPropertyStub;
	JSB_cpSlideJoint_class->enumerate = JS_EnumerateStub;
	JSB_cpSlideJoint_class->resolve = JS_ResolveStub;
	JSB_cpSlideJoint_class->convert = JS_ConvertStub;
	JSB_cpSlideJoint_class->finalize = JSB_cpSlideJoint_finalize;
	JSB_cpSlideJoint_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAnchr1", JSB_cpSlideJoint_getAnchr1, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getAnchr2", JSB_cpSlideJoint_getAnchr2, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getMax", JSB_cpSlideJoint_getMax, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getMin", JSB_cpSlideJoint_getMin, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setAnchr1", JSB_cpSlideJoint_setAnchr1, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setAnchr2", JSB_cpSlideJoint_setAnchr2, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setMax", JSB_cpSlideJoint_setMax, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setMin", JSB_cpSlideJoint_setMin, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_cpSlideJoint_object = JS_InitClass(cx, globalObj, JSB_cpConstraint_object, JSB_cpSlideJoint_class, JSB_cpSlideJoint_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

/*
 * cpGearJoint
 */
#pragma mark - cpGearJoint

JSClass* JSB_cpGearJoint_class = NULL;
JSObject* JSB_cpGearJoint_object = NULL;
// Arguments: cpBody*, cpBody*, cpFloat, cpFloat
// Constructor
JSBool JSB_cpGearJoint_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSB_PRECONDITION2(argc==4, cx, JS_FALSE, "Invalid number of arguments");
	JSObject *jsobj = JS_NewObject(cx, JSB_cpGearJoint_class, JSB_cpGearJoint_object, NULL);
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpBody* arg0; cpBody* arg1; double arg2; double arg3; 

	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg0, NULL );
	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg1, NULL );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	void* 	ret_val = cpGearJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpFloat)arg2 , (cpFloat)arg3  );

	jsb_set_jsobject_for_proxy(jsobj, ret_val);
	jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Destructor
void JSB_cpGearJoint_finalize(JSFreeOp *fop, JSObject *jsthis)
{
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	if( proxy ) {
		CCLOGINFO("jsbindings: finalizing JS object %p (cpGearJoint), handle: %p", jsthis, proxy->handle);

		jsb_del_jsobject_for_proxy(proxy->handle);
		if(proxy->flags == JSB_C_FLAG_CALL_FREE)
			cpConstraintFree( (cpConstraint*)proxy->handle);
		jsb_del_c_proxy_for_jsobject(jsthis);
	} else {
		CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpGearJoint)", jsthis);
	}
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpGearJoint_getPhase(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpGearJoint* arg0 = (cpGearJoint*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpGearJointGetPhase((cpConstraint*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpGearJoint_getRatio(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpGearJoint* arg0 = (cpGearJoint*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpGearJointGetRatio((cpConstraint*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpGearJoint_setPhase(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpGearJoint* arg0 = (cpGearJoint*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpGearJointSetPhase((cpConstraint*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpGearJoint_setRatio(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpGearJoint* arg0 = (cpGearJoint*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpGearJointSetRatio((cpConstraint*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

void JSB_cpGearJoint_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_cpGearJoint_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_cpGearJoint_class->name = name;
	JSB_cpGearJoint_class->addProperty = JS_PropertyStub;
	JSB_cpGearJoint_class->delProperty = JS_DeletePropertyStub;
	JSB_cpGearJoint_class->getProperty = JS_PropertyStub;
	JSB_cpGearJoint_class->setProperty = JS_StrictPropertyStub;
	JSB_cpGearJoint_class->enumerate = JS_EnumerateStub;
	JSB_cpGearJoint_class->resolve = JS_ResolveStub;
	JSB_cpGearJoint_class->convert = JS_ConvertStub;
	JSB_cpGearJoint_class->finalize = JSB_cpGearJoint_finalize;
	JSB_cpGearJoint_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getPhase", JSB_cpGearJoint_getPhase, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getRatio", JSB_cpGearJoint_getRatio, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setPhase", JSB_cpGearJoint_setPhase, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setRatio", JSB_cpGearJoint_setRatio, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_cpGearJoint_object = JS_InitClass(cx, globalObj, JSB_cpConstraint_object, JSB_cpGearJoint_class, JSB_cpGearJoint_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

/*
 * cpDampedRotarySpring
 */
#pragma mark - cpDampedRotarySpring

JSClass* JSB_cpDampedRotarySpring_class = NULL;
JSObject* JSB_cpDampedRotarySpring_object = NULL;
// Arguments: cpBody*, cpBody*, cpFloat, cpFloat, cpFloat
// Constructor
JSBool JSB_cpDampedRotarySpring_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSB_PRECONDITION2(argc==5, cx, JS_FALSE, "Invalid number of arguments");
	JSObject *jsobj = JS_NewObject(cx, JSB_cpDampedRotarySpring_class, JSB_cpDampedRotarySpring_object, NULL);
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpBody* arg0; cpBody* arg1; double arg2; double arg3; double arg4; 

	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg0, NULL );
	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg1, NULL );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg4 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	void* 	ret_val = cpDampedRotarySpringNew((cpBody*)arg0 , (cpBody*)arg1 , (cpFloat)arg2 , (cpFloat)arg3 , (cpFloat)arg4  );

	jsb_set_jsobject_for_proxy(jsobj, ret_val);
	jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Destructor
void JSB_cpDampedRotarySpring_finalize(JSFreeOp *fop, JSObject *jsthis)
{
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	if( proxy ) {
		CCLOGINFO("jsbindings: finalizing JS object %p (cpDampedRotarySpring), handle: %p", jsthis, proxy->handle);

		jsb_del_jsobject_for_proxy(proxy->handle);
		if(proxy->flags == JSB_C_FLAG_CALL_FREE)
			cpConstraintFree( (cpConstraint*)proxy->handle);
		jsb_del_c_proxy_for_jsobject(jsthis);
	} else {
		CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpDampedRotarySpring)", jsthis);
	}
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpDampedRotarySpring_getDamping(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpDampedRotarySpring* arg0 = (cpDampedRotarySpring*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpDampedRotarySpringGetDamping((cpConstraint*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpDampedRotarySpring_getRestAngle(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpDampedRotarySpring* arg0 = (cpDampedRotarySpring*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpDampedRotarySpringGetRestAngle((cpConstraint*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpDampedRotarySpring_getStiffness(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpDampedRotarySpring* arg0 = (cpDampedRotarySpring*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpDampedRotarySpringGetStiffness((cpConstraint*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpDampedRotarySpring_setDamping(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpDampedRotarySpring* arg0 = (cpDampedRotarySpring*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpDampedRotarySpringSetDamping((cpConstraint*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpDampedRotarySpring_setRestAngle(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpDampedRotarySpring* arg0 = (cpDampedRotarySpring*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpDampedRotarySpringSetRestAngle((cpConstraint*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpDampedRotarySpring_setStiffness(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpDampedRotarySpring* arg0 = (cpDampedRotarySpring*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpDampedRotarySpringSetStiffness((cpConstraint*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

void JSB_cpDampedRotarySpring_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_cpDampedRotarySpring_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_cpDampedRotarySpring_class->name = name;
	JSB_cpDampedRotarySpring_class->addProperty = JS_PropertyStub;
	JSB_cpDampedRotarySpring_class->delProperty = JS_DeletePropertyStub;
	JSB_cpDampedRotarySpring_class->getProperty = JS_PropertyStub;
	JSB_cpDampedRotarySpring_class->setProperty = JS_StrictPropertyStub;
	JSB_cpDampedRotarySpring_class->enumerate = JS_EnumerateStub;
	JSB_cpDampedRotarySpring_class->resolve = JS_ResolveStub;
	JSB_cpDampedRotarySpring_class->convert = JS_ConvertStub;
	JSB_cpDampedRotarySpring_class->finalize = JSB_cpDampedRotarySpring_finalize;
	JSB_cpDampedRotarySpring_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getDamping", JSB_cpDampedRotarySpring_getDamping, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getRestAngle", JSB_cpDampedRotarySpring_getRestAngle, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getStiffness", JSB_cpDampedRotarySpring_getStiffness, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setDamping", JSB_cpDampedRotarySpring_setDamping, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setRestAngle", JSB_cpDampedRotarySpring_setRestAngle, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setStiffness", JSB_cpDampedRotarySpring_setStiffness, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_cpDampedRotarySpring_object = JS_InitClass(cx, globalObj, JSB_cpConstraint_object, JSB_cpDampedRotarySpring_class, JSB_cpDampedRotarySpring_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

/*
 * cpDampedSpring
 */
#pragma mark - cpDampedSpring

JSClass* JSB_cpDampedSpring_class = NULL;
JSObject* JSB_cpDampedSpring_object = NULL;
// Arguments: cpBody*, cpBody*, cpVect, cpVect, cpFloat, cpFloat, cpFloat
// Constructor
JSBool JSB_cpDampedSpring_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSB_PRECONDITION2(argc==7, cx, JS_FALSE, "Invalid number of arguments");
	JSObject *jsobj = JS_NewObject(cx, JSB_cpDampedSpring_class, JSB_cpDampedSpring_object, NULL);
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpBody* arg0; cpBody* arg1; cpVect arg2; cpVect arg3; double arg4; double arg5; double arg6; 

	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg0, NULL );
	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg1, NULL );
	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg2 );
	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg3 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg4 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg5 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg6 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	void* 	ret_val = cpDampedSpringNew((cpBody*)arg0 , (cpBody*)arg1 , (cpVect)arg2 , (cpVect)arg3 , (cpFloat)arg4 , (cpFloat)arg5 , (cpFloat)arg6  );

	jsb_set_jsobject_for_proxy(jsobj, ret_val);
	jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Destructor
void JSB_cpDampedSpring_finalize(JSFreeOp *fop, JSObject *jsthis)
{
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	if( proxy ) {
		CCLOGINFO("jsbindings: finalizing JS object %p (cpDampedSpring), handle: %p", jsthis, proxy->handle);

		jsb_del_jsobject_for_proxy(proxy->handle);
		if(proxy->flags == JSB_C_FLAG_CALL_FREE)
			cpConstraintFree( (cpConstraint*)proxy->handle);
		jsb_del_c_proxy_for_jsobject(jsthis);
	} else {
		CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpDampedSpring)", jsthis);
	}
}

// Arguments: 
// Ret value: cpVect
JSBool JSB_cpDampedSpring_getAnchr1(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpDampedSpring* arg0 = (cpDampedSpring*) proxy->handle;
	cpVect ret_val;

	ret_val = cpDampedSpringGetAnchr1((cpConstraint*)arg0  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpVect
JSBool JSB_cpDampedSpring_getAnchr2(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpDampedSpring* arg0 = (cpDampedSpring*) proxy->handle;
	cpVect ret_val;

	ret_val = cpDampedSpringGetAnchr2((cpConstraint*)arg0  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpDampedSpring_getDamping(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpDampedSpring* arg0 = (cpDampedSpring*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpDampedSpringGetDamping((cpConstraint*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpDampedSpring_getRestLength(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpDampedSpring* arg0 = (cpDampedSpring*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpDampedSpringGetRestLength((cpConstraint*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpDampedSpring_getStiffness(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpDampedSpring* arg0 = (cpDampedSpring*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpDampedSpringGetStiffness((cpConstraint*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: void
JSBool JSB_cpDampedSpring_setAnchr1(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpDampedSpring* arg0 = (cpDampedSpring*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpDampedSpringSetAnchr1((cpConstraint*)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: void
JSBool JSB_cpDampedSpring_setAnchr2(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpDampedSpring* arg0 = (cpDampedSpring*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpDampedSpringSetAnchr2((cpConstraint*)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpDampedSpring_setDamping(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpDampedSpring* arg0 = (cpDampedSpring*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpDampedSpringSetDamping((cpConstraint*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpDampedSpring_setRestLength(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpDampedSpring* arg0 = (cpDampedSpring*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpDampedSpringSetRestLength((cpConstraint*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpDampedSpring_setStiffness(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpDampedSpring* arg0 = (cpDampedSpring*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpDampedSpringSetStiffness((cpConstraint*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

void JSB_cpDampedSpring_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_cpDampedSpring_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_cpDampedSpring_class->name = name;
	JSB_cpDampedSpring_class->addProperty = JS_PropertyStub;
	JSB_cpDampedSpring_class->delProperty = JS_DeletePropertyStub;
	JSB_cpDampedSpring_class->getProperty = JS_PropertyStub;
	JSB_cpDampedSpring_class->setProperty = JS_StrictPropertyStub;
	JSB_cpDampedSpring_class->enumerate = JS_EnumerateStub;
	JSB_cpDampedSpring_class->resolve = JS_ResolveStub;
	JSB_cpDampedSpring_class->convert = JS_ConvertStub;
	JSB_cpDampedSpring_class->finalize = JSB_cpDampedSpring_finalize;
	JSB_cpDampedSpring_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAnchr1", JSB_cpDampedSpring_getAnchr1, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getAnchr2", JSB_cpDampedSpring_getAnchr2, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getDamping", JSB_cpDampedSpring_getDamping, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getRestLength", JSB_cpDampedSpring_getRestLength, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getStiffness", JSB_cpDampedSpring_getStiffness, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setAnchr1", JSB_cpDampedSpring_setAnchr1, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setAnchr2", JSB_cpDampedSpring_setAnchr2, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setDamping", JSB_cpDampedSpring_setDamping, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setRestLength", JSB_cpDampedSpring_setRestLength, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setStiffness", JSB_cpDampedSpring_setStiffness, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_cpDampedSpring_object = JS_InitClass(cx, globalObj, JSB_cpConstraint_object, JSB_cpDampedSpring_class, JSB_cpDampedSpring_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

/*
 * cpRatchetJoint
 */
#pragma mark - cpRatchetJoint

JSClass* JSB_cpRatchetJoint_class = NULL;
JSObject* JSB_cpRatchetJoint_object = NULL;
// Arguments: cpBody*, cpBody*, cpFloat, cpFloat
// Constructor
JSBool JSB_cpRatchetJoint_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSB_PRECONDITION2(argc==4, cx, JS_FALSE, "Invalid number of arguments");
	JSObject *jsobj = JS_NewObject(cx, JSB_cpRatchetJoint_class, JSB_cpRatchetJoint_object, NULL);
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpBody* arg0; cpBody* arg1; double arg2; double arg3; 

	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg0, NULL );
	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg1, NULL );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	void* 	ret_val = cpRatchetJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpFloat)arg2 , (cpFloat)arg3  );

	jsb_set_jsobject_for_proxy(jsobj, ret_val);
	jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Destructor
void JSB_cpRatchetJoint_finalize(JSFreeOp *fop, JSObject *jsthis)
{
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	if( proxy ) {
		CCLOGINFO("jsbindings: finalizing JS object %p (cpRatchetJoint), handle: %p", jsthis, proxy->handle);

		jsb_del_jsobject_for_proxy(proxy->handle);
		if(proxy->flags == JSB_C_FLAG_CALL_FREE)
			cpConstraintFree( (cpConstraint*)proxy->handle);
		jsb_del_c_proxy_for_jsobject(jsthis);
	} else {
		CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpRatchetJoint)", jsthis);
	}
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpRatchetJoint_getAngle(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpRatchetJoint* arg0 = (cpRatchetJoint*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpRatchetJointGetAngle((cpConstraint*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpRatchetJoint_getPhase(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpRatchetJoint* arg0 = (cpRatchetJoint*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpRatchetJointGetPhase((cpConstraint*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpRatchetJoint_getRatchet(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpRatchetJoint* arg0 = (cpRatchetJoint*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpRatchetJointGetRatchet((cpConstraint*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpRatchetJoint_setAngle(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpRatchetJoint* arg0 = (cpRatchetJoint*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpRatchetJointSetAngle((cpConstraint*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpRatchetJoint_setPhase(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpRatchetJoint* arg0 = (cpRatchetJoint*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpRatchetJointSetPhase((cpConstraint*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpRatchetJoint_setRatchet(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpRatchetJoint* arg0 = (cpRatchetJoint*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpRatchetJointSetRatchet((cpConstraint*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

void JSB_cpRatchetJoint_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_cpRatchetJoint_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_cpRatchetJoint_class->name = name;
	JSB_cpRatchetJoint_class->addProperty = JS_PropertyStub;
	JSB_cpRatchetJoint_class->delProperty = JS_DeletePropertyStub;
	JSB_cpRatchetJoint_class->getProperty = JS_PropertyStub;
	JSB_cpRatchetJoint_class->setProperty = JS_StrictPropertyStub;
	JSB_cpRatchetJoint_class->enumerate = JS_EnumerateStub;
	JSB_cpRatchetJoint_class->resolve = JS_ResolveStub;
	JSB_cpRatchetJoint_class->convert = JS_ConvertStub;
	JSB_cpRatchetJoint_class->finalize = JSB_cpRatchetJoint_finalize;
	JSB_cpRatchetJoint_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getAngle", JSB_cpRatchetJoint_getAngle, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getPhase", JSB_cpRatchetJoint_getPhase, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getRatchet", JSB_cpRatchetJoint_getRatchet, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setAngle", JSB_cpRatchetJoint_setAngle, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setPhase", JSB_cpRatchetJoint_setPhase, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setRatchet", JSB_cpRatchetJoint_setRatchet, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_cpRatchetJoint_object = JS_InitClass(cx, globalObj, JSB_cpConstraint_object, JSB_cpRatchetJoint_class, JSB_cpRatchetJoint_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

/*
 * cpRotaryLimitJoint
 */
#pragma mark - cpRotaryLimitJoint

JSClass* JSB_cpRotaryLimitJoint_class = NULL;
JSObject* JSB_cpRotaryLimitJoint_object = NULL;
// Arguments: cpBody*, cpBody*, cpFloat, cpFloat
// Constructor
JSBool JSB_cpRotaryLimitJoint_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSB_PRECONDITION2(argc==4, cx, JS_FALSE, "Invalid number of arguments");
	JSObject *jsobj = JS_NewObject(cx, JSB_cpRotaryLimitJoint_class, JSB_cpRotaryLimitJoint_object, NULL);
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpBody* arg0; cpBody* arg1; double arg2; double arg3; 

	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg0, NULL );
	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg1, NULL );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	void* 	ret_val = cpRotaryLimitJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpFloat)arg2 , (cpFloat)arg3  );

	jsb_set_jsobject_for_proxy(jsobj, ret_val);
	jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Destructor
void JSB_cpRotaryLimitJoint_finalize(JSFreeOp *fop, JSObject *jsthis)
{
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	if( proxy ) {
		CCLOGINFO("jsbindings: finalizing JS object %p (cpRotaryLimitJoint), handle: %p", jsthis, proxy->handle);

		jsb_del_jsobject_for_proxy(proxy->handle);
		if(proxy->flags == JSB_C_FLAG_CALL_FREE)
			cpConstraintFree( (cpConstraint*)proxy->handle);
		jsb_del_c_proxy_for_jsobject(jsthis);
	} else {
		CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpRotaryLimitJoint)", jsthis);
	}
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpRotaryLimitJoint_getMax(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpRotaryLimitJoint* arg0 = (cpRotaryLimitJoint*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpRotaryLimitJointGetMax((cpConstraint*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpRotaryLimitJoint_getMin(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpRotaryLimitJoint* arg0 = (cpRotaryLimitJoint*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpRotaryLimitJointGetMin((cpConstraint*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpRotaryLimitJoint_setMax(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpRotaryLimitJoint* arg0 = (cpRotaryLimitJoint*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpRotaryLimitJointSetMax((cpConstraint*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpRotaryLimitJoint_setMin(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpRotaryLimitJoint* arg0 = (cpRotaryLimitJoint*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpRotaryLimitJointSetMin((cpConstraint*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

void JSB_cpRotaryLimitJoint_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_cpRotaryLimitJoint_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_cpRotaryLimitJoint_class->name = name;
	JSB_cpRotaryLimitJoint_class->addProperty = JS_PropertyStub;
	JSB_cpRotaryLimitJoint_class->delProperty = JS_DeletePropertyStub;
	JSB_cpRotaryLimitJoint_class->getProperty = JS_PropertyStub;
	JSB_cpRotaryLimitJoint_class->setProperty = JS_StrictPropertyStub;
	JSB_cpRotaryLimitJoint_class->enumerate = JS_EnumerateStub;
	JSB_cpRotaryLimitJoint_class->resolve = JS_ResolveStub;
	JSB_cpRotaryLimitJoint_class->convert = JS_ConvertStub;
	JSB_cpRotaryLimitJoint_class->finalize = JSB_cpRotaryLimitJoint_finalize;
	JSB_cpRotaryLimitJoint_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getMax", JSB_cpRotaryLimitJoint_getMax, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getMin", JSB_cpRotaryLimitJoint_getMin, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setMax", JSB_cpRotaryLimitJoint_setMax, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setMin", JSB_cpRotaryLimitJoint_setMin, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_cpRotaryLimitJoint_object = JS_InitClass(cx, globalObj, JSB_cpConstraint_object, JSB_cpRotaryLimitJoint_class, JSB_cpRotaryLimitJoint_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

/*
 * cpArbiter
 */
#pragma mark - cpArbiter

JSClass* JSB_cpArbiter_class = NULL;
JSObject* JSB_cpArbiter_object = NULL;

// Constructor
JSBool JSB_cpArbiter_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSB_PRECONDITION2(argc==0, cx, JS_FALSE, "Invalid number of arguments");
	JSB_PRECONDITION2(false, cx, JS_TRUE, "No constructor");

	return JS_TRUE;
}

// Destructor
void JSB_cpArbiter_finalize(JSFreeOp *fop, JSObject *jsthis)
{
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	if( proxy ) {
		CCLOGINFO("jsbindings: finalizing JS object %p (cpArbiter), handle: %p", jsthis, proxy->handle);

		jsb_del_jsobject_for_proxy(proxy->handle);
		if(proxy->flags == JSB_C_FLAG_CALL_FREE)
			// No destructor found: ( (None*)proxy->handle);
		jsb_del_c_proxy_for_jsobject(jsthis);
	} else {
		CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpArbiter)", jsthis);
	}
}

// Arguments: 
// Ret value: int
JSBool JSB_cpArbiter_getCount(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->handle;
	int ret_val;

	ret_val = cpArbiterGetCount((cpArbiter*)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));
	return JS_TRUE;
}

// Arguments: int
// Ret value: cpFloat
JSBool JSB_cpArbiter_getDepth(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg1; 

	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpArbiterGetDepth((cpArbiter*)arg0 , (int)arg1  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpArbiter_getElasticity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpArbiterGetElasticity((cpArbiter*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpArbiter_getFriction(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpArbiterGetFriction((cpArbiter*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: int
// Ret value: cpVect
JSBool JSB_cpArbiter_getNormal(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg1; 

	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpArbiterGetNormal((cpArbiter*)arg0 , (int)arg1  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: int
// Ret value: cpVect
JSBool JSB_cpArbiter_getPoint(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg1; 

	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpArbiterGetPoint((cpArbiter*)arg0 , (int)arg1  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpVect
JSBool JSB_cpArbiter_getSurfaceVelocity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->handle;
	cpVect ret_val;

	ret_val = cpArbiterGetSurfaceVelocity((cpArbiter*)arg0  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void
JSBool JSB_cpArbiter_ignore(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->handle;

	cpArbiterIgnore((cpArbiter*)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpBool
JSBool JSB_cpArbiter_isFirstContact(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->handle;
	cpBool ret_val;

	ret_val = cpArbiterIsFirstContact((cpArbiter*)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpArbiter_setElasticity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpArbiterSetElasticity((cpArbiter*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpArbiter_setFriction(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpArbiterSetFriction((cpArbiter*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: void
JSBool JSB_cpArbiter_setSurfaceVelocity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpArbiterSetSurfaceVelocity((cpArbiter*)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpVect
JSBool JSB_cpArbiter_totalImpulse(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->handle;
	cpVect ret_val;

	ret_val = cpArbiterTotalImpulse((cpArbiter*)arg0  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpVect
JSBool JSB_cpArbiter_totalImpulseWithFriction(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->handle;
	cpVect ret_val;

	ret_val = cpArbiterTotalImpulseWithFriction((cpArbiter*)arg0  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpArbiter_totalKE(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpArbiter* arg0 = (cpArbiter*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpArbiterTotalKE((cpArbiter*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

void JSB_cpArbiter_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_cpArbiter_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_cpArbiter_class->name = name;
	JSB_cpArbiter_class->addProperty = JS_PropertyStub;
	JSB_cpArbiter_class->delProperty = JS_DeletePropertyStub;
	JSB_cpArbiter_class->getProperty = JS_PropertyStub;
	JSB_cpArbiter_class->setProperty = JS_StrictPropertyStub;
	JSB_cpArbiter_class->enumerate = JS_EnumerateStub;
	JSB_cpArbiter_class->resolve = JS_ResolveStub;
	JSB_cpArbiter_class->convert = JS_ConvertStub;
	JSB_cpArbiter_class->finalize = JSB_cpArbiter_finalize;
	JSB_cpArbiter_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getCount", JSB_cpArbiter_getCount, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getDepth", JSB_cpArbiter_getDepth, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getElasticity", JSB_cpArbiter_getElasticity, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getFriction", JSB_cpArbiter_getFriction, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getNormal", JSB_cpArbiter_getNormal, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getPoint", JSB_cpArbiter_getPoint, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getSurfaceVelocity", JSB_cpArbiter_getSurfaceVelocity, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("ignore", JSB_cpArbiter_ignore, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("isFirstContact", JSB_cpArbiter_isFirstContact, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setElasticity", JSB_cpArbiter_setElasticity, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setFriction", JSB_cpArbiter_setFriction, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setSurfaceVelocity", JSB_cpArbiter_setSurfaceVelocity, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("totalImpulse", JSB_cpArbiter_totalImpulse, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("totalImpulseWithFriction", JSB_cpArbiter_totalImpulseWithFriction, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("totalKE", JSB_cpArbiter_totalKE, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getShapes", JSB_cpArbiter_getShapes, 2, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getBodies", JSB_cpArbiter_getBodies, 2, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_cpArbiter_object = JS_InitClass(cx, globalObj, JSB_cpBase_object, JSB_cpArbiter_class, JSB_cpArbiter_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

/*
 * cpSpace
 */
#pragma mark - cpSpace

JSClass* JSB_cpSpace_class = NULL;
JSObject* JSB_cpSpace_object = NULL;
// Arguments: 
// Constructor
JSBool JSB_cpSpace_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSB_PRECONDITION2(argc==0, cx, JS_FALSE, "Invalid number of arguments");
	JSObject *jsobj = JS_NewObject(cx, JSB_cpSpace_class, JSB_cpSpace_object, NULL);
	void* 	ret_val = cpSpaceNew( );

	jsb_set_jsobject_for_proxy(jsobj, ret_val);
	jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Arguments: cpShape*
// Ret value: void
JSBool JSB_cpSpace_activateShapesTouchingShape(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpShape* arg1; 

	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg1, NULL );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpSpaceActivateShapesTouchingShape((cpSpace*)arg0 , (cpShape*)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: cpBool
JSBool JSB_cpSpace_containsBody(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpBody* arg1; 

	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg1, NULL );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpSpaceContainsBody((cpSpace*)arg0 , (cpBody*)arg1  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));
	return JS_TRUE;
}

// Arguments: cpConstraint*
// Ret value: cpBool
JSBool JSB_cpSpace_containsConstraint(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpConstraint* arg1; 

	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg1, NULL );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpSpaceContainsConstraint((cpSpace*)arg0 , (cpConstraint*)arg1  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));
	return JS_TRUE;
}

// Arguments: cpShape*
// Ret value: cpBool
JSBool JSB_cpSpace_containsShape(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpShape* arg1; 

	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg1, NULL );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpSpaceContainsShape((cpSpace*)arg0 , (cpShape*)arg1  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: void
JSBool JSB_cpSpace_destroy(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;

	cpSpaceDestroy((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpSpace_getCollisionBias(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpSpaceGetCollisionBias((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpTimestamp
JSBool JSB_cpSpace_getCollisionPersistence(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	cpTimestamp ret_val;

	ret_val = cpSpaceGetCollisionPersistence((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpSpace_getCollisionSlop(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpSpaceGetCollisionSlop((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpSpace_getCurrentTimeStep(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpSpaceGetCurrentTimeStep((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpSpace_getDamping(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpSpaceGetDamping((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpBool
JSBool JSB_cpSpace_getEnableContactGraph(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	cpBool ret_val;

	ret_val = cpSpaceGetEnableContactGraph((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpVect
JSBool JSB_cpSpace_getGravity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	cpVect ret_val;

	ret_val = cpSpaceGetGravity((cpSpace*)arg0  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpSpace_getIdleSpeedThreshold(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpSpaceGetIdleSpeedThreshold((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: int
JSBool JSB_cpSpace_getIterations(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	int ret_val;

	ret_val = cpSpaceGetIterations((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpSpace_getSleepTimeThreshold(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpSpaceGetSleepTimeThreshold((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpBody*
JSBool JSB_cpSpace_getStaticBody(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	cpBody* ret_val;

	ret_val = cpSpaceGetStaticBody((cpSpace*)arg0  );

	jsval ret_jsval = c_class_to_jsval( cx, ret_val, JSB_cpBody_object, JSB_cpBody_class, "cpBody" );
	JS_SET_RVAL(cx, vp, ret_jsval);
    
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpSpace*
JSBool JSB_cpSpace_init(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	cpSpace* ret_val;

	ret_val = cpSpaceInit((cpSpace*)arg0  );

	jsval ret_jsval = c_class_to_jsval( cx, ret_val, JSB_cpSpace_object, JSB_cpSpace_class, "cpSpace" );
	JS_SET_RVAL(cx, vp, ret_jsval);
    
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpBool
JSBool JSB_cpSpace_isLocked(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	cpBool ret_val;

	ret_val = cpSpaceIsLocked((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));
	return JS_TRUE;
}

// Arguments: cpVect, cpLayers, cpGroup
// Ret value: cpShape*
JSBool JSB_cpSpace_pointQueryFirst(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; uint32_t arg2; cpGroup arg3;

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	ok &= jsval_to_uint32( cx, *argvp++, &arg2 );
	ok &= jsval_to_uint( cx, *argvp++, (unsigned int*) &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	cpShape* ret_val;

	ret_val = cpSpacePointQueryFirst((cpSpace*)arg0 , (cpVect)arg1 , (cpLayers)arg2 , (cpGroup)arg3  );

	if(ret_val) {
		jsval ret_jsval = c_class_to_jsval( cx, ret_val, JSB_cpShape_object, JSB_cpShape_class, "cpShape" );
		JS_SET_RVAL(cx, vp, ret_jsval);
	} else {
		JS_SET_RVAL(cx, vp, JSVAL_NULL);
	}
	return JS_TRUE;
}
// Arguments: cpShape*
// Ret value: void
JSBool JSB_cpSpace_reindexShape(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpShape* arg1; 

	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg1, NULL );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpSpaceReindexShape((cpSpace*)arg0 , (cpShape*)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: void
JSBool JSB_cpSpace_reindexShapesForBody(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpBody* arg1; 

	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg1, NULL );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpSpaceReindexShapesForBody((cpSpace*)arg0 , (cpBody*)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void
JSBool JSB_cpSpace_reindexStatic(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;

	cpSpaceReindexStatic((cpSpace*)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpSpace_setCollisionBias(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpSpaceSetCollisionBias((cpSpace*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpTimestamp
// Ret value: void
JSBool JSB_cpSpace_setCollisionPersistence(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg1; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpSpaceSetCollisionPersistence((cpSpace*)arg0 , (cpTimestamp)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpSpace_setCollisionSlop(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpSpaceSetCollisionSlop((cpSpace*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpSpace_setDamping(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpSpaceSetDamping((cpSpace*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpBool
// Ret value: void
JSBool JSB_cpSpace_setEnableContactGraph(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg1; 

	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpSpaceSetEnableContactGraph((cpSpace*)arg0 , (cpBool)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: void
JSBool JSB_cpSpace_setGravity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpSpaceSetGravity((cpSpace*)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpSpace_setIdleSpeedThreshold(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpSpaceSetIdleSpeedThreshold((cpSpace*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: int
// Ret value: void
JSBool JSB_cpSpace_setIterations(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg1; 

	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpSpaceSetIterations((cpSpace*)arg0 , (int)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpSpace_setSleepTimeThreshold(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpSpaceSetSleepTimeThreshold((cpSpace*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpSpace_step(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpSpaceStep((cpSpace*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat, int
// Ret value: void
JSBool JSB_cpSpace_useSpatialHash(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSpace* arg0 = (cpSpace*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; int32_t arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= jsval_to_int32( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpSpaceUseSpatialHash((cpSpace*)arg0 , (cpFloat)arg1 , (int)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

void JSB_cpSpace_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_cpSpace_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_cpSpace_class->name = name;
	JSB_cpSpace_class->addProperty = JS_PropertyStub;
	JSB_cpSpace_class->delProperty = JS_DeletePropertyStub;
	JSB_cpSpace_class->getProperty = JS_PropertyStub;
	JSB_cpSpace_class->setProperty = JS_StrictPropertyStub;
	JSB_cpSpace_class->enumerate = JS_EnumerateStub;
	JSB_cpSpace_class->resolve = JS_ResolveStub;
	JSB_cpSpace_class->convert = JS_ConvertStub;
	JSB_cpSpace_class->finalize = JSB_cpSpace_finalize;
	JSB_cpSpace_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("activateShapesTouchingShape", JSB_cpSpace_activateShapesTouchingShape, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("containsBody", JSB_cpSpace_containsBody, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("containsConstraint", JSB_cpSpace_containsConstraint, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("containsShape", JSB_cpSpace_containsShape, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("destroy", JSB_cpSpace_destroy, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getCollisionBias", JSB_cpSpace_getCollisionBias, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getCollisionPersistence", JSB_cpSpace_getCollisionPersistence, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getCollisionSlop", JSB_cpSpace_getCollisionSlop, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getCurrentTimeStep", JSB_cpSpace_getCurrentTimeStep, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getDamping", JSB_cpSpace_getDamping, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getEnableContactGraph", JSB_cpSpace_getEnableContactGraph, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getGravity", JSB_cpSpace_getGravity, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getIdleSpeedThreshold", JSB_cpSpace_getIdleSpeedThreshold, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getIterations", JSB_cpSpace_getIterations, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getSleepTimeThreshold", JSB_cpSpace_getSleepTimeThreshold, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getStaticBody", JSB_cpSpace_getStaticBody, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("init", JSB_cpSpace_init, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("isLocked", JSB_cpSpace_isLocked, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("pointQueryFirst", JSB_cpSpace_pointQueryFirst, 3, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("reindexShape", JSB_cpSpace_reindexShape, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("reindexShapesForBody", JSB_cpSpace_reindexShapesForBody, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("reindexStatic", JSB_cpSpace_reindexStatic, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setCollisionBias", JSB_cpSpace_setCollisionBias, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setCollisionPersistence", JSB_cpSpace_setCollisionPersistence, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setCollisionSlop", JSB_cpSpace_setCollisionSlop, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setDamping", JSB_cpSpace_setDamping, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setEnableContactGraph", JSB_cpSpace_setEnableContactGraph, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setGravity", JSB_cpSpace_setGravity, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setIdleSpeedThreshold", JSB_cpSpace_setIdleSpeedThreshold, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setIterations", JSB_cpSpace_setIterations, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setSleepTimeThreshold", JSB_cpSpace_setSleepTimeThreshold, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("step", JSB_cpSpace_step, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("useSpatialHash", JSB_cpSpace_useSpatialHash, 2, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("addShape", JSB_cpSpace_addShape, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("addCollisionHandler", JSB_cpSpace_addCollisionHandler, 7, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("addStaticShape", JSB_cpSpace_addStaticShape, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("removeConstraint", JSB_cpSpace_removeConstraint, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("removeBody", JSB_cpSpace_removeBody, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("removeCollisionHandler", JSB_cpSpace_removeCollisionHandler, 2, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("removeStaticShape", JSB_cpSpace_removeStaticShape, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("addConstraint", JSB_cpSpace_addConstraint, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("addBody", JSB_cpSpace_addBody, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("removeShape", JSB_cpSpace_removeShape, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_cpSpace_object = JS_InitClass(cx, globalObj, JSB_cpBase_object, JSB_cpSpace_class, JSB_cpSpace_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

/*
 * cpBody
 */
#pragma mark - cpBody

JSClass* JSB_cpBody_class = NULL;
JSObject* JSB_cpBody_object = NULL;

// Destructor
void JSB_cpBody_finalize(JSFreeOp *fop, JSObject *jsthis)
{
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	if( proxy ) {
		CCLOGINFO("jsbindings: finalizing JS object %p (cpBody), handle: %p", jsthis, proxy->handle);

		jsb_del_jsobject_for_proxy(proxy->handle);
		if(proxy->flags == JSB_C_FLAG_CALL_FREE)
			cpBodyFree( (cpBody*)proxy->handle);
		jsb_del_c_proxy_for_jsobject(jsthis);
	} else {
		CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpBody)", jsthis);
	}
}

// Arguments: 
// Ret value: void
JSBool JSB_cpBody_activate(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;

	cpBodyActivate((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpShape*
// Ret value: void
JSBool JSB_cpBody_activateStatic(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpShape* arg1; 

	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg1, NULL );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpBodyActivateStatic((cpBody*)arg0 , (cpShape*)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpVect, cpVect
// Ret value: void
JSBool JSB_cpBody_applyForce(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; cpVect arg2; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpBodyApplyForce((cpBody*)arg0 , (cpVect)arg1 , (cpVect)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpVect, cpVect
// Ret value: void
JSBool JSB_cpBody_applyImpulse(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; cpVect arg2; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpBodyApplyImpulse((cpBody*)arg0 , (cpVect)arg1 , (cpVect)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void
JSBool JSB_cpBody_destroy(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;

	cpBodyDestroy((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpBody_getAngVel(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpBodyGetAngVel((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpBody_getAngVelLimit(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpBodyGetAngVelLimit((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpBody_getAngle(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpBodyGetAngle((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpVect
JSBool JSB_cpBody_getForce(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	cpVect ret_val;

	ret_val = cpBodyGetForce((cpBody*)arg0  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpBody_getMass(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpBodyGetMass((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpBody_getMoment(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpBodyGetMoment((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpVect
JSBool JSB_cpBody_getPos(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	cpVect ret_val;

	ret_val = cpBodyGetPos((cpBody*)arg0  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpVect
JSBool JSB_cpBody_getRot(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	cpVect ret_val;

	ret_val = cpBodyGetRot((cpBody*)arg0  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpSpace*
JSBool JSB_cpBody_getSpace(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	cpSpace* ret_val;

	ret_val = cpBodyGetSpace((cpBody*)arg0  );

	jsval ret_jsval = c_class_to_jsval( cx, ret_val, JSB_cpSpace_object, JSB_cpSpace_class, "cpSpace" );
	JS_SET_RVAL(cx, vp, ret_jsval);
    
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpBody_getTorque(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpBodyGetTorque((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpVect
JSBool JSB_cpBody_getVel(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	cpVect ret_val;

	ret_val = cpBodyGetVel((cpBody*)arg0  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: cpVect
JSBool JSB_cpBody_getVelAtLocalPoint(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpBodyGetVelAtLocalPoint((cpBody*)arg0 , (cpVect)arg1  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: cpVect
JSBool JSB_cpBody_getVelAtWorldPoint(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpBodyGetVelAtWorldPoint((cpBody*)arg0 , (cpVect)arg1  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpBody_getVelLimit(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpBodyGetVelLimit((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpFloat, cpFloat
// Ret value: cpBody*
JSBool JSB_cpBody_init(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; double arg2; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	cpBody* ret_val;

	ret_val = cpBodyInit((cpBody*)arg0 , (cpFloat)arg1 , (cpFloat)arg2  );

	jsval ret_jsval = c_class_to_jsval( cx, ret_val, JSB_cpBody_object, JSB_cpBody_class, "cpBody" );
	JS_SET_RVAL(cx, vp, ret_jsval);
    
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpBody*
JSBool JSB_cpBody_initStatic(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	cpBody* ret_val;

	ret_val = cpBodyInitStatic((cpBody*)arg0  );

	jsval ret_jsval = c_class_to_jsval( cx, ret_val, JSB_cpBody_object, JSB_cpBody_class, "cpBody" );
	JS_SET_RVAL(cx, vp, ret_jsval);
    
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpBool
JSBool JSB_cpBody_isRogue(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	cpBool ret_val;

	ret_val = cpBodyIsRogue((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpBool
JSBool JSB_cpBody_isSleeping(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	cpBool ret_val;

	ret_val = cpBodyIsSleeping((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpBool
JSBool JSB_cpBody_isStatic(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	cpBool ret_val;

	ret_val = cpBodyIsStatic((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpBody_kineticEnergy(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpBodyKineticEnergy((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: cpVect
JSBool JSB_cpBody_local2World(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpBodyLocal2World((cpBody*)arg0 , (cpVect)arg1  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void
JSBool JSB_cpBody_resetForces(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;

	cpBodyResetForces((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpBody_setAngVel(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpBodySetAngVel((cpBody*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpBody_setAngVelLimit(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpBodySetAngVelLimit((cpBody*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpBody_setAngle(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpBodySetAngle((cpBody*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: void
JSBool JSB_cpBody_setForce(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpBodySetForce((cpBody*)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpBody_setMass(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpBodySetMass((cpBody*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpBody_setMoment(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpBodySetMoment((cpBody*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: void
JSBool JSB_cpBody_setPos(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpBodySetPos((cpBody*)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpBody_setTorque(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpBodySetTorque((cpBody*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: void
JSBool JSB_cpBody_setVel(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpBodySetVel((cpBody*)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpBody_setVelLimit(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpBodySetVelLimit((cpBody*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: void
JSBool JSB_cpBody_sleep(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;

	cpBodySleep((cpBody*)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: void
JSBool JSB_cpBody_sleepWithGroup(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpBody* arg1; 

	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg1, NULL );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpBodySleepWithGroup((cpBody*)arg0 , (cpBody*)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpBody_updatePosition(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpBodyUpdatePosition((cpBody*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpVect, cpFloat, cpFloat
// Ret value: void
JSBool JSB_cpBody_updateVelocity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 3, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; double arg2; double arg3; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpBodyUpdateVelocity((cpBody*)arg0 , (cpVect)arg1 , (cpFloat)arg2 , (cpFloat)arg3  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: cpVect
JSBool JSB_cpBody_world2Local(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpBody* arg0 = (cpBody*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpBodyWorld2Local((cpBody*)arg0 , (cpVect)arg1  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

void JSB_cpBody_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_cpBody_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_cpBody_class->name = name;
	JSB_cpBody_class->addProperty = JS_PropertyStub;
	JSB_cpBody_class->delProperty = JS_DeletePropertyStub;
	JSB_cpBody_class->getProperty = JS_PropertyStub;
	JSB_cpBody_class->setProperty = JS_StrictPropertyStub;
	JSB_cpBody_class->enumerate = JS_EnumerateStub;
	JSB_cpBody_class->resolve = JS_ResolveStub;
	JSB_cpBody_class->convert = JS_ConvertStub;
	JSB_cpBody_class->finalize = JSB_cpBody_finalize;
	JSB_cpBody_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("activate", JSB_cpBody_activate, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("activateStatic", JSB_cpBody_activateStatic, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("applyForce", JSB_cpBody_applyForce, 2, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("applyImpulse", JSB_cpBody_applyImpulse, 2, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("destroy", JSB_cpBody_destroy, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getAngVel", JSB_cpBody_getAngVel, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getAngVelLimit", JSB_cpBody_getAngVelLimit, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getAngle", JSB_cpBody_getAngle, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getForce", JSB_cpBody_getForce, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getMass", JSB_cpBody_getMass, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getMoment", JSB_cpBody_getMoment, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getPos", JSB_cpBody_getPos, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getRot", JSB_cpBody_getRot, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getSpace", JSB_cpBody_getSpace, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getTorque", JSB_cpBody_getTorque, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getVel", JSB_cpBody_getVel, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getVelAtLocalPoint", JSB_cpBody_getVelAtLocalPoint, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getVelAtWorldPoint", JSB_cpBody_getVelAtWorldPoint, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getVelLimit", JSB_cpBody_getVelLimit, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("init", JSB_cpBody_init, 2, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("initStatic", JSB_cpBody_initStatic, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("isRogue", JSB_cpBody_isRogue, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("isSleeping", JSB_cpBody_isSleeping, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("isStatic", JSB_cpBody_isStatic, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("kineticEnergy", JSB_cpBody_kineticEnergy, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("local2World", JSB_cpBody_local2World, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("resetForces", JSB_cpBody_resetForces, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setAngVel", JSB_cpBody_setAngVel, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setAngVelLimit", JSB_cpBody_setAngVelLimit, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setAngle", JSB_cpBody_setAngle, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setForce", JSB_cpBody_setForce, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setMass", JSB_cpBody_setMass, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setMoment", JSB_cpBody_setMoment, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setPos", JSB_cpBody_setPos, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setTorque", JSB_cpBody_setTorque, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setVel", JSB_cpBody_setVel, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setVelLimit", JSB_cpBody_setVelLimit, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("sleep", JSB_cpBody_sleep, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("sleepWithGroup", JSB_cpBody_sleepWithGroup, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("updatePosition", JSB_cpBody_updatePosition, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("updateVelocity", JSB_cpBody_updateVelocity, 3, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("world2Local", JSB_cpBody_world2Local, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setUserData", JSB_cpBody_setUserData, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getUserData", JSB_cpBody_getUserData, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_cpBody_object = JS_InitClass(cx, globalObj, JSB_cpBase_object, JSB_cpBody_class, JSB_cpBody_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

/*
 * cpShape
 */
#pragma mark - cpShape

JSClass* JSB_cpShape_class = NULL;
JSObject* JSB_cpShape_object = NULL;

// Constructor
JSBool JSB_cpShape_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSB_PRECONDITION2(argc==0, cx, JS_FALSE, "Invalid number of arguments");
	JSB_PRECONDITION2(false, cx, JS_TRUE, "No constructor");

	return JS_TRUE;
}

// Destructor
void JSB_cpShape_finalize(JSFreeOp *fop, JSObject *jsthis)
{
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	if( proxy ) {
		CCLOGINFO("jsbindings: finalizing JS object %p (cpShape), handle: %p", jsthis, proxy->handle);

		jsb_del_jsobject_for_proxy(proxy->handle);
		if(proxy->flags == JSB_C_FLAG_CALL_FREE)
			cpShapeFree( (cpShape*)proxy->handle);
		jsb_del_c_proxy_for_jsobject(jsthis);
	} else {
		CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpShape)", jsthis);
	}
}

// Arguments: 
// Ret value: cpBB
JSBool JSB_cpShape_cacheBB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpShape* arg0 = (cpShape*) proxy->handle;
	cpBB ret_val;

	ret_val = cpShapeCacheBB((cpShape*)arg0  );

	jsval ret_jsval = cpBB_to_jsval( cx, (cpBB)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: void
JSBool JSB_cpShape_destroy(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpShape* arg0 = (cpShape*) proxy->handle;

	cpShapeDestroy((cpShape*)arg0  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpBB
JSBool JSB_cpShape_getBB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpShape* arg0 = (cpShape*) proxy->handle;
	cpBB ret_val;

	ret_val = cpShapeGetBB((cpShape*)arg0  );

	jsval ret_jsval = cpBB_to_jsval( cx, (cpBB)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpBody*
JSBool JSB_cpShape_getBody(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpShape* arg0 = (cpShape*) proxy->handle;
	cpBody* ret_val;

	ret_val = cpShapeGetBody((cpShape*)arg0  );

	jsval ret_jsval = c_class_to_jsval( cx, ret_val, JSB_cpBody_object, JSB_cpBody_class, "cpBody" );
	JS_SET_RVAL(cx, vp, ret_jsval);
    
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpCollisionType
JSBool JSB_cpShape_getCollisionType(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpShape* arg0 = (cpShape*) proxy->handle;
	cpCollisionType ret_val;

	ret_val = cpShapeGetCollisionType((cpShape*)arg0  );

	jsval ret_jsval = uint32_to_jsval( cx, (cpCollisionType)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpShape_getElasticity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpShape* arg0 = (cpShape*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpShapeGetElasticity((cpShape*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpShape_getFriction(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpShape* arg0 = (cpShape*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpShapeGetFriction((cpShape*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpGroup
JSBool JSB_cpShape_getGroup(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpShape* arg0 = (cpShape*) proxy->handle;
	cpGroup ret_val;

	ret_val = cpShapeGetGroup((cpShape*)arg0  );

	jsval ret_jsval = uint32_to_jsval( cx, (cpGroup)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpLayers
JSBool JSB_cpShape_getLayers(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpShape* arg0 = (cpShape*) proxy->handle;
	cpLayers ret_val;

	ret_val = cpShapeGetLayers((cpShape*)arg0  );
	JS_SET_RVAL(cx, vp, UINT_TO_JSVAL((uint32_t)ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpBool
JSBool JSB_cpShape_getSensor(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpShape* arg0 = (cpShape*) proxy->handle;
	cpBool ret_val;

	ret_val = cpShapeGetSensor((cpShape*)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpSpace*
JSBool JSB_cpShape_getSpace(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpShape* arg0 = (cpShape*) proxy->handle;
	cpSpace* ret_val;

	ret_val = cpShapeGetSpace((cpShape*)arg0  );

	jsval ret_jsval = c_class_to_jsval( cx, ret_val, JSB_cpSpace_object, JSB_cpSpace_class, "cpSpace" );
	JS_SET_RVAL(cx, vp, ret_jsval);
    
	return JS_TRUE;
}

// Arguments: 
// Ret value: cpVect
JSBool JSB_cpShape_getSurfaceVelocity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpShape* arg0 = (cpShape*) proxy->handle;
	cpVect ret_val;

	ret_val = cpShapeGetSurfaceVelocity((cpShape*)arg0  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: cpBool
JSBool JSB_cpShape_pointQuery(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpShape* arg0 = (cpShape*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpShapePointQuery((cpShape*)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));
	return JS_TRUE;
}

// Arguments: cpBody*
// Ret value: void
JSBool JSB_cpShape_setBody(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpShape* arg0 = (cpShape*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpBody* arg1; 

	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg1, NULL );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpShapeSetBody((cpShape*)arg0 , (cpBody*)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpCollisionType
// Ret value: void
JSBool JSB_cpShape_setCollisionType(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpShape* arg0 = (cpShape*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpCollisionType arg1; 

	ok &= jsval_to_uint( cx, *argvp++, (unsigned int*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpShapeSetCollisionType((cpShape*)arg0 , (cpCollisionType)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpShape_setElasticity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpShape* arg0 = (cpShape*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpShapeSetElasticity((cpShape*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpFloat
// Ret value: void
JSBool JSB_cpShape_setFriction(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpShape* arg0 = (cpShape*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	double arg1; 

	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpShapeSetFriction((cpShape*)arg0 , (cpFloat)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpGroup
// Ret value: void
JSBool JSB_cpShape_setGroup(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpShape* arg0 = (cpShape*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpGroup arg1; 

	ok &= jsval_to_uint( cx, *argvp++, (unsigned int*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpShapeSetGroup((cpShape*)arg0 , (cpGroup)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpLayers
// Ret value: void
JSBool JSB_cpShape_setLayers(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpShape* arg0 = (cpShape*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	uint32_t arg1; 

	ok &= jsval_to_uint32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpShapeSetLayers((cpShape*)arg0 , (cpLayers)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpBool
// Ret value: void
JSBool JSB_cpShape_setSensor(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpShape* arg0 = (cpShape*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg1; 

	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpShapeSetSensor((cpShape*)arg0 , (cpBool)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpVect
// Ret value: void
JSBool JSB_cpShape_setSurfaceVelocity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpShape* arg0 = (cpShape*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpShapeSetSurfaceVelocity((cpShape*)arg0 , (cpVect)arg1  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

// Arguments: cpVect, cpVect
// Ret value: cpBB
JSBool JSB_cpShape_update(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpShape* arg0 = (cpShape*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; cpVect arg2; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	cpBB ret_val;

	ret_val = cpShapeUpdate((cpShape*)arg0 , (cpVect)arg1 , (cpVect)arg2  );

	jsval ret_jsval = cpBB_to_jsval( cx, (cpBB)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

void JSB_cpShape_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_cpShape_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_cpShape_class->name = name;
	JSB_cpShape_class->addProperty = JS_PropertyStub;
	JSB_cpShape_class->delProperty = JS_DeletePropertyStub;
	JSB_cpShape_class->getProperty = JS_PropertyStub;
	JSB_cpShape_class->setProperty = JS_StrictPropertyStub;
	JSB_cpShape_class->enumerate = JS_EnumerateStub;
	JSB_cpShape_class->resolve = JS_ResolveStub;
	JSB_cpShape_class->convert = JS_ConvertStub;
	JSB_cpShape_class->finalize = JSB_cpShape_finalize;
	JSB_cpShape_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("cacheBB", JSB_cpShape_cacheBB, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("destroy", JSB_cpShape_destroy, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getBB", JSB_cpShape_getBB, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getBody", JSB_cpShape_getBody, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getCollisionType", JSB_cpShape_getCollisionType, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getElasticity", JSB_cpShape_getElasticity, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getFriction", JSB_cpShape_getFriction, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getGroup", JSB_cpShape_getGroup, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getLayers", JSB_cpShape_getLayers, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getSensor", JSB_cpShape_getSensor, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getSpace", JSB_cpShape_getSpace, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getSurfaceVelocity", JSB_cpShape_getSurfaceVelocity, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("pointQuery", JSB_cpShape_pointQuery, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setBody", JSB_cpShape_setBody, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setCollisionType", JSB_cpShape_setCollisionType, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setElasticity", JSB_cpShape_setElasticity, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setFriction", JSB_cpShape_setFriction, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setGroup", JSB_cpShape_setGroup, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setLayers", JSB_cpShape_setLayers, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setSensor", JSB_cpShape_setSensor, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setSurfaceVelocity", JSB_cpShape_setSurfaceVelocity, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("update", JSB_cpShape_update, 2, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_cpShape_object = JS_InitClass(cx, globalObj, JSB_cpBase_object, JSB_cpShape_class, JSB_cpShape_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

/*
 * cpCircleShape
 */
#pragma mark - cpCircleShape

JSClass* JSB_cpCircleShape_class = NULL;
JSObject* JSB_cpCircleShape_object = NULL;
// Arguments: cpBody*, cpFloat, cpVect
// Constructor
JSBool JSB_cpCircleShape_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSB_PRECONDITION2(argc==3, cx, JS_FALSE, "Invalid number of arguments");
	JSObject *jsobj = JS_NewObject(cx, JSB_cpCircleShape_class, JSB_cpCircleShape_object, NULL);
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpBody* arg0; double arg1; cpVect arg2; 

	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg0, NULL );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg1 );
	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	void* 	ret_val = cpCircleShapeNew((cpBody*)arg0 , (cpFloat)arg1 , (cpVect)arg2  );

	jsb_set_jsobject_for_proxy(jsobj, ret_val);
	jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Destructor
void JSB_cpCircleShape_finalize(JSFreeOp *fop, JSObject *jsthis)
{
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	if( proxy ) {
		CCLOGINFO("jsbindings: finalizing JS object %p (cpCircleShape), handle: %p", jsthis, proxy->handle);

		jsb_del_jsobject_for_proxy(proxy->handle);
		if(proxy->flags == JSB_C_FLAG_CALL_FREE)
			cpShapeFree( (cpShape*)proxy->handle);
		jsb_del_c_proxy_for_jsobject(jsthis);
	} else {
		CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpCircleShape)", jsthis);
	}
}

// Arguments: 
// Ret value: cpVect
JSBool JSB_cpCircleShape_getOffset(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpCircleShape* arg0 = (cpCircleShape*) proxy->handle;
	cpVect ret_val;

	ret_val = cpCircleShapeGetOffset((cpShape*)arg0  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpCircleShape_getRadius(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpCircleShape* arg0 = (cpCircleShape*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpCircleShapeGetRadius((cpShape*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

void JSB_cpCircleShape_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_cpCircleShape_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_cpCircleShape_class->name = name;
	JSB_cpCircleShape_class->addProperty = JS_PropertyStub;
	JSB_cpCircleShape_class->delProperty = JS_DeletePropertyStub;
	JSB_cpCircleShape_class->getProperty = JS_PropertyStub;
	JSB_cpCircleShape_class->setProperty = JS_StrictPropertyStub;
	JSB_cpCircleShape_class->enumerate = JS_EnumerateStub;
	JSB_cpCircleShape_class->resolve = JS_ResolveStub;
	JSB_cpCircleShape_class->convert = JS_ConvertStub;
	JSB_cpCircleShape_class->finalize = JSB_cpCircleShape_finalize;
	JSB_cpCircleShape_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getOffset", JSB_cpCircleShape_getOffset, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getRadius", JSB_cpCircleShape_getRadius, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_cpCircleShape_object = JS_InitClass(cx, globalObj, JSB_cpShape_object, JSB_cpCircleShape_class, JSB_cpCircleShape_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

/*
 * cpSegmentShape
 */
#pragma mark - cpSegmentShape

JSClass* JSB_cpSegmentShape_class = NULL;
JSObject* JSB_cpSegmentShape_object = NULL;
// Arguments: cpBody*, cpVect, cpVect, cpFloat
// Constructor
JSBool JSB_cpSegmentShape_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
	JSB_PRECONDITION2(argc==4, cx, JS_FALSE, "Invalid number of arguments");
	JSObject *jsobj = JS_NewObject(cx, JSB_cpSegmentShape_class, JSB_cpSegmentShape_object, NULL);
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpBody* arg0; cpVect arg1; cpVect arg2; double arg3; 

	ok &= jsval_to_c_class( cx, *argvp++, (void**)&arg0, NULL );
	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg2 );
	ok &= JS_ValueToNumber( cx, *argvp++, &arg3 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	void* 	ret_val = cpSegmentShapeNew((cpBody*)arg0 , (cpVect)arg1 , (cpVect)arg2 , (cpFloat)arg3  );

	jsb_set_jsobject_for_proxy(jsobj, ret_val);
	jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
	JS_SET_RVAL(cx, vp, OBJECT_TO_JSVAL(jsobj));

	return JS_TRUE;
}

// Destructor
void JSB_cpSegmentShape_finalize(JSFreeOp *fop, JSObject *jsthis)
{
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	if( proxy ) {
		CCLOGINFO("jsbindings: finalizing JS object %p (cpSegmentShape), handle: %p", jsthis, proxy->handle);

		jsb_del_jsobject_for_proxy(proxy->handle);
		if(proxy->flags == JSB_C_FLAG_CALL_FREE)
			cpShapeFree( (cpShape*)proxy->handle);
		jsb_del_c_proxy_for_jsobject(jsthis);
	} else {
		CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpSegmentShape)", jsthis);
	}
}

// Arguments: 
// Ret value: cpVect
JSBool JSB_cpSegmentShape_getA(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSegmentShape* arg0 = (cpSegmentShape*) proxy->handle;
	cpVect ret_val;

	ret_val = cpSegmentShapeGetA((cpShape*)arg0  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpVect
JSBool JSB_cpSegmentShape_getB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSegmentShape* arg0 = (cpSegmentShape*) proxy->handle;
	cpVect ret_val;

	ret_val = cpSegmentShapeGetB((cpShape*)arg0  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpVect
JSBool JSB_cpSegmentShape_getNormal(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSegmentShape* arg0 = (cpSegmentShape*) proxy->handle;
	cpVect ret_val;

	ret_val = cpSegmentShapeGetNormal((cpShape*)arg0  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

// Arguments: 
// Ret value: cpFloat
JSBool JSB_cpSegmentShape_getRadius(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSegmentShape* arg0 = (cpSegmentShape*) proxy->handle;
	cpFloat ret_val;

	ret_val = cpSegmentShapeGetRadius((cpShape*)arg0  );
	JS_SET_RVAL(cx, vp, DOUBLE_TO_JSVAL(ret_val));
	return JS_TRUE;
}

// Arguments: cpVect, cpVect
// Ret value: void
JSBool JSB_cpSegmentShape_setNeighbors(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 2, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpSegmentShape* arg0 = (cpSegmentShape*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	cpVect arg1; cpVect arg2; 

	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg1 );
	ok &= jsval_to_cpVect( cx, *argvp++, (cpVect*) &arg2 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");

	cpSegmentShapeSetNeighbors((cpShape*)arg0 , (cpVect)arg1 , (cpVect)arg2  );
	JS_SET_RVAL(cx, vp, JSVAL_VOID);
	return JS_TRUE;
}

void JSB_cpSegmentShape_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_cpSegmentShape_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_cpSegmentShape_class->name = name;
	JSB_cpSegmentShape_class->addProperty = JS_PropertyStub;
	JSB_cpSegmentShape_class->delProperty = JS_DeletePropertyStub;
	JSB_cpSegmentShape_class->getProperty = JS_PropertyStub;
	JSB_cpSegmentShape_class->setProperty = JS_StrictPropertyStub;
	JSB_cpSegmentShape_class->enumerate = JS_EnumerateStub;
	JSB_cpSegmentShape_class->resolve = JS_ResolveStub;
	JSB_cpSegmentShape_class->convert = JS_ConvertStub;
	JSB_cpSegmentShape_class->finalize = JSB_cpSegmentShape_finalize;
	JSB_cpSegmentShape_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getA", JSB_cpSegmentShape_getA, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getB", JSB_cpSegmentShape_getB, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getNormal", JSB_cpSegmentShape_getNormal, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getRadius", JSB_cpSegmentShape_getRadius, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("setNeighbors", JSB_cpSegmentShape_setNeighbors, 2, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_cpSegmentShape_object = JS_InitClass(cx, globalObj, JSB_cpShape_object, JSB_cpSegmentShape_class, JSB_cpSegmentShape_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}

/*
 * cpPolyShape
 */
#pragma mark - cpPolyShape

JSClass* JSB_cpPolyShape_class = NULL;
JSObject* JSB_cpPolyShape_object = NULL;

// Destructor
void JSB_cpPolyShape_finalize(JSFreeOp *fop, JSObject *jsthis)
{
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	if( proxy ) {
		CCLOGINFO("jsbindings: finalizing JS object %p (cpPolyShape), handle: %p", jsthis, proxy->handle);

		jsb_del_jsobject_for_proxy(proxy->handle);
		if(proxy->flags == JSB_C_FLAG_CALL_FREE)
			cpShapeFree( (cpShape*)proxy->handle);
		jsb_del_c_proxy_for_jsobject(jsthis);
	} else {
		CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpPolyShape)", jsthis);
	}
}

// Arguments: 
// Ret value: int
JSBool JSB_cpPolyShape_getNumVerts(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 0, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpPolyShape* arg0 = (cpPolyShape*) proxy->handle;
	int ret_val;

	ret_val = cpPolyShapeGetNumVerts((cpShape*)arg0  );
	JS_SET_RVAL(cx, vp, INT_TO_JSVAL((int32_t)ret_val));
	return JS_TRUE;
}

// Arguments: int
// Ret value: cpVect
JSBool JSB_cpPolyShape_getVert(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2( argc == 1, cx, JS_FALSE, "Invalid number of arguments" );

	JSObject* jsthis = (JSObject *)JS_THIS_OBJECT(cx, vp);
	struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
	cpPolyShape* arg0 = (cpPolyShape*) proxy->handle;
	jsval *argvp = JS_ARGV(cx,vp);
	JSBool ok = JS_TRUE;
	int32_t arg1; 

	ok &= jsval_to_int32( cx, *argvp++, &arg1 );
	JSB_PRECONDITION2(ok, cx, JS_FALSE, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpPolyShapeGetVert((cpShape*)arg0 , (int)arg1  );

	jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
	JS_SET_RVAL(cx, vp, ret_jsval);

	return JS_TRUE;
}

void JSB_cpPolyShape_createClass(JSContext *cx, JSObject* globalObj, const char* name )
{
	JSB_cpPolyShape_class = (JSClass *)calloc(1, sizeof(JSClass));
	JSB_cpPolyShape_class->name = name;
	JSB_cpPolyShape_class->addProperty = JS_PropertyStub;
	JSB_cpPolyShape_class->delProperty = JS_DeletePropertyStub;
	JSB_cpPolyShape_class->getProperty = JS_PropertyStub;
	JSB_cpPolyShape_class->setProperty = JS_StrictPropertyStub;
	JSB_cpPolyShape_class->enumerate = JS_EnumerateStub;
	JSB_cpPolyShape_class->resolve = JS_ResolveStub;
	JSB_cpPolyShape_class->convert = JS_ConvertStub;
	JSB_cpPolyShape_class->finalize = JSB_cpPolyShape_finalize;
	JSB_cpPolyShape_class->flags = JSCLASS_HAS_PRIVATE;

	static JSPropertySpec properties[] = {
		{0, 0, 0, 0, 0}
	};
	static JSFunctionSpec funcs[] = {
		JS_FN("getNumVerts", JSB_cpPolyShape_getNumVerts, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FN("getVert", JSB_cpPolyShape_getVert, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
		JS_FS_END
	};
	static JSFunctionSpec st_funcs[] = {
		JS_FS_END
	};

	JSB_cpPolyShape_object = JS_InitClass(cx, globalObj, JSB_cpShape_object, JSB_cpPolyShape_class, JSB_cpPolyShape_constructor,0,properties,funcs,NULL,st_funcs);
	JSBool found;
	JS_SetPropertyAttributes(cx, globalObj, name, JSPROP_ENUMERATE | JSPROP_READONLY, &found);
}


#endif // JSB_INCLUDE_CHIPMUNK

/*
* AUTOGENERATED FILE. DO NOT EDIT IT
* Generated by "generate_jsb.py -c opengl_jsb.ini" on 2013-03-05
* Script version: v0.6
*/
#include "scripting/js-bindings/manual/js_bindings_config.h"
#ifdef JSB_INCLUDE_OPENGL

#include "scripting/js-bindings/manual/jsb_opengl_manual.h"

#include "jsfriendapi.h"
//#include "jsb_config.h"
#include "scripting/js-bindings/manual/js_bindings_core.h"
#include "scripting/js-bindings/manual/js_manual_conversions.h"
#include "scripting/js-bindings/manual/jsb_opengl_functions.h"
#include "platform/CCGL.h"

// Arguments: GLenum
// Ret value: void
bool JSB_glActiveTexture(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0;

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glActiveTexture((GLenum)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLuint, GLuint
// Ret value: void
bool JSB_glAttachShader(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; uint32_t arg1; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint32( cx, args.get(1), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glAttachShader((GLuint)arg0 , (GLuint)arg1  );

    args.rval().setUndefined();
    return true;
}

// Arguments: GLuint, GLuint, char*
// Ret value: void
bool JSB_glBindAttribLocation(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 3, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; uint32_t arg1; const char* arg2; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint32( cx, args.get(1), &arg1 );
    ok &= jsval_to_charptr(cx, args.get(2), &arg2 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glBindAttribLocation((GLuint)arg0 , (GLuint)arg1 , (char*)arg2  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLuint
// Ret value: void
bool JSB_glBindBuffer(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; uint32_t arg1; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint32( cx, args.get(1), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glBindBuffer((GLenum)arg0 , (GLuint)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLuint
// Ret value: void
bool JSB_glBindFramebuffer(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; uint32_t arg1; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint32( cx, args.get(1), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glBindFramebuffer((GLenum)arg0 , (GLuint)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLuint
// Ret value: void
bool JSB_glBindRenderbuffer(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; uint32_t arg1; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint32( cx, args.get(1), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glBindRenderbuffer((GLenum)arg0 , (GLuint)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLuint
// Ret value: void
bool JSB_glBindTexture(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; uint32_t arg1; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint32( cx, args.get(1), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glBindTexture((GLenum)arg0 , (GLuint)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLclampf, GLclampf, GLclampf, GLclampf
// Ret value: void
bool JSB_glBlendColor(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 4, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    ok &= jsval_to_int32( cx, args.get(2), &arg2 );
    ok &= jsval_to_int32( cx, args.get(3), &arg3 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glBlendColor((GLclampf)arg0 , (GLclampf)arg1 , (GLclampf)arg2 , (GLclampf)arg3  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum
// Ret value: void
bool JSB_glBlendEquation(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glBlendEquation((GLenum)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLenum
// Ret value: void
bool JSB_glBlendEquationSeparate(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; uint32_t arg1; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint32( cx, args.get(1), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glBlendEquationSeparate((GLenum)arg0 , (GLenum)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLenum
// Ret value: void
bool JSB_glBlendFunc(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; uint32_t arg1; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint32( cx, args.get(1), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glBlendFunc((GLenum)arg0 , (GLenum)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLenum, GLenum, GLenum
// Ret value: void
bool JSB_glBlendFuncSeparate(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 4, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; uint32_t arg1; uint32_t arg2; uint32_t arg3; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint32( cx, args.get(1), &arg1 );
    ok &= jsval_to_uint32( cx, args.get(2), &arg2 );
    ok &= jsval_to_uint32( cx, args.get(3), &arg3 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glBlendFuncSeparate((GLenum)arg0 , (GLenum)arg1 , (GLenum)arg2 , (GLenum)arg3  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, ArrayBufferView, GLenum
// Ret value: void
bool JSB_glBufferData(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 3, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; void* arg1; uint32_t arg2; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    GLsizei count;
    ok &= JSB_get_arraybufferview_dataptr( cx, args.get(1), &count, &arg1);
    ok &= jsval_to_uint32( cx, args.get(2), &arg2 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glBufferData((GLenum)arg0 , count, (GLvoid*)arg1 , (GLenum)arg2  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLintptr, ArrayBufferView
// Ret value: void
bool JSB_glBufferSubData(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 3, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; int32_t arg1; void* arg2; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    GLsizei count;
    ok &= JSB_get_arraybufferview_dataptr( cx, args.get(2), &count, &arg2);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glBufferSubData((GLenum)arg0 , (GLintptr)arg1 , count, (GLvoid*)arg2  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum
// Ret value: GLenum
bool JSB_glCheckFramebufferStatus(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    GLenum ret_val;

    ret_val = glCheckFramebufferStatus((GLenum)arg0  );
    args.rval().set(UINT_TO_JSVAL((uint32_t)ret_val));
    return true;
}

// Arguments: GLbitfield
// Ret value: void
bool JSB_glClear(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glClear((GLbitfield)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLclampf, GLclampf, GLclampf, GLclampf
// Ret value: void
bool JSB_glClearColor(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 4, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    ok &= jsval_to_int32( cx, args.get(2), &arg2 );
    ok &= jsval_to_int32( cx, args.get(3), &arg3 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glClearColor((GLclampf)arg0 , (GLclampf)arg1 , (GLclampf)arg2 , (GLclampf)arg3  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLclampf
// Ret value: void
bool JSB_glClearDepthf(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glClearDepthf((GLclampf)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLint
// Ret value: void
bool JSB_glClearStencil(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glClearStencil((GLint)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLboolean, GLboolean, GLboolean, GLboolean
// Ret value: void
bool JSB_glColorMask(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 4, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint16_t arg0; uint16_t arg1; uint16_t arg2; uint16_t arg3; 

    ok &= jsval_to_uint16( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint16( cx, args.get(1), &arg1 );
    ok &= jsval_to_uint16( cx, args.get(2), &arg2 );
    ok &= jsval_to_uint16( cx, args.get(3), &arg3 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glColorMask((GLboolean)arg0 , (GLboolean)arg1 , (GLboolean)arg2 , (GLboolean)arg3  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLuint
// Ret value: void
bool JSB_glCompileShader(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glCompileShader((GLuint)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLint, GLenum, GLsizei, GLsizei, GLint, GLsizei, ArrayBufferView
// Ret value: void
bool JSB_glCompressedTexImage2D(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 8, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; int32_t arg1; uint32_t arg2; int32_t arg3; int32_t arg4; int32_t arg5; int32_t arg6; void* arg7; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    ok &= jsval_to_uint32( cx, args.get(2), &arg2 );
    ok &= jsval_to_int32( cx, args.get(3), &arg3 );
    ok &= jsval_to_int32( cx, args.get(4), &arg4 );
    ok &= jsval_to_int32( cx, args.get(5), &arg5 );
    ok &= jsval_to_int32( cx, args.get(6), &arg6 );
    GLsizei count;
    ok &= JSB_get_arraybufferview_dataptr( cx, args.get(7), &count, &arg7);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glCompressedTexImage2D((GLenum)arg0 , (GLint)arg1 , (GLenum)arg2 , (GLsizei)arg3 , (GLsizei)arg4 , (GLint)arg5 , (GLsizei)arg6 , (GLvoid*)arg7  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLsizei, ArrayBufferView
// Ret value: void
bool JSB_glCompressedTexSubImage2D(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 9, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; int32_t arg4; int32_t arg5; uint32_t arg6; int32_t arg7; void* arg8; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    ok &= jsval_to_int32( cx, args.get(2), &arg2 );
    ok &= jsval_to_int32( cx, args.get(3), &arg3 );
    ok &= jsval_to_int32( cx, args.get(4), &arg4 );
    ok &= jsval_to_int32( cx, args.get(5), &arg5 );
    ok &= jsval_to_uint32( cx, args.get(6), &arg6 );
    ok &= jsval_to_int32( cx, args.get(7), &arg7 );
    GLsizei count;
    ok &= JSB_get_arraybufferview_dataptr( cx, args.get(8), &count, &arg8);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glCompressedTexSubImage2D((GLenum)arg0 , (GLint)arg1 , (GLint)arg2 , (GLint)arg3 , (GLsizei)arg4 , (GLsizei)arg5 , (GLenum)arg6 , (GLsizei)arg7 , (GLvoid*)arg8  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLint, GLenum, GLint, GLint, GLsizei, GLsizei, GLint
// Ret value: void
bool JSB_glCopyTexImage2D(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 8, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; int32_t arg1; uint32_t arg2; int32_t arg3; int32_t arg4; int32_t arg5; int32_t arg6; int32_t arg7; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    ok &= jsval_to_uint32( cx, args.get(2), &arg2 );
    ok &= jsval_to_int32( cx, args.get(3), &arg3 );
    ok &= jsval_to_int32( cx, args.get(4), &arg4 );
    ok &= jsval_to_int32( cx, args.get(5), &arg5 );
    ok &= jsval_to_int32( cx, args.get(6), &arg6 );
    ok &= jsval_to_int32( cx, args.get(7), &arg7 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glCopyTexImage2D((GLenum)arg0 , (GLint)arg1 , (GLenum)arg2 , (GLint)arg3 , (GLint)arg4 , (GLsizei)arg5 , (GLsizei)arg6 , (GLint)arg7  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLint, GLint, GLint, GLint, GLint, GLsizei, GLsizei
// Ret value: void
bool JSB_glCopyTexSubImage2D(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 8, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; int32_t arg4; int32_t arg5; int32_t arg6; int32_t arg7; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    ok &= jsval_to_int32( cx, args.get(2), &arg2 );
    ok &= jsval_to_int32( cx, args.get(3), &arg3 );
    ok &= jsval_to_int32( cx, args.get(4), &arg4 );
    ok &= jsval_to_int32( cx, args.get(5), &arg5 );
    ok &= jsval_to_int32( cx, args.get(6), &arg6 );
    ok &= jsval_to_int32( cx, args.get(7), &arg7 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glCopyTexSubImage2D((GLenum)arg0 , (GLint)arg1 , (GLint)arg2 , (GLint)arg3 , (GLint)arg4 , (GLint)arg5 , (GLsizei)arg6 , (GLsizei)arg7  );
    args.rval().setUndefined();
    return true;
}

// Arguments: 
// Ret value: GLuint
bool JSB_glCreateProgram(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    GLuint ret_val;

    ret_val = glCreateProgram( );
    args.rval().set(UINT_TO_JSVAL((uint32_t)ret_val));
    return true;
}

// Arguments: GLenum
// Ret value: GLuint
bool JSB_glCreateShader(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    GLuint ret_val;

    ret_val = glCreateShader((GLenum)arg0  );
    args.rval().set(UINT_TO_JSVAL((uint32_t)ret_val));
    return true;
}

// Arguments: GLenum
// Ret value: void
bool JSB_glCullFace(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glCullFace((GLenum)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLuint
// Ret value: void
bool JSB_glDeleteProgram(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glDeleteProgram((GLuint)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLuint
// Ret value: void
bool JSB_glDeleteShader(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glDeleteShader((GLuint)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum
// Ret value: void
bool JSB_glDepthFunc(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glDepthFunc((GLenum)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLboolean
// Ret value: void
bool JSB_glDepthMask(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint16_t arg0; 

    ok &= jsval_to_uint16( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glDepthMask((GLboolean)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLclampf, GLclampf
// Ret value: void
bool JSB_glDepthRangef(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; int32_t arg1; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glDepthRangef((GLclampf)arg0 , (GLclampf)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLuint, GLuint
// Ret value: void
bool JSB_glDetachShader(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; uint32_t arg1; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint32( cx, args.get(1), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glDetachShader((GLuint)arg0 , (GLuint)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum
// Ret value: void
bool JSB_glDisable(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glDisable((GLenum)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLuint
// Ret value: void
bool JSB_glDisableVertexAttribArray(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glDisableVertexAttribArray((GLuint)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLint, GLsizei
// Ret value: void
bool JSB_glDrawArrays(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 3, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; int32_t arg1; int32_t arg2; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    ok &= jsval_to_int32( cx, args.get(2), &arg2 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glDrawArrays((GLenum)arg0 , (GLint)arg1 , (GLsizei)arg2  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLsizei, GLenum, ArrayBufferView
// Ret value: void
bool JSB_glDrawElements(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 4, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; int32_t arg1; uint32_t arg2; void* arg3; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    ok &= jsval_to_uint32( cx, args.get(2), &arg2 );
    GLsizei count;
    ok &= JSB_get_arraybufferview_dataptr( cx, args.get(3), &count, &arg3);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glDrawElements((GLenum)arg0 , (GLsizei)arg1 , (GLenum)arg2 , (GLvoid*)arg3  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum
// Ret value: void
bool JSB_glEnable(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glEnable((GLenum)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLuint
// Ret value: void
bool JSB_glEnableVertexAttribArray(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glEnableVertexAttribArray((GLuint)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: 
// Ret value: void
bool JSB_glFinish(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    glFinish( );
    args.rval().setUndefined();
    return true;
}

// Arguments: 
// Ret value: void
bool JSB_glFlush(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    glFlush( );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLenum, GLenum, GLuint
// Ret value: void
bool JSB_glFramebufferRenderbuffer(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 4, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; uint32_t arg1; uint32_t arg2; uint32_t arg3; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint32( cx, args.get(1), &arg1 );
    ok &= jsval_to_uint32( cx, args.get(2), &arg2 );
    ok &= jsval_to_uint32( cx, args.get(3), &arg3 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glFramebufferRenderbuffer((GLenum)arg0 , (GLenum)arg1 , (GLenum)arg2 , (GLuint)arg3  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLenum, GLenum, GLuint, GLint
// Ret value: void
bool JSB_glFramebufferTexture2D(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 5, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; uint32_t arg1; uint32_t arg2; uint32_t arg3; int32_t arg4; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint32( cx, args.get(1), &arg1 );
    ok &= jsval_to_uint32( cx, args.get(2), &arg2 );
    ok &= jsval_to_uint32( cx, args.get(3), &arg3 );
    ok &= jsval_to_int32( cx, args.get(4), &arg4 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glFramebufferTexture2D((GLenum)arg0 , (GLenum)arg1 , (GLenum)arg2 , (GLuint)arg3 , (GLint)arg4  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum
// Ret value: void
bool JSB_glFrontFace(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glFrontFace((GLenum)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum
// Ret value: void
bool JSB_glGenerateMipmap(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glGenerateMipmap((GLenum)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLuint, char*
// Ret value: int
bool JSB_glGetAttribLocation(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; const char* arg1; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_charptr( cx, args.get(1), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    int ret_val;

    ret_val = glGetAttribLocation((GLuint)arg0 , (char*)arg1  );
    args.rval().set(INT_TO_JSVAL((int32_t)ret_val));
    return true;
}

// Arguments: 
// Ret value: GLenum
bool JSB_glGetError(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    GLenum ret_val;

    ret_val = glGetError( );
    args.rval().set(UINT_TO_JSVAL((uint32_t)ret_val));
    return true;
}

// Arguments: GLuint, char*
// Ret value: int
bool JSB_glGetUniformLocation(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; const char* arg1; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_charptr( cx, args.get(1), &arg1 );
    printf("%s ", arg1);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    int ret_val;

    ret_val = glGetUniformLocation((GLuint)arg0 , (char*)arg1  );
    args.rval().set(INT_TO_JSVAL((int32_t)ret_val));
    return true;
}

// Arguments: GLenum, GLenum
// Ret value: void
bool JSB_glHint(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; uint32_t arg1; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint32( cx, args.get(1), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glHint((GLenum)arg0 , (GLenum)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLuint
// Ret value: GLboolean
bool JSB_glIsBuffer(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    GLboolean ret_val;

    ret_val = glIsBuffer((GLuint)arg0  );
    args.rval().set(INT_TO_JSVAL((int32_t)ret_val));
    return true;
}

// Arguments: GLenum
// Ret value: GLboolean
bool JSB_glIsEnabled(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    GLboolean ret_val;

    ret_val = glIsEnabled((GLenum)arg0  );
    args.rval().set(INT_TO_JSVAL((int32_t)ret_val));
    return true;
}

// Arguments: GLuint
// Ret value: GLboolean
bool JSB_glIsFramebuffer(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    GLboolean ret_val;

    ret_val = glIsFramebuffer((GLuint)arg0  );
    args.rval().set(INT_TO_JSVAL((int32_t)ret_val));
    return true;
}

// Arguments: GLuint
// Ret value: GLboolean
bool JSB_glIsProgram(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    GLboolean ret_val;

    ret_val = glIsProgram((GLuint)arg0  );
    args.rval().set(INT_TO_JSVAL((int32_t)ret_val));
    return true;
}

// Arguments: GLuint
// Ret value: GLboolean
bool JSB_glIsRenderbuffer(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    GLboolean ret_val;

    ret_val = glIsRenderbuffer((GLuint)arg0  );
    args.rval().set(INT_TO_JSVAL((int32_t)ret_val));
    return true;
}

// Arguments: GLuint
// Ret value: GLboolean
bool JSB_glIsShader(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    GLboolean ret_val;

    ret_val = glIsShader((GLuint)arg0  );
    args.rval().set(INT_TO_JSVAL((int32_t)ret_val));
    return true;
}

// Arguments: GLuint
// Ret value: GLboolean
bool JSB_glIsTexture(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    GLboolean ret_val;

    ret_val = glIsTexture((GLuint)arg0  );
    args.rval().set(INT_TO_JSVAL((int32_t)ret_val));
    return true;
}

// Arguments: GLfloat
// Ret value: void
bool JSB_glLineWidth(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glLineWidth((GLfloat)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLuint
// Ret value: void
bool JSB_glLinkProgram(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glLinkProgram((GLuint)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLint
// Ret value: void
bool JSB_glPixelStorei(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; int32_t arg1; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glPixelStorei((GLenum)arg0 , (GLint)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLfloat, GLfloat
// Ret value: void
bool JSB_glPolygonOffset(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; int32_t arg1; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glPolygonOffset((GLfloat)arg0 , (GLfloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, ArrayBufferView
// Ret value: void
bool JSB_glReadPixels(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 7, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; uint32_t arg4; uint32_t arg5; void* arg6; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    ok &= jsval_to_int32( cx, args.get(2), &arg2 );
    ok &= jsval_to_int32( cx, args.get(3), &arg3 );
    ok &= jsval_to_uint32( cx, args.get(4), &arg4 );
    ok &= jsval_to_uint32( cx, args.get(5), &arg5 );
    GLsizei count;
    ok &= JSB_get_arraybufferview_dataptr( cx, args.get(6), &count, &arg6);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glReadPixels((GLint)arg0 , (GLint)arg1 , (GLsizei)arg2 , (GLsizei)arg3 , (GLenum)arg4 , (GLenum)arg5 , (GLvoid*)arg6  );
    args.rval().setUndefined();
    return true;
}

// Arguments: 
// Ret value: void
bool JSB_glReleaseShaderCompiler(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    glReleaseShaderCompiler( );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLenum, GLsizei, GLsizei
// Ret value: void
bool JSB_glRenderbufferStorage(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 4, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; uint32_t arg1; int32_t arg2; int32_t arg3; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint32( cx, args.get(1), &arg1 );
    ok &= jsval_to_int32( cx, args.get(2), &arg2 );
    ok &= jsval_to_int32( cx, args.get(3), &arg3 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glRenderbufferStorage((GLenum)arg0 , (GLenum)arg1 , (GLsizei)arg2 , (GLsizei)arg3  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLclampf, GLboolean
// Ret value: void
bool JSB_glSampleCoverage(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; uint16_t arg1; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint16( cx, args.get(1), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glSampleCoverage((GLclampf)arg0 , (GLboolean)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLint, GLint, GLsizei, GLsizei
// Ret value: void
bool JSB_glScissor(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 4, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    ok &= jsval_to_int32( cx, args.get(2), &arg2 );
    ok &= jsval_to_int32( cx, args.get(3), &arg3 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glScissor((GLint)arg0 , (GLint)arg1 , (GLsizei)arg2 , (GLsizei)arg3  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLint, GLuint
// Ret value: void
bool JSB_glStencilFunc(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 3, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; int32_t arg1; uint32_t arg2; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    ok &= jsval_to_uint32( cx, args.get(2), &arg2 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glStencilFunc((GLenum)arg0 , (GLint)arg1 , (GLuint)arg2  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLenum, GLint, GLuint
// Ret value: void
bool JSB_glStencilFuncSeparate(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 4, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; uint32_t arg1; int32_t arg2; uint32_t arg3; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint32( cx, args.get(1), &arg1 );
    ok &= jsval_to_int32( cx, args.get(2), &arg2 );
    ok &= jsval_to_uint32( cx, args.get(3), &arg3 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glStencilFuncSeparate((GLenum)arg0 , (GLenum)arg1 , (GLint)arg2 , (GLuint)arg3  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLuint
// Ret value: void
bool JSB_glStencilMask(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glStencilMask((GLuint)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLuint
// Ret value: void
bool JSB_glStencilMaskSeparate(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; uint32_t arg1; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint32( cx, args.get(1), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glStencilMaskSeparate((GLenum)arg0 , (GLuint)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLenum, GLenum
// Ret value: void
bool JSB_glStencilOp(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 3, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; uint32_t arg1; uint32_t arg2; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint32( cx, args.get(1), &arg1 );
    ok &= jsval_to_uint32( cx, args.get(2), &arg2 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glStencilOp((GLenum)arg0 , (GLenum)arg1 , (GLenum)arg2  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLenum, GLenum, GLenum
// Ret value: void
bool JSB_glStencilOpSeparate(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 4, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; uint32_t arg1; uint32_t arg2; uint32_t arg3; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint32( cx, args.get(1), &arg1 );
    ok &= jsval_to_uint32( cx, args.get(2), &arg2 );
    ok &= jsval_to_uint32( cx, args.get(3), &arg3 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glStencilOpSeparate((GLenum)arg0 , (GLenum)arg1 , (GLenum)arg2 , (GLenum)arg3  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLint, GLint, GLsizei, GLsizei, GLint, GLenum, GLenum, ArrayBufferView
// Ret value: void
bool JSB_glTexImage2D(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 9, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; int32_t arg4; int32_t arg5; uint32_t arg6; uint32_t arg7; void* arg8; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    ok &= jsval_to_int32( cx, args.get(2), &arg2 );
    ok &= jsval_to_int32( cx, args.get(3), &arg3 );
    ok &= jsval_to_int32( cx, args.get(4), &arg4 );
    ok &= jsval_to_int32( cx, args.get(5), &arg5 );
    ok &= jsval_to_uint32( cx, args.get(6), &arg6 );
    ok &= jsval_to_uint32( cx, args.get(7), &arg7 );
    GLsizei count;
    ok &= JSB_get_arraybufferview_dataptr( cx, args.get(8), &count, &arg8);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glTexImage2D((GLenum)arg0 , (GLint)arg1 , (GLint)arg2 , (GLsizei)arg3 , (GLsizei)arg4 , (GLint)arg5 , (GLenum)arg6 , (GLenum)arg7 , (GLvoid*)arg8  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLenum, GLfloat
// Ret value: void
bool JSB_glTexParameterf(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 3, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; uint32_t arg1; int32_t arg2; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint32( cx, args.get(1), &arg1 );
    ok &= jsval_to_int32( cx, args.get(2), &arg2 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glTexParameterf((GLenum)arg0 , (GLenum)arg1 , (GLfloat)arg2  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLenum, GLint
// Ret value: void
bool JSB_glTexParameteri(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 3, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; uint32_t arg1; int32_t arg2; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint32( cx, args.get(1), &arg1 );
    ok &= jsval_to_int32( cx, args.get(2), &arg2 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glTexParameteri((GLenum)arg0 , (GLenum)arg1 , (GLint)arg2  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLenum, GLint, GLint, GLint, GLsizei, GLsizei, GLenum, GLenum, ArrayBufferView
// Ret value: void
bool JSB_glTexSubImage2D(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 9, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; int32_t arg4; int32_t arg5; uint32_t arg6; uint32_t arg7; void* arg8; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    ok &= jsval_to_int32( cx, args.get(2), &arg2 );
    ok &= jsval_to_int32( cx, args.get(3), &arg3 );
    ok &= jsval_to_int32( cx, args.get(4), &arg4 );
    ok &= jsval_to_int32( cx, args.get(5), &arg5 );
    ok &= jsval_to_uint32( cx, args.get(6), &arg6 );
    ok &= jsval_to_uint32( cx, args.get(7), &arg7 );
    GLsizei count;
    ok &= JSB_get_arraybufferview_dataptr( cx, args.get(8), &count, &arg8);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glTexSubImage2D((GLenum)arg0 , (GLint)arg1 , (GLint)arg2 , (GLint)arg3 , (GLsizei)arg4 , (GLsizei)arg5 , (GLenum)arg6 , (GLenum)arg7 , (GLvoid*)arg8  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLint, GLfloat
// Ret value: void
bool JSB_glUniform1f(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; int32_t arg1; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glUniform1f((GLint)arg0 , (GLfloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLint, GLsizei, TypedArray/Sequence
// Ret value: void
bool JSB_glUniform1fv(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 3, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; int32_t arg1; void* arg2; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    GLsizei count;
    ok &= JSB_jsval_typedarray_to_dataptr( cx, args.get(2), &count, &arg2, js::Scalar::Float32);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glUniform1fv((GLint)arg0 , (GLsizei)arg1 , (GLfloat*)arg2  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLint, GLint
// Ret value: void
bool JSB_glUniform1i(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; int32_t arg1; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glUniform1i((GLint)arg0 , (GLint)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLint, GLsizei, TypedArray/Sequence
// Ret value: void
bool JSB_glUniform1iv(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 3, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; int32_t arg1; void* arg2; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    GLsizei count;
    ok &= JSB_jsval_typedarray_to_dataptr( cx, args.get(2), &count, &arg2, js::Scalar::Int32);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glUniform1iv((GLint)arg0 , (GLsizei)arg1 , (GLint*)arg2  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLint, GLfloat, GLfloat
// Ret value: void
bool JSB_glUniform2f(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 3, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; int32_t arg1; int32_t arg2; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    ok &= jsval_to_int32( cx, args.get(2), &arg2 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glUniform2f((GLint)arg0 , (GLfloat)arg1 , (GLfloat)arg2  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLint, GLsizei, TypedArray/Sequence
// Ret value: void
bool JSB_glUniform2fv(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 3, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; int32_t arg1; void* arg2; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    GLsizei count;
    ok &= JSB_jsval_typedarray_to_dataptr( cx, args.get(2), &count, &arg2, js::Scalar::Float32);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glUniform2fv((GLint)arg0 , (GLsizei)arg1 , (GLfloat*)arg2  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLint, GLint, GLint
// Ret value: void
bool JSB_glUniform2i(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 3, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; int32_t arg1; int32_t arg2; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    ok &= jsval_to_int32( cx, args.get(2), &arg2 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glUniform2i((GLint)arg0 , (GLint)arg1 , (GLint)arg2  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLint, GLsizei, TypedArray/Sequence
// Ret value: void
bool JSB_glUniform2iv(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 3, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; int32_t arg1; void* arg2; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    GLsizei count;
    ok &= JSB_jsval_typedarray_to_dataptr( cx, args.get(2), &count, &arg2, js::Scalar::Int32);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glUniform2iv((GLint)arg0 , (GLsizei)arg1 , (GLint*)arg2  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLint, GLfloat, GLfloat, GLfloat
// Ret value: void
bool JSB_glUniform3f(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 4, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    ok &= jsval_to_int32( cx, args.get(2), &arg2 );
    ok &= jsval_to_int32( cx, args.get(3), &arg3 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glUniform3f((GLint)arg0 , (GLfloat)arg1 , (GLfloat)arg2 , (GLfloat)arg3  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLint, GLsizei, TypedArray/Sequence
// Ret value: void
bool JSB_glUniform3fv(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 3, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; int32_t arg1; void* arg2; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    GLsizei count;
    ok &= JSB_jsval_typedarray_to_dataptr( cx, args.get(2), &count, &arg2, js::Scalar::Float32);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glUniform3fv((GLint)arg0 , (GLsizei)arg1 , (GLfloat*)arg2  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLint, GLint, GLint, GLint
// Ret value: void
bool JSB_glUniform3i(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 4, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    ok &= jsval_to_int32( cx, args.get(2), &arg2 );
    ok &= jsval_to_int32( cx, args.get(3), &arg3 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glUniform3i((GLint)arg0 , (GLint)arg1 , (GLint)arg2 , (GLint)arg3  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLint, GLsizei, TypedArray/Sequence
// Ret value: void
bool JSB_glUniform3iv(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 3, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; int32_t arg1; void* arg2; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    GLsizei count;
    ok &= JSB_jsval_typedarray_to_dataptr( cx, args.get(2), &count, &arg2, js::Scalar::Int32);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glUniform3iv((GLint)arg0 , (GLsizei)arg1 , (GLint*)arg2  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLint, GLfloat, GLfloat, GLfloat, GLfloat
// Ret value: void
bool JSB_glUniform4f(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 5, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; int32_t arg4; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    ok &= jsval_to_int32( cx, args.get(2), &arg2 );
    ok &= jsval_to_int32( cx, args.get(3), &arg3 );
    ok &= jsval_to_int32( cx, args.get(4), &arg4 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glUniform4f((GLint)arg0 , (GLfloat)arg1 , (GLfloat)arg2 , (GLfloat)arg3 , (GLfloat)arg4  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLint, GLsizei, TypedArray/Sequence
// Ret value: void
bool JSB_glUniform4fv(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 3, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; int32_t arg1; void* arg2; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    GLsizei count;
    ok &= JSB_jsval_typedarray_to_dataptr( cx, args.get(2), &count, &arg2, js::Scalar::Float32);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glUniform4fv((GLint)arg0 , (GLsizei)arg1 , (GLfloat*)arg2  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLint, GLint, GLint, GLint, GLint
// Ret value: void
bool JSB_glUniform4i(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 5, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; int32_t arg4; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    ok &= jsval_to_int32( cx, args.get(2), &arg2 );
    ok &= jsval_to_int32( cx, args.get(3), &arg3 );
    ok &= jsval_to_int32( cx, args.get(4), &arg4 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glUniform4i((GLint)arg0 , (GLint)arg1 , (GLint)arg2 , (GLint)arg3 , (GLint)arg4  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLint, GLsizei, TypedArray/Sequence
// Ret value: void
bool JSB_glUniform4iv(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 3, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; int32_t arg1; void* arg2; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    GLsizei count;
    ok &= JSB_jsval_typedarray_to_dataptr( cx, args.get(2), &count, &arg2, js::Scalar::Int32);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glUniform4iv((GLint)arg0 , (GLsizei)arg1 , (GLint*)arg2  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLint, GLboolean, TypedArray/Sequence
// Ret value: void
bool JSB_glUniformMatrix2fv(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 3, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; uint16_t arg1; void* arg2; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint16( cx, args.get(1), &arg1 );
    GLsizei count;
    ok &= JSB_jsval_typedarray_to_dataptr( cx, args.get(2), &count, &arg2, js::Scalar::Float32);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glUniformMatrix2fv(arg0, 1, (GLboolean)arg1 , (GLfloat*)arg2  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLint, GLboolean, TypedArray/Sequence
// Ret value: void
bool JSB_glUniformMatrix3fv(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 3, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; uint16_t arg1; void* arg2; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint16( cx, args.get(1), &arg1 );
    GLsizei count;
    ok &= JSB_jsval_typedarray_to_dataptr( cx, args.get(2), &count, &arg2, js::Scalar::Float32);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glUniformMatrix3fv(arg0, 1, (GLboolean)arg1 , (GLfloat*)arg2  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLint, GLboolean, TypedArray/Sequence
// Ret value: void
bool JSB_glUniformMatrix4fv(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 3, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; uint16_t arg1; void* arg2; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_uint16( cx, args.get(1), &arg1 );
    GLsizei count;
    ok &= JSB_jsval_typedarray_to_dataptr( cx, args.get(2), &count, &arg2, js::Scalar::Float32);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glUniformMatrix4fv(arg0, 1, (GLboolean)arg1 , (GLfloat*)arg2  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLuint
// Ret value: void
bool JSB_glUseProgram(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glUseProgram((GLuint)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLuint
// Ret value: void
bool JSB_glValidateProgram(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glValidateProgram((GLuint)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLuint, GLfloat
// Ret value: void
bool JSB_glVertexAttrib1f(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; int32_t arg1; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glVertexAttrib1f((GLuint)arg0 , (GLfloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLuint, TypedArray/Sequence
// Ret value: void
bool JSB_glVertexAttrib1fv(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; void* arg1; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    GLsizei count;
    ok &= JSB_jsval_typedarray_to_dataptr( cx, args.get(1), &count, &arg1, js::Scalar::Float32);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glVertexAttrib1fv((GLuint)arg0 , (GLfloat*)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLuint, GLfloat, GLfloat
// Ret value: void
bool JSB_glVertexAttrib2f(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 3, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; int32_t arg1; int32_t arg2; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    ok &= jsval_to_int32( cx, args.get(2), &arg2 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glVertexAttrib2f((GLuint)arg0 , (GLfloat)arg1 , (GLfloat)arg2  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLuint, TypedArray/Sequence
// Ret value: void
bool JSB_glVertexAttrib2fv(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; void* arg1; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    GLsizei count;
    ok &= JSB_jsval_typedarray_to_dataptr( cx, args.get(1), &count, &arg1, js::Scalar::Float32);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glVertexAttrib2fv((GLuint)arg0 , (GLfloat*)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLuint, GLfloat, GLfloat, GLfloat
// Ret value: void
bool JSB_glVertexAttrib3f(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 4, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    ok &= jsval_to_int32( cx, args.get(2), &arg2 );
    ok &= jsval_to_int32( cx, args.get(3), &arg3 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glVertexAttrib3f((GLuint)arg0 , (GLfloat)arg1 , (GLfloat)arg2 , (GLfloat)arg3  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLuint, TypedArray/Sequence
// Ret value: void
bool JSB_glVertexAttrib3fv(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; void* arg1; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    GLsizei count;
    ok &= JSB_jsval_typedarray_to_dataptr( cx, args.get(1), &count, &arg1, js::Scalar::Float32);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glVertexAttrib3fv((GLuint)arg0 , (GLfloat*)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLuint, GLfloat, GLfloat, GLfloat, GLfloat
// Ret value: void
bool JSB_glVertexAttrib4f(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 5, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; int32_t arg4; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    ok &= jsval_to_int32( cx, args.get(2), &arg2 );
    ok &= jsval_to_int32( cx, args.get(3), &arg3 );
    ok &= jsval_to_int32( cx, args.get(4), &arg4 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glVertexAttrib4f((GLuint)arg0 , (GLfloat)arg1 , (GLfloat)arg2 , (GLfloat)arg3 , (GLfloat)arg4  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLuint, TypedArray/Sequence
// Ret value: void
bool JSB_glVertexAttrib4fv(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; void* arg1; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    GLsizei count;
    ok &= JSB_jsval_typedarray_to_dataptr( cx, args.get(1), &count, &arg1, js::Scalar::Float32);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glVertexAttrib4fv((GLuint)arg0 , (GLfloat*)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLuint, GLint, GLenum, GLboolean, GLsizei, GLvoid*
// Ret value: void
bool JSB_glVertexAttribPointer(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 6, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    uint32_t arg0; int32_t arg1; uint32_t arg2; uint16_t arg3; int32_t arg4; int32_t arg5; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    ok &= jsval_to_uint32( cx, args.get(2), &arg2 );
    ok &= jsval_to_uint16( cx, args.get(3), &arg3 );
    ok &= jsval_to_int32( cx, args.get(4), &arg4 );
    ok &= jsval_to_int32( cx, args.get(5), &arg5 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glVertexAttribPointer((GLuint)arg0 , (GLint)arg1 , (GLenum)arg2 , (GLboolean)arg3 , (GLsizei)arg4 , (GLvoid*)arg5  );
    args.rval().setUndefined();
    return true;
}

// Arguments: GLint, GLint, GLsizei, GLsizei
// Ret value: void
bool JSB_glViewport(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 4, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    int32_t arg0; int32_t arg1; int32_t arg2; int32_t arg3; 

    ok &= jsval_to_int32( cx, args.get(0), &arg0 );
    ok &= jsval_to_int32( cx, args.get(1), &arg1 );
    ok &= jsval_to_int32( cx, args.get(2), &arg2 );
    ok &= jsval_to_int32( cx, args.get(3), &arg3 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    glViewport((GLint)arg0 , (GLint)arg1 , (GLsizei)arg2 , (GLsizei)arg3  );
    args.rval().setUndefined();
    return true;
}


#endif // JSB_INCLUDE_OPENGL

/*
* AUTOGENERATED FILE. DO NOT EDIT IT
* Generated by "generate_js_bindings.py -c chipmunk_jsb.ini" on 2012-11-07
* Script version: v0.3
*/
#include "js_bindings_config.h"
#ifdef JSB_INCLUDE_CHIPMUNK

#include "js_bindings_chipmunk_manual.h"

#include "jsfriendapi.h"
#include "js_bindings_config.h"
#include "js_manual_conversions.h"
#include "js_bindings_chipmunk_functions.h"

/*
 * cpConstraint
 */
#pragma mark - cpConstraint

JSClass* JSB_cpConstraint_class = NULL;
JSObject* JSB_cpConstraint_object = NULL;

// Constructor
bool JSB_cpConstraint_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSB_PRECONDITION2(argc==0, cx, false, "Invalid number of arguments");
    JSB_PRECONDITION2(false, cx, true, "No constructor");

    return true;
}

// Destructor
void JSB_cpConstraint_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    if( proxy ) {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpConstraint), handle: %p", jsthis, proxy->handle);

        jsb_del_jsobject_for_proxy(proxy->handle);
        if(proxy->flags == JSB_C_FLAG_CALL_FREE)
            cpConstraintFree( (cpConstraint*)proxy->handle);
        jsb_del_c_proxy_for_jsobject(jsthis);
    } else {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpConstraint)", jsthis);
    }
}

// Arguments: 
// Ret value: void
bool JSB_cpConstraint_activateBodies(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpConstraint* arg0 = (cpConstraint*) proxy->handle;

    cpConstraintActivateBodies((cpConstraint*)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: 
// Ret value: void
bool JSB_cpConstraint_destroy(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpConstraint* arg0 = (cpConstraint*) proxy->handle;

    cpConstraintDestroy((cpConstraint*)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: 
// Ret value: cpBody*
bool JSB_cpConstraint_getA(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpConstraint* arg0 = (cpConstraint*) proxy->handle;
    cpBody* ret_val = nullptr;

    ret_val = cpConstraintGetA((cpConstraint*)arg0  );

    JS::RootedObject bodyProto(cx, JSB_cpBody_object);
    jsval ret_jsval = c_class_to_jsval( cx, ret_val, bodyProto, JSB_cpBody_class, "cpBody" );
    args.rval().set(ret_jsval);
    
    return true;
}

// Arguments: 
// Ret value: cpBody*
bool JSB_cpConstraint_getB(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpConstraint* arg0 = (cpConstraint*) proxy->handle;
    cpBody* ret_val = nullptr;

    ret_val = cpConstraintGetB((cpConstraint*)arg0  );
    
    JS::RootedObject bodyProto(cx, JSB_cpBody_object);
    jsval ret_jsval = c_class_to_jsval( cx, ret_val, bodyProto, JSB_cpBody_class, "cpBody" );
    args.rval().set(ret_jsval);
    
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpConstraint_getErrorBias(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpConstraint* arg0 = (cpConstraint*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpConstraintGetErrorBias((cpConstraint*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpConstraint_getImpulse(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpConstraint* arg0 = (cpConstraint*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpConstraintGetImpulse((cpConstraint*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpConstraint_getMaxBias(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpConstraint* arg0 = (cpConstraint*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpConstraintGetMaxBias((cpConstraint*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpConstraint_getMaxForce(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpConstraint* arg0 = (cpConstraint*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpConstraintGetMaxForce((cpConstraint*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpSpace*
bool JSB_cpConstraint_getSpace(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpConstraint* arg0 = (cpConstraint*) proxy->handle;
    cpSpace* ret_val = nullptr;

    ret_val = cpConstraintGetSpace((cpConstraint*)arg0  );

    JS::RootedObject spaceProto(cx, JSB_cpSpace_object);
    jsval ret_jsval = c_class_to_jsval( cx, ret_val, spaceProto, JSB_cpSpace_class, "cpSpace" );
    args.rval().set(ret_jsval);
    
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpConstraint_setErrorBias(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpConstraint* arg0 = (cpConstraint*) proxy->handle;
    bool ok = true;
    double arg1; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpConstraintSetErrorBias((cpConstraint*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpConstraint_setMaxBias(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpConstraint* arg0 = (cpConstraint*) proxy->handle;
    bool ok = true;
    double arg1; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpConstraintSetMaxBias((cpConstraint*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpConstraint_setMaxForce(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpConstraint* arg0 = (cpConstraint*) proxy->handle;
    bool ok = true;
    double arg1; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpConstraintSetMaxForce((cpConstraint*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

void JSB_cpConstraint_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    JSB_cpConstraint_class = (JSClass *)calloc(1, sizeof(JSClass));
    JSB_cpConstraint_class->name = name;
    JSB_cpConstraint_class->addProperty = JS_PropertyStub;
    JSB_cpConstraint_class->delProperty = JS_DeletePropertyStub;
    JSB_cpConstraint_class->getProperty = JS_PropertyStub;
    JSB_cpConstraint_class->setProperty = JS_StrictPropertyStub;
    JSB_cpConstraint_class->enumerate = JS_EnumerateStub;
    JSB_cpConstraint_class->resolve = JS_ResolveStub;
    JSB_cpConstraint_class->convert = JS_ConvertStub;
    JSB_cpConstraint_class->finalize = JSB_cpConstraint_finalize;
    JSB_cpConstraint_class->flags = JSCLASS_HAS_PRIVATE;

    static JSPropertySpec properties[] = {
        JS_PS_END
    };
    static JSFunctionSpec funcs[] = {
        JS_FN("activateBodies", JSB_cpConstraint_activateBodies, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("destroy", JSB_cpConstraint_destroy, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getA", JSB_cpConstraint_getA, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getB", JSB_cpConstraint_getB, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getErrorBias", JSB_cpConstraint_getErrorBias, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getImpulse", JSB_cpConstraint_getImpulse, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getMaxBias", JSB_cpConstraint_getMaxBias, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getMaxForce", JSB_cpConstraint_getMaxForce, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getSpace", JSB_cpConstraint_getSpace, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setErrorBias", JSB_cpConstraint_setErrorBias, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setMaxBias", JSB_cpConstraint_setMaxBias, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setMaxForce", JSB_cpConstraint_setMaxForce, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FS_END
    };
    static JSFunctionSpec st_funcs[] = {
        JS_FS_END
    };

    JS::RootedObject baseProto(cx, JSB_cpBase_object);
    JSB_cpConstraint_object = JS_InitClass(cx, globalObj, baseProto, JSB_cpConstraint_class, JSB_cpConstraint_constructor,0,properties,funcs,NULL,st_funcs);
}

/*
 * cpGrooveJoint
 */
#pragma mark - cpGrooveJoint

JSClass* JSB_cpGrooveJoint_class = NULL;
JSObject* JSB_cpGrooveJoint_object = NULL;
// Arguments: cpBody*, cpBody*, cpVect, cpVect, cpVect
// Constructor
bool JSB_cpGrooveJoint_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSB_PRECONDITION2(argc==5, cx, false, "Invalid number of arguments");
    JS::RootedObject grooveJointProto(cx, JSB_cpGrooveJoint_object);
    JS::RootedObject jsobj(cx, JS_NewObject(cx, JSB_cpGrooveJoint_class, grooveJointProto, JS::NullPtr()));
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    cpBody* arg0 = nullptr; cpBody* arg1 = nullptr; cpVect arg2; cpVect arg3; cpVect arg4; 

    ok &= jsval_to_c_class( cx, args.get(0), (void**)&arg0, NULL );
    ok &= jsval_to_c_class( cx, args.get(1), (void**)&arg1, NULL );
    ok &= jsval_to_cpVect( cx, args.get(2), (cpVect*) &arg2 );
    ok &= jsval_to_cpVect( cx, args.get(3), (cpVect*) &arg3 );
    ok &= jsval_to_cpVect( cx, args.get(4), (cpVect*) &arg4 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    void*   ret_val = cpGrooveJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpVect)arg2 , (cpVect)arg3 , (cpVect)arg4  );

    jsb_set_jsobject_for_proxy(jsobj, ret_val);
    jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
    args.rval().set(OBJECT_TO_JSVAL(jsobj));

    return true;
}

// Destructor
void JSB_cpGrooveJoint_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    if( proxy ) {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpGrooveJoint), handle: %p", jsthis, proxy->handle);

        jsb_del_jsobject_for_proxy(proxy->handle);
        if(proxy->flags == JSB_C_FLAG_CALL_FREE)
            cpConstraintFree( (cpConstraint*)proxy->handle);
        jsb_del_c_proxy_for_jsobject(jsthis);
    } else {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpGrooveJoint)", jsthis);
    }
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpGrooveJoint_getAnchr2(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpGrooveJoint* arg0 = (cpGrooveJoint*) proxy->handle;
    cpVect ret_val;

    ret_val = cpGrooveJointGetAnchr2((cpConstraint*)arg0  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpGrooveJoint_getGrooveA(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpGrooveJoint* arg0 = (cpGrooveJoint*) proxy->handle;
    cpVect ret_val;

    ret_val = cpGrooveJointGetGrooveA((cpConstraint*)arg0  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpGrooveJoint_getGrooveB(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpGrooveJoint* arg0 = (cpGrooveJoint*) proxy->handle;
    cpVect ret_val;

    ret_val = cpGrooveJointGetGrooveB((cpConstraint*)arg0  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpGrooveJoint_setAnchr2(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpGrooveJoint* arg0 = (cpGrooveJoint*) proxy->handle;
    bool ok = true;
    cpVect arg1; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpGrooveJointSetAnchr2((cpConstraint*)arg0 , (cpVect)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpGrooveJoint_setGrooveA(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpGrooveJoint* arg0 = (cpGrooveJoint*) proxy->handle;
    bool ok = true;
    cpVect arg1; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpGrooveJointSetGrooveA((cpConstraint*)arg0 , (cpVect)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpGrooveJoint_setGrooveB(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpGrooveJoint* arg0 = (cpGrooveJoint*) proxy->handle;
    bool ok = true;
    cpVect arg1; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpGrooveJointSetGrooveB((cpConstraint*)arg0 , (cpVect)arg1  );
    args.rval().setUndefined();
    return true;
}

void JSB_cpGrooveJoint_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    JSB_cpGrooveJoint_class = (JSClass *)calloc(1, sizeof(JSClass));
    JSB_cpGrooveJoint_class->name = name;
    JSB_cpGrooveJoint_class->addProperty = JS_PropertyStub;
    JSB_cpGrooveJoint_class->delProperty = JS_DeletePropertyStub;
    JSB_cpGrooveJoint_class->getProperty = JS_PropertyStub;
    JSB_cpGrooveJoint_class->setProperty = JS_StrictPropertyStub;
    JSB_cpGrooveJoint_class->enumerate = JS_EnumerateStub;
    JSB_cpGrooveJoint_class->resolve = JS_ResolveStub;
    JSB_cpGrooveJoint_class->convert = JS_ConvertStub;
    JSB_cpGrooveJoint_class->finalize = JSB_cpGrooveJoint_finalize;
    JSB_cpGrooveJoint_class->flags = JSCLASS_HAS_PRIVATE;

    static JSPropertySpec properties[] = {
        JS_PS_END
    };
    static JSFunctionSpec funcs[] = {
        JS_FN("getAnchr2", JSB_cpGrooveJoint_getAnchr2, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getGrooveA", JSB_cpGrooveJoint_getGrooveA, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getGrooveB", JSB_cpGrooveJoint_getGrooveB, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setAnchr2", JSB_cpGrooveJoint_setAnchr2, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setGrooveA", JSB_cpGrooveJoint_setGrooveA, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setGrooveB", JSB_cpGrooveJoint_setGrooveB, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FS_END
    };
    static JSFunctionSpec st_funcs[] = {
        JS_FS_END
    };

    JS::RootedObject constraintProto(cx, JSB_cpConstraint_object);
    JSB_cpGrooveJoint_object = JS_InitClass(cx, globalObj, constraintProto, JSB_cpGrooveJoint_class, JSB_cpGrooveJoint_constructor,0,properties,funcs,NULL,st_funcs);
}

/*
 * cpSimpleMotor
 */
#pragma mark - cpSimpleMotor

JSClass* JSB_cpSimpleMotor_class = NULL;
JSObject* JSB_cpSimpleMotor_object = NULL;
// Arguments: cpBody*, cpBody*, cpFloat
// Constructor
bool JSB_cpSimpleMotor_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSB_PRECONDITION2(argc==3, cx, false, "Invalid number of arguments");
    JS::RootedObject simpleMotorProto(cx, JSB_cpSimpleMotor_object);
    JS::RootedObject jsobj(cx, JS_NewObject(cx, JSB_cpSimpleMotor_class, simpleMotorProto, JS::NullPtr()));
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    cpBody* arg0 = nullptr; cpBody* arg1 = nullptr; double arg2 = 0; 

    ok &= jsval_to_c_class( cx, args.get(0), (void**)&arg0, NULL );
    ok &= jsval_to_c_class( cx, args.get(1), (void**)&arg1, NULL );
    ok &= JS::ToNumber( cx, args.get(2), &arg2 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    void*   ret_val = cpSimpleMotorNew((cpBody*)arg0 , (cpBody*)arg1 , (cpFloat)arg2  );

    jsb_set_jsobject_for_proxy(jsobj, ret_val);
    jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
    args.rval().set(OBJECT_TO_JSVAL(jsobj));

    return true;
}

// Destructor
void JSB_cpSimpleMotor_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    if( proxy ) {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpSimpleMotor), handle: %p", jsthis, proxy->handle);

        jsb_del_jsobject_for_proxy(proxy->handle);
        if(proxy->flags == JSB_C_FLAG_CALL_FREE)
            cpConstraintFree( (cpConstraint*)proxy->handle);
        jsb_del_c_proxy_for_jsobject(jsthis);
    } else {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpSimpleMotor)", jsthis);
    }
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpSimpleMotor_getRate(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSimpleMotor* arg0 = (cpSimpleMotor*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpSimpleMotorGetRate((cpConstraint*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpSimpleMotor_setRate(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSimpleMotor* arg0 = (cpSimpleMotor*) proxy->handle;
    bool ok = true;
    double arg1; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpSimpleMotorSetRate((cpConstraint*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

void JSB_cpSimpleMotor_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    JSB_cpSimpleMotor_class = (JSClass *)calloc(1, sizeof(JSClass));
    JSB_cpSimpleMotor_class->name = name;
    JSB_cpSimpleMotor_class->addProperty = JS_PropertyStub;
    JSB_cpSimpleMotor_class->delProperty = JS_DeletePropertyStub;
    JSB_cpSimpleMotor_class->getProperty = JS_PropertyStub;
    JSB_cpSimpleMotor_class->setProperty = JS_StrictPropertyStub;
    JSB_cpSimpleMotor_class->enumerate = JS_EnumerateStub;
    JSB_cpSimpleMotor_class->resolve = JS_ResolveStub;
    JSB_cpSimpleMotor_class->convert = JS_ConvertStub;
    JSB_cpSimpleMotor_class->finalize = JSB_cpSimpleMotor_finalize;
    JSB_cpSimpleMotor_class->flags = JSCLASS_HAS_PRIVATE;

    static JSPropertySpec properties[] = {
        JS_PS_END
    };
    static JSFunctionSpec funcs[] = {
        JS_FN("getRate", JSB_cpSimpleMotor_getRate, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setRate", JSB_cpSimpleMotor_setRate, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FS_END
    };
    static JSFunctionSpec st_funcs[] = {
        JS_FS_END
    };

    JS::RootedObject constraintProto(cx, JSB_cpConstraint_object);
    JSB_cpSimpleMotor_object = JS_InitClass(cx, globalObj, constraintProto, JSB_cpSimpleMotor_class, JSB_cpSimpleMotor_constructor,0,properties,funcs,NULL,st_funcs);
}

/*
 * cpPivotJoint
 */
#pragma mark - cpPivotJoint

JSClass* JSB_cpPivotJoint_class = NULL;
JSObject* JSB_cpPivotJoint_object = NULL;
// Arguments: cpBody*, cpBody*, cpVect
// Constructor
bool JSB_cpPivotJoint_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSB_PRECONDITION2(argc==4 || argc==3, cx, false, "Invalid number of arguments");
    JS::RootedObject pivotJointProto(cx, JSB_cpPivotJoint_object);
    JS::RootedObject jsobj(cx, JS_NewObject(cx, JSB_cpPivotJoint_class, pivotJointProto, JS::NullPtr()));
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    cpBody* arg0 = nullptr; cpBody* arg1 = nullptr; cpVect arg2; cpVect arg3; void *ret_val = nullptr;

    ok &= jsval_to_c_class( cx, args.get(0), (void**)&arg0, NULL );
    ok &= jsval_to_c_class( cx, args.get(1), (void**)&arg1, NULL );
    ok &= jsval_to_cpVect( cx, args.get(2), (cpVect*) &arg2 );
    if(argc == 4) {
        ok &= jsval_to_cpVect( cx, args.get(3), (cpVect*) &arg3 );
        JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
        ret_val = cpPivotJointNew2((cpBody*)arg0 , (cpBody*)arg1 , (cpVect)arg2, (cpVect)arg3  );
    } else {
        JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
        ret_val = cpPivotJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpVect)arg2);
    }

    jsb_set_jsobject_for_proxy(jsobj, ret_val);
    jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
    args.rval().set(OBJECT_TO_JSVAL(jsobj));

    return true;
}
// Destructor
void JSB_cpPivotJoint_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    if( proxy ) {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpPivotJoint), handle: %p", jsthis, proxy->handle);

        jsb_del_jsobject_for_proxy(proxy->handle);
        if(proxy->flags == JSB_C_FLAG_CALL_FREE)
            cpConstraintFree( (cpConstraint*)proxy->handle);
        jsb_del_c_proxy_for_jsobject(jsthis);
    } else {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpPivotJoint)", jsthis);
    }
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpPivotJoint_getAnchr1(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpPivotJoint* arg0 = (cpPivotJoint*) proxy->handle;
    cpVect ret_val;

    ret_val = cpPivotJointGetAnchr1((cpConstraint*)arg0  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpPivotJoint_getAnchr2(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpPivotJoint* arg0 = (cpPivotJoint*) proxy->handle;
    cpVect ret_val;

    ret_val = cpPivotJointGetAnchr2((cpConstraint*)arg0  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpPivotJoint_setAnchr1(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpPivotJoint* arg0 = (cpPivotJoint*) proxy->handle;
    bool ok = true;
    cpVect arg1; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpPivotJointSetAnchr1((cpConstraint*)arg0 , (cpVect)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpPivotJoint_setAnchr2(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpPivotJoint* arg0 = (cpPivotJoint*) proxy->handle;
    bool ok = true;
    cpVect arg1; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpPivotJointSetAnchr2((cpConstraint*)arg0 , (cpVect)arg1  );
    args.rval().setUndefined();
    return true;
}

void JSB_cpPivotJoint_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    JSB_cpPivotJoint_class = (JSClass *)calloc(1, sizeof(JSClass));
    JSB_cpPivotJoint_class->name = name;
    JSB_cpPivotJoint_class->addProperty = JS_PropertyStub;
    JSB_cpPivotJoint_class->delProperty = JS_DeletePropertyStub;
    JSB_cpPivotJoint_class->getProperty = JS_PropertyStub;
    JSB_cpPivotJoint_class->setProperty = JS_StrictPropertyStub;
    JSB_cpPivotJoint_class->enumerate = JS_EnumerateStub;
    JSB_cpPivotJoint_class->resolve = JS_ResolveStub;
    JSB_cpPivotJoint_class->convert = JS_ConvertStub;
    JSB_cpPivotJoint_class->finalize = JSB_cpPivotJoint_finalize;
    JSB_cpPivotJoint_class->flags = JSCLASS_HAS_PRIVATE;

    static JSPropertySpec properties[] = {
        JS_PS_END
    };
    static JSFunctionSpec funcs[] = {
        JS_FN("getAnchr1", JSB_cpPivotJoint_getAnchr1, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getAnchr2", JSB_cpPivotJoint_getAnchr2, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setAnchr1", JSB_cpPivotJoint_setAnchr1, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setAnchr2", JSB_cpPivotJoint_setAnchr2, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FS_END
    };
    static JSFunctionSpec st_funcs[] = {
        JS_FS_END
    };
    
    JS::RootedObject constraintProto(cx, JSB_cpConstraint_object);
    JSB_cpPivotJoint_object = JS_InitClass(cx, globalObj, constraintProto, JSB_cpPivotJoint_class, JSB_cpPivotJoint_constructor,0,properties,funcs,NULL,st_funcs);
}

/*
 * cpPinJoint
 */
#pragma mark - cpPinJoint

JSClass* JSB_cpPinJoint_class = NULL;
JSObject* JSB_cpPinJoint_object = NULL;
// Arguments: cpBody*, cpBody*, cpVect, cpVect
// Constructor
bool JSB_cpPinJoint_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSB_PRECONDITION2(argc==4, cx, false, "Invalid number of arguments");
    JS::RootedObject pinJointProto(cx, JSB_cpPinJoint_object);
    JS::RootedObject jsobj(cx, JS_NewObject(cx, JSB_cpPinJoint_class, pinJointProto, JS::NullPtr()));
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    cpBody* arg0 = nullptr; cpBody* arg1 = nullptr; cpVect arg2; cpVect arg3; 

    ok &= jsval_to_c_class( cx, args.get(0), (void**)&arg0, NULL );
    ok &= jsval_to_c_class( cx, args.get(1), (void**)&arg1, NULL );
    ok &= jsval_to_cpVect( cx, args.get(2), (cpVect*) &arg2 );
    ok &= jsval_to_cpVect( cx, args.get(3), (cpVect*) &arg3 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    void*   ret_val = cpPinJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpVect)arg2 , (cpVect)arg3  );

    jsb_set_jsobject_for_proxy(jsobj, ret_val);
    jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
    args.rval().set(OBJECT_TO_JSVAL(jsobj));

    return true;
}

// Destructor
void JSB_cpPinJoint_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    if( proxy ) {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpPinJoint), handle: %p", jsthis, proxy->handle);

        jsb_del_jsobject_for_proxy(proxy->handle);
        if(proxy->flags == JSB_C_FLAG_CALL_FREE)
            cpConstraintFree( (cpConstraint*)proxy->handle);
        jsb_del_c_proxy_for_jsobject(jsthis);
    } else {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpPinJoint)", jsthis);
    }
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpPinJoint_getAnchr1(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpPinJoint* arg0 = (cpPinJoint*) proxy->handle;
    cpVect ret_val;

    ret_val = cpPinJointGetAnchr1((cpConstraint*)arg0  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpPinJoint_getAnchr2(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpPinJoint* arg0 = (cpPinJoint*) proxy->handle;
    cpVect ret_val;

    ret_val = cpPinJointGetAnchr2((cpConstraint*)arg0  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpPinJoint_getDist(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpPinJoint* arg0 = (cpPinJoint*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpPinJointGetDist((cpConstraint*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpPinJoint_setAnchr1(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpPinJoint* arg0 = (cpPinJoint*) proxy->handle;
    bool ok = true;
    cpVect arg1; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpPinJointSetAnchr1((cpConstraint*)arg0 , (cpVect)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpPinJoint_setAnchr2(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpPinJoint* arg0 = (cpPinJoint*) proxy->handle;
    bool ok = true;
    cpVect arg1; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpPinJointSetAnchr2((cpConstraint*)arg0 , (cpVect)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpPinJoint_setDist(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpPinJoint* arg0 = (cpPinJoint*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpPinJointSetDist((cpConstraint*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

void JSB_cpPinJoint_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    JSB_cpPinJoint_class = (JSClass *)calloc(1, sizeof(JSClass));
    JSB_cpPinJoint_class->name = name;
    JSB_cpPinJoint_class->addProperty = JS_PropertyStub;
    JSB_cpPinJoint_class->delProperty = JS_DeletePropertyStub;
    JSB_cpPinJoint_class->getProperty = JS_PropertyStub;
    JSB_cpPinJoint_class->setProperty = JS_StrictPropertyStub;
    JSB_cpPinJoint_class->enumerate = JS_EnumerateStub;
    JSB_cpPinJoint_class->resolve = JS_ResolveStub;
    JSB_cpPinJoint_class->convert = JS_ConvertStub;
    JSB_cpPinJoint_class->finalize = JSB_cpPinJoint_finalize;
    JSB_cpPinJoint_class->flags = JSCLASS_HAS_PRIVATE;

    static JSPropertySpec properties[] = {
        JS_PS_END
    };
    static JSFunctionSpec funcs[] = {
        JS_FN("getAnchr1", JSB_cpPinJoint_getAnchr1, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getAnchr2", JSB_cpPinJoint_getAnchr2, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getDist", JSB_cpPinJoint_getDist, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setAnchr1", JSB_cpPinJoint_setAnchr1, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setAnchr2", JSB_cpPinJoint_setAnchr2, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setDist", JSB_cpPinJoint_setDist, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FS_END
    };
    static JSFunctionSpec st_funcs[] = {
        JS_FS_END
    };
    
    JS::RootedObject constraintProto(cx, JSB_cpConstraint_object);
    JSB_cpPinJoint_object = JS_InitClass(cx, globalObj, constraintProto, JSB_cpPinJoint_class, JSB_cpPinJoint_constructor,0,properties,funcs,NULL,st_funcs);
}

/*
 * cpSlideJoint
 */
#pragma mark - cpSlideJoint

JSClass* JSB_cpSlideJoint_class = NULL;
JSObject* JSB_cpSlideJoint_object = NULL;
// Arguments: cpBody*, cpBody*, cpVect, cpVect, cpFloat, cpFloat
// Constructor
bool JSB_cpSlideJoint_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSB_PRECONDITION2(argc==6, cx, false, "Invalid number of arguments");
    JS::RootedObject slideJointProto(cx, JSB_cpSlideJoint_object);
    JS::RootedObject jsobj(cx, JS_NewObject(cx, JSB_cpSlideJoint_class, slideJointProto, JS::NullPtr()));
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    cpBody* arg0 = nullptr; cpBody* arg1 = nullptr; cpVect arg2; cpVect arg3; double arg4 = 0; double arg5 = 0; 

    ok &= jsval_to_c_class( cx, args.get(0), (void**)&arg0, NULL );
    ok &= jsval_to_c_class( cx, args.get(1), (void**)&arg1, NULL );
    ok &= jsval_to_cpVect( cx, args.get(2), (cpVect*) &arg2 );
    ok &= jsval_to_cpVect( cx, args.get(3), (cpVect*) &arg3 );
    ok &= JS::ToNumber( cx, args.get(4), &arg4 );
    ok &= JS::ToNumber( cx, args.get(5), &arg5 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    void*   ret_val = cpSlideJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpVect)arg2 , (cpVect)arg3 , (cpFloat)arg4 , (cpFloat)arg5  );

    jsb_set_jsobject_for_proxy(jsobj, ret_val);
    jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
    args.rval().set(OBJECT_TO_JSVAL(jsobj));

    return true;
}

// Destructor
void JSB_cpSlideJoint_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    if( proxy ) {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpSlideJoint), handle: %p", jsthis, proxy->handle);

        jsb_del_jsobject_for_proxy(proxy->handle);
        if(proxy->flags == JSB_C_FLAG_CALL_FREE)
            cpConstraintFree( (cpConstraint*)proxy->handle);
        jsb_del_c_proxy_for_jsobject(jsthis);
    } else {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpSlideJoint)", jsthis);
    }
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpSlideJoint_getAnchr1(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSlideJoint* arg0 = (cpSlideJoint*) proxy->handle;
    cpVect ret_val;

    ret_val = cpSlideJointGetAnchr1((cpConstraint*)arg0  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpSlideJoint_getAnchr2(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSlideJoint* arg0 = (cpSlideJoint*) proxy->handle;
    cpVect ret_val;

    ret_val = cpSlideJointGetAnchr2((cpConstraint*)arg0  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpSlideJoint_getMax(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSlideJoint* arg0 = (cpSlideJoint*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpSlideJointGetMax((cpConstraint*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpSlideJoint_getMin(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSlideJoint* arg0 = (cpSlideJoint*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpSlideJointGetMin((cpConstraint*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpSlideJoint_setAnchr1(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSlideJoint* arg0 = (cpSlideJoint*) proxy->handle;
    bool ok = true;
    cpVect arg1; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpSlideJointSetAnchr1((cpConstraint*)arg0 , (cpVect)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpSlideJoint_setAnchr2(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSlideJoint* arg0 = (cpSlideJoint*) proxy->handle;
    bool ok = true;
    cpVect arg1; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpSlideJointSetAnchr2((cpConstraint*)arg0 , (cpVect)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpSlideJoint_setMax(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSlideJoint* arg0 = (cpSlideJoint*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpSlideJointSetMax((cpConstraint*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpSlideJoint_setMin(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSlideJoint* arg0 = (cpSlideJoint*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpSlideJointSetMin((cpConstraint*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

void JSB_cpSlideJoint_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    JSB_cpSlideJoint_class = (JSClass *)calloc(1, sizeof(JSClass));
    JSB_cpSlideJoint_class->name = name;
    JSB_cpSlideJoint_class->addProperty = JS_PropertyStub;
    JSB_cpSlideJoint_class->delProperty = JS_DeletePropertyStub;
    JSB_cpSlideJoint_class->getProperty = JS_PropertyStub;
    JSB_cpSlideJoint_class->setProperty = JS_StrictPropertyStub;
    JSB_cpSlideJoint_class->enumerate = JS_EnumerateStub;
    JSB_cpSlideJoint_class->resolve = JS_ResolveStub;
    JSB_cpSlideJoint_class->convert = JS_ConvertStub;
    JSB_cpSlideJoint_class->finalize = JSB_cpSlideJoint_finalize;
    JSB_cpSlideJoint_class->flags = JSCLASS_HAS_PRIVATE;

    static JSPropertySpec properties[] = {
        JS_PS_END
    };
    static JSFunctionSpec funcs[] = {
        JS_FN("getAnchr1", JSB_cpSlideJoint_getAnchr1, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getAnchr2", JSB_cpSlideJoint_getAnchr2, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getMax", JSB_cpSlideJoint_getMax, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getMin", JSB_cpSlideJoint_getMin, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setAnchr1", JSB_cpSlideJoint_setAnchr1, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setAnchr2", JSB_cpSlideJoint_setAnchr2, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setMax", JSB_cpSlideJoint_setMax, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setMin", JSB_cpSlideJoint_setMin, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FS_END
    };
    static JSFunctionSpec st_funcs[] = {
        JS_FS_END
    };
    
    JS::RootedObject constraintProto(cx, JSB_cpConstraint_object);
    JSB_cpSlideJoint_object = JS_InitClass(cx, globalObj, constraintProto, JSB_cpSlideJoint_class, JSB_cpSlideJoint_constructor,0,properties,funcs,NULL,st_funcs);
}

/*
 * cpGearJoint
 */
#pragma mark - cpGearJoint

JSClass* JSB_cpGearJoint_class = NULL;
JSObject* JSB_cpGearJoint_object = NULL;
// Arguments: cpBody*, cpBody*, cpFloat, cpFloat
// Constructor
bool JSB_cpGearJoint_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSB_PRECONDITION2(argc==4, cx, false, "Invalid number of arguments");
    JS::RootedObject gearJointProto(cx, JSB_cpGearJoint_object);
    JS::RootedObject jsobj(cx, JS_NewObject(cx, JSB_cpGearJoint_class, gearJointProto, JS::NullPtr()));
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    cpBody* arg0 = nullptr; cpBody* arg1 = nullptr; double arg2 = 0; double arg3 = 0; 

    ok &= jsval_to_c_class( cx, args.get(0), (void**)&arg0, NULL );
    ok &= jsval_to_c_class( cx, args.get(1), (void**)&arg1, NULL );
    ok &= JS::ToNumber( cx, args.get(2), &arg2 );
    ok &= JS::ToNumber( cx, args.get(3), &arg3 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    void*   ret_val = cpGearJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpFloat)arg2 , (cpFloat)arg3  );

    jsb_set_jsobject_for_proxy(jsobj, ret_val);
    jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
    args.rval().set(OBJECT_TO_JSVAL(jsobj));

    return true;
}

// Destructor
void JSB_cpGearJoint_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    if( proxy ) {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpGearJoint), handle: %p", jsthis, proxy->handle);

        jsb_del_jsobject_for_proxy(proxy->handle);
        if(proxy->flags == JSB_C_FLAG_CALL_FREE)
            cpConstraintFree( (cpConstraint*)proxy->handle);
        jsb_del_c_proxy_for_jsobject(jsthis);
    } else {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpGearJoint)", jsthis);
    }
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpGearJoint_getPhase(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpGearJoint* arg0 = (cpGearJoint*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpGearJointGetPhase((cpConstraint*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpGearJoint_getRatio(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpGearJoint* arg0 = (cpGearJoint*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpGearJointGetRatio((cpConstraint*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpGearJoint_setPhase(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpGearJoint* arg0 = (cpGearJoint*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpGearJointSetPhase((cpConstraint*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpGearJoint_setRatio(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpGearJoint* arg0 = (cpGearJoint*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpGearJointSetRatio((cpConstraint*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

void JSB_cpGearJoint_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    JSB_cpGearJoint_class = (JSClass *)calloc(1, sizeof(JSClass));
    JSB_cpGearJoint_class->name = name;
    JSB_cpGearJoint_class->addProperty = JS_PropertyStub;
    JSB_cpGearJoint_class->delProperty = JS_DeletePropertyStub;
    JSB_cpGearJoint_class->getProperty = JS_PropertyStub;
    JSB_cpGearJoint_class->setProperty = JS_StrictPropertyStub;
    JSB_cpGearJoint_class->enumerate = JS_EnumerateStub;
    JSB_cpGearJoint_class->resolve = JS_ResolveStub;
    JSB_cpGearJoint_class->convert = JS_ConvertStub;
    JSB_cpGearJoint_class->finalize = JSB_cpGearJoint_finalize;
    JSB_cpGearJoint_class->flags = JSCLASS_HAS_PRIVATE;

    static JSPropertySpec properties[] = {
        JS_PS_END
    };
    static JSFunctionSpec funcs[] = {
        JS_FN("getPhase", JSB_cpGearJoint_getPhase, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getRatio", JSB_cpGearJoint_getRatio, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setPhase", JSB_cpGearJoint_setPhase, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setRatio", JSB_cpGearJoint_setRatio, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FS_END
    };
    static JSFunctionSpec st_funcs[] = {
        JS_FS_END
    };
    
    JS::RootedObject constraintProto(cx, JSB_cpConstraint_object);
    JSB_cpGearJoint_object = JS_InitClass(cx, globalObj, constraintProto, JSB_cpGearJoint_class, JSB_cpGearJoint_constructor,0,properties,funcs,NULL,st_funcs);
}

/*
 * cpDampedRotarySpring
 */
#pragma mark - cpDampedRotarySpring

JSClass* JSB_cpDampedRotarySpring_class = NULL;
JSObject* JSB_cpDampedRotarySpring_object = NULL;
// Arguments: cpBody*, cpBody*, cpFloat, cpFloat, cpFloat
// Constructor
bool JSB_cpDampedRotarySpring_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSB_PRECONDITION2(argc==5, cx, false, "Invalid number of arguments");
    JS::RootedObject dampedRotarySringProto(cx, JSB_cpDampedRotarySpring_object);
    JS::RootedObject jsobj(cx, JS_NewObject(cx, JSB_cpDampedRotarySpring_class, dampedRotarySringProto, JS::NullPtr()));
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    cpBody* arg0 = nullptr; cpBody* arg1 = nullptr; double arg2 = 0; double arg3 = 0; double arg4 = 0; 

    ok &= jsval_to_c_class( cx, args.get(0), (void**)&arg0, NULL );
    ok &= jsval_to_c_class( cx, args.get(1), (void**)&arg1, NULL );
    ok &= JS::ToNumber( cx, args.get(2), &arg2 );
    ok &= JS::ToNumber( cx, args.get(3), &arg3 );
    ok &= JS::ToNumber( cx, args.get(4), &arg4 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    void*   ret_val = cpDampedRotarySpringNew((cpBody*)arg0 , (cpBody*)arg1 , (cpFloat)arg2 , (cpFloat)arg3 , (cpFloat)arg4  );

    jsb_set_jsobject_for_proxy(jsobj, ret_val);
    jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
    args.rval().set(OBJECT_TO_JSVAL(jsobj));

    return true;
}

// Destructor
void JSB_cpDampedRotarySpring_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    if( proxy ) {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpDampedRotarySpring), handle: %p", jsthis, proxy->handle);

        jsb_del_jsobject_for_proxy(proxy->handle);
        if(proxy->flags == JSB_C_FLAG_CALL_FREE)
            cpConstraintFree( (cpConstraint*)proxy->handle);
        jsb_del_c_proxy_for_jsobject(jsthis);
    } else {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpDampedRotarySpring)", jsthis);
    }
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpDampedRotarySpring_getDamping(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpDampedRotarySpring* arg0 = (cpDampedRotarySpring*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpDampedRotarySpringGetDamping((cpConstraint*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpDampedRotarySpring_getRestAngle(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpDampedRotarySpring* arg0 = (cpDampedRotarySpring*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpDampedRotarySpringGetRestAngle((cpConstraint*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpDampedRotarySpring_getStiffness(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpDampedRotarySpring* arg0 = (cpDampedRotarySpring*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpDampedRotarySpringGetStiffness((cpConstraint*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpDampedRotarySpring_setDamping(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpDampedRotarySpring* arg0 = (cpDampedRotarySpring*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpDampedRotarySpringSetDamping((cpConstraint*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpDampedRotarySpring_setRestAngle(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpDampedRotarySpring* arg0 = (cpDampedRotarySpring*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpDampedRotarySpringSetRestAngle((cpConstraint*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpDampedRotarySpring_setStiffness(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpDampedRotarySpring* arg0 = (cpDampedRotarySpring*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpDampedRotarySpringSetStiffness((cpConstraint*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

void JSB_cpDampedRotarySpring_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    JSB_cpDampedRotarySpring_class = (JSClass *)calloc(1, sizeof(JSClass));
    JSB_cpDampedRotarySpring_class->name = name;
    JSB_cpDampedRotarySpring_class->addProperty = JS_PropertyStub;
    JSB_cpDampedRotarySpring_class->delProperty = JS_DeletePropertyStub;
    JSB_cpDampedRotarySpring_class->getProperty = JS_PropertyStub;
    JSB_cpDampedRotarySpring_class->setProperty = JS_StrictPropertyStub;
    JSB_cpDampedRotarySpring_class->enumerate = JS_EnumerateStub;
    JSB_cpDampedRotarySpring_class->resolve = JS_ResolveStub;
    JSB_cpDampedRotarySpring_class->convert = JS_ConvertStub;
    JSB_cpDampedRotarySpring_class->finalize = JSB_cpDampedRotarySpring_finalize;
    JSB_cpDampedRotarySpring_class->flags = JSCLASS_HAS_PRIVATE;

    static JSPropertySpec properties[] = {
        JS_PS_END
    };
    static JSFunctionSpec funcs[] = {
        JS_FN("getDamping", JSB_cpDampedRotarySpring_getDamping, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getRestAngle", JSB_cpDampedRotarySpring_getRestAngle, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getStiffness", JSB_cpDampedRotarySpring_getStiffness, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setDamping", JSB_cpDampedRotarySpring_setDamping, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setRestAngle", JSB_cpDampedRotarySpring_setRestAngle, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setStiffness", JSB_cpDampedRotarySpring_setStiffness, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FS_END
    };
    static JSFunctionSpec st_funcs[] = {
        JS_FS_END
    };
    
    JS::RootedObject constraintProto(cx, JSB_cpConstraint_object);
    JSB_cpDampedRotarySpring_object = JS_InitClass(cx, globalObj, constraintProto, JSB_cpDampedRotarySpring_class, JSB_cpDampedRotarySpring_constructor,0,properties,funcs,NULL,st_funcs);
}

/*
 * cpDampedSpring
 */
#pragma mark - cpDampedSpring

JSClass* JSB_cpDampedSpring_class = NULL;
JSObject* JSB_cpDampedSpring_object = NULL;
// Arguments: cpBody*, cpBody*, cpVect, cpVect, cpFloat, cpFloat, cpFloat
// Constructor
bool JSB_cpDampedSpring_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSB_PRECONDITION2(argc==7, cx, false, "Invalid number of arguments");
    JS::RootedObject dampedSpringProto(cx, JSB_cpDampedSpring_object);
    JS::RootedObject jsobj(cx, JS_NewObject(cx, JSB_cpDampedSpring_class, dampedSpringProto, JS::NullPtr()));
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    cpBody* arg0 = nullptr; cpBody* arg1 = nullptr; cpVect arg2; cpVect arg3; double arg4 = 0; double arg5 = 0; double arg6 = 0; 

    ok &= jsval_to_c_class( cx, args.get(0), (void**)&arg0, NULL );
    ok &= jsval_to_c_class( cx, args.get(1), (void**)&arg1, NULL );
    ok &= jsval_to_cpVect( cx, args.get(2), (cpVect*) &arg2 );
    ok &= jsval_to_cpVect( cx, args.get(3), (cpVect*) &arg3 );
    ok &= JS::ToNumber( cx, args.get(4), &arg4 );
    ok &= JS::ToNumber( cx, args.get(5), &arg5 );
    ok &= JS::ToNumber( cx, args.get(6), &arg6 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    void*   ret_val = cpDampedSpringNew((cpBody*)arg0 , (cpBody*)arg1 , (cpVect)arg2 , (cpVect)arg3 , (cpFloat)arg4 , (cpFloat)arg5 , (cpFloat)arg6  );

    jsb_set_jsobject_for_proxy(jsobj, ret_val);
    jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
    args.rval().set(OBJECT_TO_JSVAL(jsobj));

    return true;
}

// Destructor
void JSB_cpDampedSpring_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    if( proxy ) {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpDampedSpring), handle: %p", jsthis, proxy->handle);

        jsb_del_jsobject_for_proxy(proxy->handle);
        if(proxy->flags == JSB_C_FLAG_CALL_FREE)
            cpConstraintFree( (cpConstraint*)proxy->handle);
        jsb_del_c_proxy_for_jsobject(jsthis);
    } else {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpDampedSpring)", jsthis);
    }
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpDampedSpring_getAnchr1(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpDampedSpring* arg0 = (cpDampedSpring*) proxy->handle;
    cpVect ret_val;

    ret_val = cpDampedSpringGetAnchr1((cpConstraint*)arg0  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpDampedSpring_getAnchr2(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpDampedSpring* arg0 = (cpDampedSpring*) proxy->handle;
    cpVect ret_val;

    ret_val = cpDampedSpringGetAnchr2((cpConstraint*)arg0  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpDampedSpring_getDamping(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpDampedSpring* arg0 = (cpDampedSpring*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpDampedSpringGetDamping((cpConstraint*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpDampedSpring_getRestLength(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpDampedSpring* arg0 = (cpDampedSpring*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpDampedSpringGetRestLength((cpConstraint*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpDampedSpring_getStiffness(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpDampedSpring* arg0 = (cpDampedSpring*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpDampedSpringGetStiffness((cpConstraint*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpDampedSpring_setAnchr1(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpDampedSpring* arg0 = (cpDampedSpring*) proxy->handle;
    bool ok = true;
    cpVect arg1; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpDampedSpringSetAnchr1((cpConstraint*)arg0 , (cpVect)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpDampedSpring_setAnchr2(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpDampedSpring* arg0 = (cpDampedSpring*) proxy->handle;
    bool ok = true;
    cpVect arg1; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpDampedSpringSetAnchr2((cpConstraint*)arg0 , (cpVect)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpDampedSpring_setDamping(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpDampedSpring* arg0 = (cpDampedSpring*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpDampedSpringSetDamping((cpConstraint*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpDampedSpring_setRestLength(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpDampedSpring* arg0 = (cpDampedSpring*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpDampedSpringSetRestLength((cpConstraint*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpDampedSpring_setStiffness(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpDampedSpring* arg0 = (cpDampedSpring*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpDampedSpringSetStiffness((cpConstraint*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

void JSB_cpDampedSpring_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    JSB_cpDampedSpring_class = (JSClass *)calloc(1, sizeof(JSClass));
    JSB_cpDampedSpring_class->name = name;
    JSB_cpDampedSpring_class->addProperty = JS_PropertyStub;
    JSB_cpDampedSpring_class->delProperty = JS_DeletePropertyStub;
    JSB_cpDampedSpring_class->getProperty = JS_PropertyStub;
    JSB_cpDampedSpring_class->setProperty = JS_StrictPropertyStub;
    JSB_cpDampedSpring_class->enumerate = JS_EnumerateStub;
    JSB_cpDampedSpring_class->resolve = JS_ResolveStub;
    JSB_cpDampedSpring_class->convert = JS_ConvertStub;
    JSB_cpDampedSpring_class->finalize = JSB_cpDampedSpring_finalize;
    JSB_cpDampedSpring_class->flags = JSCLASS_HAS_PRIVATE;

    static JSPropertySpec properties[] = {
        JS_PS_END
    };
    static JSFunctionSpec funcs[] = {
        JS_FN("getAnchr1", JSB_cpDampedSpring_getAnchr1, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getAnchr2", JSB_cpDampedSpring_getAnchr2, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getDamping", JSB_cpDampedSpring_getDamping, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getRestLength", JSB_cpDampedSpring_getRestLength, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getStiffness", JSB_cpDampedSpring_getStiffness, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setAnchr1", JSB_cpDampedSpring_setAnchr1, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setAnchr2", JSB_cpDampedSpring_setAnchr2, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setDamping", JSB_cpDampedSpring_setDamping, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setRestLength", JSB_cpDampedSpring_setRestLength, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setStiffness", JSB_cpDampedSpring_setStiffness, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FS_END
    };
    static JSFunctionSpec st_funcs[] = {
        JS_FS_END
    };
    
    JS::RootedObject constraintProto(cx, JSB_cpConstraint_object);
    JSB_cpDampedSpring_object = JS_InitClass(cx, globalObj, constraintProto, JSB_cpDampedSpring_class, JSB_cpDampedSpring_constructor,0,properties,funcs,NULL,st_funcs);
}

/*
 * cpRatchetJoint
 */
#pragma mark - cpRatchetJoint

JSClass* JSB_cpRatchetJoint_class = NULL;
JSObject* JSB_cpRatchetJoint_object = NULL;
// Arguments: cpBody*, cpBody*, cpFloat, cpFloat
// Constructor
bool JSB_cpRatchetJoint_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSB_PRECONDITION2(argc==4, cx, false, "Invalid number of arguments");
    JS::RootedObject ratchetJointProto(cx, JSB_cpRatchetJoint_object);
    JS::RootedObject jsobj(cx, JS_NewObject(cx, JSB_cpRatchetJoint_class, ratchetJointProto, JS::NullPtr()));
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    cpBody* arg0 = nullptr; cpBody* arg1 = nullptr; double arg2 = 0; double arg3 = 0; 

    ok &= jsval_to_c_class( cx, args.get(0), (void**)&arg0, NULL );
    ok &= jsval_to_c_class( cx, args.get(1), (void**)&arg1, NULL );
    ok &= JS::ToNumber( cx, args.get(2), &arg2 );
    ok &= JS::ToNumber( cx, args.get(3), &arg3 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    void*   ret_val = cpRatchetJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpFloat)arg2 , (cpFloat)arg3  );

    jsb_set_jsobject_for_proxy(jsobj, ret_val);
    jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
    args.rval().set(OBJECT_TO_JSVAL(jsobj));

    return true;
}

// Destructor
void JSB_cpRatchetJoint_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    if( proxy ) {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpRatchetJoint), handle: %p", jsthis, proxy->handle);

        jsb_del_jsobject_for_proxy(proxy->handle);
        if(proxy->flags == JSB_C_FLAG_CALL_FREE)
            cpConstraintFree( (cpConstraint*)proxy->handle);
        jsb_del_c_proxy_for_jsobject(jsthis);
    } else {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpRatchetJoint)", jsthis);
    }
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpRatchetJoint_getAngle(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpRatchetJoint* arg0 = (cpRatchetJoint*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpRatchetJointGetAngle((cpConstraint*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpRatchetJoint_getPhase(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpRatchetJoint* arg0 = (cpRatchetJoint*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpRatchetJointGetPhase((cpConstraint*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpRatchetJoint_getRatchet(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpRatchetJoint* arg0 = (cpRatchetJoint*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpRatchetJointGetRatchet((cpConstraint*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpRatchetJoint_setAngle(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpRatchetJoint* arg0 = (cpRatchetJoint*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpRatchetJointSetAngle((cpConstraint*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpRatchetJoint_setPhase(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpRatchetJoint* arg0 = (cpRatchetJoint*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpRatchetJointSetPhase((cpConstraint*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpRatchetJoint_setRatchet(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpRatchetJoint* arg0 = (cpRatchetJoint*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpRatchetJointSetRatchet((cpConstraint*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

void JSB_cpRatchetJoint_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    JSB_cpRatchetJoint_class = (JSClass *)calloc(1, sizeof(JSClass));
    JSB_cpRatchetJoint_class->name = name;
    JSB_cpRatchetJoint_class->addProperty = JS_PropertyStub;
    JSB_cpRatchetJoint_class->delProperty = JS_DeletePropertyStub;
    JSB_cpRatchetJoint_class->getProperty = JS_PropertyStub;
    JSB_cpRatchetJoint_class->setProperty = JS_StrictPropertyStub;
    JSB_cpRatchetJoint_class->enumerate = JS_EnumerateStub;
    JSB_cpRatchetJoint_class->resolve = JS_ResolveStub;
    JSB_cpRatchetJoint_class->convert = JS_ConvertStub;
    JSB_cpRatchetJoint_class->finalize = JSB_cpRatchetJoint_finalize;
    JSB_cpRatchetJoint_class->flags = JSCLASS_HAS_PRIVATE;

    static JSPropertySpec properties[] = {
        JS_PS_END
    };
    static JSFunctionSpec funcs[] = {
        JS_FN("getAngle", JSB_cpRatchetJoint_getAngle, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getPhase", JSB_cpRatchetJoint_getPhase, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getRatchet", JSB_cpRatchetJoint_getRatchet, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setAngle", JSB_cpRatchetJoint_setAngle, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setPhase", JSB_cpRatchetJoint_setPhase, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setRatchet", JSB_cpRatchetJoint_setRatchet, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FS_END
    };
    static JSFunctionSpec st_funcs[] = {
        JS_FS_END
    };
    
    JS::RootedObject constraintProto(cx, JSB_cpConstraint_object);
    JSB_cpRatchetJoint_object = JS_InitClass(cx, globalObj, constraintProto, JSB_cpRatchetJoint_class, JSB_cpRatchetJoint_constructor,0,properties,funcs,NULL,st_funcs);
}

/*
 * cpRotaryLimitJoint
 */
#pragma mark - cpRotaryLimitJoint

JSClass* JSB_cpRotaryLimitJoint_class = NULL;
JSObject* JSB_cpRotaryLimitJoint_object = NULL;
// Arguments: cpBody*, cpBody*, cpFloat, cpFloat
// Constructor
bool JSB_cpRotaryLimitJoint_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSB_PRECONDITION2(argc==4, cx, false, "Invalid number of arguments");
    JS::RootedObject rotaryLimitJointProto(cx, JSB_cpRotaryLimitJoint_object);
    JS::RootedObject jsobj(cx, JS_NewObject(cx, JSB_cpRotaryLimitJoint_class, rotaryLimitJointProto, JS::NullPtr()));
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    cpBody* arg0 = nullptr; cpBody* arg1 = nullptr; double arg2 = 0; double arg3 = 0; 

    ok &= jsval_to_c_class( cx, args.get(0), (void**)&arg0, NULL );
    ok &= jsval_to_c_class( cx, args.get(1), (void**)&arg1, NULL );
    ok &= JS::ToNumber( cx, args.get(2), &arg2 );
    ok &= JS::ToNumber( cx, args.get(3), &arg3 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    void*   ret_val = cpRotaryLimitJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpFloat)arg2 , (cpFloat)arg3  );

    jsb_set_jsobject_for_proxy(jsobj, ret_val);
    jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
    args.rval().set(OBJECT_TO_JSVAL(jsobj));

    return true;
}

// Destructor
void JSB_cpRotaryLimitJoint_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    if( proxy ) {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpRotaryLimitJoint), handle: %p", jsthis, proxy->handle);

        jsb_del_jsobject_for_proxy(proxy->handle);
        if(proxy->flags == JSB_C_FLAG_CALL_FREE)
            cpConstraintFree( (cpConstraint*)proxy->handle);
        jsb_del_c_proxy_for_jsobject(jsthis);
    } else {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpRotaryLimitJoint)", jsthis);
    }
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpRotaryLimitJoint_getMax(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpRotaryLimitJoint* arg0 = (cpRotaryLimitJoint*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpRotaryLimitJointGetMax((cpConstraint*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpRotaryLimitJoint_getMin(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpRotaryLimitJoint* arg0 = (cpRotaryLimitJoint*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpRotaryLimitJointGetMin((cpConstraint*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpRotaryLimitJoint_setMax(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpRotaryLimitJoint* arg0 = (cpRotaryLimitJoint*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpRotaryLimitJointSetMax((cpConstraint*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpRotaryLimitJoint_setMin(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpRotaryLimitJoint* arg0 = (cpRotaryLimitJoint*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpRotaryLimitJointSetMin((cpConstraint*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

void JSB_cpRotaryLimitJoint_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    JSB_cpRotaryLimitJoint_class = (JSClass *)calloc(1, sizeof(JSClass));
    JSB_cpRotaryLimitJoint_class->name = name;
    JSB_cpRotaryLimitJoint_class->addProperty = JS_PropertyStub;
    JSB_cpRotaryLimitJoint_class->delProperty = JS_DeletePropertyStub;
    JSB_cpRotaryLimitJoint_class->getProperty = JS_PropertyStub;
    JSB_cpRotaryLimitJoint_class->setProperty = JS_StrictPropertyStub;
    JSB_cpRotaryLimitJoint_class->enumerate = JS_EnumerateStub;
    JSB_cpRotaryLimitJoint_class->resolve = JS_ResolveStub;
    JSB_cpRotaryLimitJoint_class->convert = JS_ConvertStub;
    JSB_cpRotaryLimitJoint_class->finalize = JSB_cpRotaryLimitJoint_finalize;
    JSB_cpRotaryLimitJoint_class->flags = JSCLASS_HAS_PRIVATE;

    static JSPropertySpec properties[] = {
        JS_PS_END
    };
    static JSFunctionSpec funcs[] = {
        JS_FN("getMax", JSB_cpRotaryLimitJoint_getMax, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getMin", JSB_cpRotaryLimitJoint_getMin, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setMax", JSB_cpRotaryLimitJoint_setMax, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setMin", JSB_cpRotaryLimitJoint_setMin, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FS_END
    };
    static JSFunctionSpec st_funcs[] = {
        JS_FS_END
    };
    
    JS::RootedObject constraintProto(cx, JSB_cpConstraint_object);
    JSB_cpRotaryLimitJoint_object = JS_InitClass(cx, globalObj, constraintProto, JSB_cpRotaryLimitJoint_class, JSB_cpRotaryLimitJoint_constructor,0,properties,funcs,NULL,st_funcs);
}

/*
 * cpArbiter
 */
#pragma mark - cpArbiter

JSClass* JSB_cpArbiter_class = NULL;
JSObject* JSB_cpArbiter_object = NULL;

// Constructor
bool JSB_cpArbiter_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSB_PRECONDITION2(argc==0, cx, false, "Invalid number of arguments");
    JSB_PRECONDITION2(false, cx, true, "No constructor");

    return true;
}

// Destructor
void JSB_cpArbiter_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    if( proxy ) {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpArbiter), handle: %p", jsthis, proxy->handle);

        jsb_del_jsobject_for_proxy(proxy->handle);
        if(proxy->flags == JSB_C_FLAG_CALL_FREE)
            // No destructor found: ( (None*)proxy->handle);
        jsb_del_c_proxy_for_jsobject(jsthis);
    } else {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpArbiter)", jsthis);
    }
}

// Arguments: 
// Ret value: int
bool JSB_cpArbiter_getCount(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpArbiter* arg0 = (cpArbiter*) proxy->handle;
    int ret_val = 0;

    ret_val = cpArbiterGetCount((cpArbiter*)arg0  );
    args.rval().set(INT_TO_JSVAL((int32_t)ret_val));
    return true;
}

// Arguments: int
// Ret value: cpFloat
bool JSB_cpArbiter_getDepth(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpArbiter* arg0 = (cpArbiter*) proxy->handle;
    bool ok = true;
    int32_t arg1 = 0; 

    ok &= jsval_to_int32( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    cpFloat ret_val = 0;

    ret_val = cpArbiterGetDepth((cpArbiter*)arg0 , (int)arg1  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpArbiter_getElasticity(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpArbiter* arg0 = (cpArbiter*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpArbiterGetElasticity((cpArbiter*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpArbiter_getFriction(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpArbiter* arg0 = (cpArbiter*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpArbiterGetFriction((cpArbiter*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: int
// Ret value: cpVect
bool JSB_cpArbiter_getNormal(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpArbiter* arg0 = (cpArbiter*) proxy->handle;
    bool ok = true;
    int32_t arg1 = 0; 

    ok &= jsval_to_int32( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    cpVect ret_val;

    ret_val = cpArbiterGetNormal((cpArbiter*)arg0 , (int)arg1  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: int
// Ret value: cpVect
bool JSB_cpArbiter_getPoint(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpArbiter* arg0 = (cpArbiter*) proxy->handle;
    bool ok = true;
    int32_t arg1 = 0; 

    ok &= jsval_to_int32( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    cpVect ret_val;

    ret_val = cpArbiterGetPoint((cpArbiter*)arg0 , (int)arg1  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpArbiter_getSurfaceVelocity(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpArbiter* arg0 = (cpArbiter*) proxy->handle;
    cpVect ret_val;

    ret_val = cpArbiterGetSurfaceVelocity((cpArbiter*)arg0  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: void
bool JSB_cpArbiter_ignore(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpArbiter* arg0 = (cpArbiter*) proxy->handle;

    cpArbiterIgnore((cpArbiter*)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: 
// Ret value: cpBool
bool JSB_cpArbiter_isFirstContact(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpArbiter* arg0 = (cpArbiter*) proxy->handle;
    cpBool ret_val;

    ret_val = cpArbiterIsFirstContact((cpArbiter*)arg0  );
    args.rval().set(INT_TO_JSVAL((int32_t)ret_val));
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpArbiter_setElasticity(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpArbiter* arg0 = (cpArbiter*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpArbiterSetElasticity((cpArbiter*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpArbiter_setFriction(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpArbiter* arg0 = (cpArbiter*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpArbiterSetFriction((cpArbiter*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpArbiter_setSurfaceVelocity(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpArbiter* arg0 = (cpArbiter*) proxy->handle;
    bool ok = true;
    cpVect arg1; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpArbiterSetSurfaceVelocity((cpArbiter*)arg0 , (cpVect)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpArbiter_totalImpulse(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpArbiter* arg0 = (cpArbiter*) proxy->handle;
    cpVect ret_val;

    ret_val = cpArbiterTotalImpulse((cpArbiter*)arg0  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpArbiter_totalImpulseWithFriction(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpArbiter* arg0 = (cpArbiter*) proxy->handle;
    cpVect ret_val;

    ret_val = cpArbiterTotalImpulseWithFriction((cpArbiter*)arg0  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpArbiter_totalKE(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpArbiter* arg0 = (cpArbiter*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpArbiterTotalKE((cpArbiter*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

bool js_get_cpArbiter_a(JSContext *cx, uint32_t argc, jsval *vp) {
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpArbiter* arbiter = (cpArbiter*) proxy->handle;
    cpShape* shape = arbiter->a;
    if(shape){
        JSObject* jsobj = jsb_get_jsobject_for_proxy(shape);
        if(jsobj){
            args.rval().set(OBJECT_TO_JSVAL(jsobj));
            return true;
        }
    }
    return false;
}

bool js_get_cpArbiter_b(JSContext *cx, uint32_t argc, jsval *vp) {
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpArbiter* arbiter = (cpArbiter*) proxy->handle;
    cpShape* shape = arbiter->b;
    if(shape){
        JSObject* jsobj = jsb_get_jsobject_for_proxy(shape);
        if(jsobj){
            args.rval().set(OBJECT_TO_JSVAL(jsobj));
            return true;
        }
    }
    return false;
}

bool js_get_cpArbiter_body_a(JSContext *cx, uint32_t argc, jsval *vp) {
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpArbiter* arbiter = (cpArbiter*) proxy->handle;
    cpBody* body = arbiter->body_a;
    if(body){
        JSObject* jsobj = jsb_get_jsobject_for_proxy(body);
        if(jsobj){
            args.rval().set(OBJECT_TO_JSVAL(jsobj));
            return true;
        }
    }
    return false;
}

bool js_get_cpArbiter_body_b(JSContext *cx, uint32_t argc, jsval *vp) {
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpArbiter* arbiter = (cpArbiter*) proxy->handle;
    cpBody* body = arbiter->body_b;
    if(body){
        JSObject* jsobj = jsb_get_jsobject_for_proxy(body);
        if(jsobj){
            args.rval().set(OBJECT_TO_JSVAL(jsobj));
            return true;
        }
    }
    return false;
}

void JSB_cpArbiter_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    JSB_cpArbiter_class = (JSClass *)calloc(1, sizeof(JSClass));
    JSB_cpArbiter_class->name = name;
    JSB_cpArbiter_class->addProperty = JS_PropertyStub;
    JSB_cpArbiter_class->delProperty = JS_DeletePropertyStub;
    JSB_cpArbiter_class->getProperty = JS_PropertyStub;
    JSB_cpArbiter_class->setProperty = JS_StrictPropertyStub;
    JSB_cpArbiter_class->enumerate = JS_EnumerateStub;
    JSB_cpArbiter_class->resolve = JS_ResolveStub;
    JSB_cpArbiter_class->convert = JS_ConvertStub;
    JSB_cpArbiter_class->finalize = JSB_cpArbiter_finalize;
    JSB_cpArbiter_class->flags = JSCLASS_HAS_PRIVATE;

    static JSPropertySpec properties[] = {
        JS_PSG("a", js_get_cpArbiter_a, JSPROP_ENUMERATE | JSPROP_PERMANENT),
        JS_PSG("b", js_get_cpArbiter_b, JSPROP_ENUMERATE | JSPROP_PERMANENT),
        JS_PSG("body_a", js_get_cpArbiter_body_a, JSPROP_ENUMERATE | JSPROP_PERMANENT),
        JS_PSG("body_b", js_get_cpArbiter_body_b, JSPROP_ENUMERATE | JSPROP_PERMANENT),
        JS_PS_END
    };
    static JSFunctionSpec funcs[] = {
        JS_FN("getCount", JSB_cpArbiter_getCount, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getDepth", JSB_cpArbiter_getDepth, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getElasticity", JSB_cpArbiter_getElasticity, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getFriction", JSB_cpArbiter_getFriction, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getNormal", JSB_cpArbiter_getNormal, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getPoint", JSB_cpArbiter_getPoint, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getSurfaceVelocity", JSB_cpArbiter_getSurfaceVelocity, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("ignore", JSB_cpArbiter_ignore, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("isFirstContact", JSB_cpArbiter_isFirstContact, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setElasticity", JSB_cpArbiter_setElasticity, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setFriction", JSB_cpArbiter_setFriction, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setSurfaceVelocity", JSB_cpArbiter_setSurfaceVelocity, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("totalImpulse", JSB_cpArbiter_totalImpulse, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("totalImpulseWithFriction", JSB_cpArbiter_totalImpulseWithFriction, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("totalKE", JSB_cpArbiter_totalKE, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getShapes", JSB_cpArbiter_getShapes, 2, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getBodies", JSB_cpArbiter_getBodies, 2, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FS_END
    };
    static JSFunctionSpec st_funcs[] = {
        JS_FS_END
    };

    JS::RootedObject baseProto(cx, JSB_cpBase_object);
    JSB_cpArbiter_object = JS_InitClass(cx, globalObj, baseProto, JSB_cpArbiter_class, JSB_cpArbiter_constructor,0,properties,funcs,NULL,st_funcs);
}

/*
 * cpSpace
 */
#pragma mark - cpSpace

JSClass* JSB_cpSpace_class = NULL;
JSObject* JSB_cpSpace_object = NULL;
// Arguments: 
// Constructor
bool JSB_cpSpace_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSB_PRECONDITION2(argc==0, cx, false, "Invalid number of arguments");
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject spaceProto(cx, JSB_cpSpace_object);
    JS::RootedObject jsobj(cx, JS_NewObject(cx, JSB_cpSpace_class, spaceProto, JS::NullPtr()));
    void*   ret_val = cpSpaceNew( );

    jsb_set_jsobject_for_proxy(jsobj, ret_val);
    jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
    args.rval().set(OBJECT_TO_JSVAL(jsobj));

    return true;
}

// Arguments: cpShape*
// Ret value: void
bool JSB_cpSpace_activateShapesTouchingShape(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    bool ok = true;
    cpShape* arg1 = nullptr; 

    ok &= jsval_to_c_class( cx, args.get(0), (void**)&arg1, NULL );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpSpaceActivateShapesTouchingShape((cpSpace*)arg0 , (cpShape*)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpBody*
// Ret value: cpBool
bool JSB_cpSpace_containsBody(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    bool ok = true;
    cpBody* arg1 = nullptr; 

    ok &= jsval_to_c_class( cx, args.get(0), (void**)&arg1, NULL );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    cpBool ret_val;

    ret_val = cpSpaceContainsBody((cpSpace*)arg0 , (cpBody*)arg1  );
    args.rval().set(INT_TO_JSVAL((int32_t)ret_val));
    return true;
}

// Arguments: cpConstraint*
// Ret value: cpBool
bool JSB_cpSpace_containsConstraint(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    bool ok = true;
    cpConstraint* arg1 = nullptr; 

    ok &= jsval_to_c_class( cx, args.get(0), (void**)&arg1, NULL );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    cpBool ret_val;

    ret_val = cpSpaceContainsConstraint((cpSpace*)arg0 , (cpConstraint*)arg1  );
    args.rval().set(INT_TO_JSVAL((int32_t)ret_val));
    return true;
}

// Arguments: cpShape*
// Ret value: cpBool
bool JSB_cpSpace_containsShape(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    bool ok = true;
    cpShape* arg1 = nullptr; 

    ok &= jsval_to_c_class( cx, args.get(0), (void**)&arg1, NULL );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    cpBool ret_val;

    ret_val = cpSpaceContainsShape((cpSpace*)arg0 , (cpShape*)arg1  );
    args.rval().set(INT_TO_JSVAL((int32_t)ret_val));
    return true;
}

// Arguments: 
// Ret value: void
bool JSB_cpSpace_destroy(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;

    cpSpaceDestroy((cpSpace*)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpSpace_getCollisionBias(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpSpaceGetCollisionBias((cpSpace*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpTimestamp
bool JSB_cpSpace_getCollisionPersistence(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    cpTimestamp ret_val = 0;

    ret_val = cpSpaceGetCollisionPersistence((cpSpace*)arg0  );
    args.rval().set(UINT_TO_JSVAL((uint32_t)ret_val));
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpSpace_getCollisionSlop(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpSpaceGetCollisionSlop((cpSpace*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpSpace_getCurrentTimeStep(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpSpaceGetCurrentTimeStep((cpSpace*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpSpace_getDamping(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpSpaceGetDamping((cpSpace*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpBool
bool JSB_cpSpace_getEnableContactGraph(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    cpBool ret_val;

    ret_val = cpSpaceGetEnableContactGraph((cpSpace*)arg0  );
    args.rval().set(INT_TO_JSVAL((int32_t)ret_val));
    return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpSpace_getGravity(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    cpVect ret_val;

    ret_val = cpSpaceGetGravity((cpSpace*)arg0  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpSpace_getIdleSpeedThreshold(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpSpaceGetIdleSpeedThreshold((cpSpace*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: int
bool JSB_cpSpace_getIterations(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    int ret_val = 0;

    ret_val = cpSpaceGetIterations((cpSpace*)arg0  );
    args.rval().set(INT_TO_JSVAL((int32_t)ret_val));
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpSpace_getSleepTimeThreshold(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpSpaceGetSleepTimeThreshold((cpSpace*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpBody*
bool JSB_cpSpace_getStaticBody(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    cpBody* ret_val = nullptr;

    ret_val = cpSpaceGetStaticBody((cpSpace*)arg0  );
    
    JS::RootedObject bodyProto(cx, JSB_cpBody_object);
    jsval ret_jsval = c_class_to_jsval( cx, ret_val, bodyProto, JSB_cpBody_class, "cpBody" );
    args.rval().set(ret_jsval);
    
    return true;
}

// Arguments: 
// Ret value: cpSpace*
bool JSB_cpSpace_init(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    cpSpace* ret_val = nullptr;

    ret_val = cpSpaceInit((cpSpace*)arg0  );
    
    JS::RootedObject spaceProto(cx, JSB_cpSpace_object);
    jsval ret_jsval = c_class_to_jsval( cx, ret_val, spaceProto, JSB_cpSpace_class, "cpSpace" );
    args.rval().set(ret_jsval);
    
    return true;
}

// Arguments: 
// Ret value: cpBool
bool JSB_cpSpace_isLocked(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    cpBool ret_val;

    ret_val = cpSpaceIsLocked((cpSpace*)arg0  );
    args.rval().set(INT_TO_JSVAL((int32_t)ret_val));
    return true;
}

// Arguments: cpVect, cpLayers, cpGroup
// Ret value: cpShape*
bool JSB_cpSpace_pointQueryFirst(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 3, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    bool ok = true;
    cpVect arg1; uint32_t arg2 = 0; cpGroup arg3 = 0;

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    ok &= jsval_to_uint32( cx, args.get(1), &arg2 );
    ok &= jsval_to_uint( cx, args.get(2), (unsigned int*) &arg3 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    cpShape* ret_val = nullptr;

    ret_val = cpSpacePointQueryFirst((cpSpace*)arg0 , (cpVect)arg1 , (cpLayers)arg2 , (cpGroup)arg3  );

    if(ret_val) {
        JS::RootedObject shapeProto(cx, JSB_cpShape_object);
        jsval ret_jsval = c_class_to_jsval( cx, ret_val, shapeProto, JSB_cpShape_class, "cpShape" );
        args.rval().set(ret_jsval);
    } else {
        args.rval().set(JSVAL_NULL);
    }
    return true;
}
// Arguments: cpShape*
// Ret value: void
bool JSB_cpSpace_reindexShape(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    bool ok = true;
    cpShape* arg1 = nullptr; 

    ok &= jsval_to_c_class( cx, args.get(0), (void**)&arg1, NULL );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpSpaceReindexShape((cpSpace*)arg0 , (cpShape*)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpBody*
// Ret value: void
bool JSB_cpSpace_reindexShapesForBody(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    bool ok = true;
    cpBody* arg1 = nullptr; 

    ok &= jsval_to_c_class( cx, args.get(0), (void**)&arg1, NULL );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpSpaceReindexShapesForBody((cpSpace*)arg0 , (cpBody*)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: 
// Ret value: void
bool JSB_cpSpace_reindexStatic(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;

    cpSpaceReindexStatic((cpSpace*)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpSpace_setCollisionBias(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpSpaceSetCollisionBias((cpSpace*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpTimestamp
// Ret value: void
bool JSB_cpSpace_setCollisionPersistence(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    bool ok = true;
    uint32_t arg1 = 0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpSpaceSetCollisionPersistence((cpSpace*)arg0 , (cpTimestamp)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpSpace_setCollisionSlop(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpSpaceSetCollisionSlop((cpSpace*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpSpace_setDamping(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpSpaceSetDamping((cpSpace*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpBool
// Ret value: void
bool JSB_cpSpace_setEnableContactGraph(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    bool ok = true;
    int32_t arg1 = 0; 

    ok &= jsval_to_int32( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpSpaceSetEnableContactGraph((cpSpace*)arg0 , (cpBool)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpSpace_setGravity(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    bool ok = true;
    cpVect arg1; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpSpaceSetGravity((cpSpace*)arg0 , (cpVect)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpSpace_setIdleSpeedThreshold(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpSpaceSetIdleSpeedThreshold((cpSpace*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: int
// Ret value: void
bool JSB_cpSpace_setIterations(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    bool ok = true;
    int32_t arg1 = 0; 

    ok &= jsval_to_int32( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpSpaceSetIterations((cpSpace*)arg0 , (int)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpSpace_setSleepTimeThreshold(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpSpaceSetSleepTimeThreshold((cpSpace*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpSpace_step(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpSpaceStep((cpSpace*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat, int
// Ret value: void
bool JSB_cpSpace_useSpatialHash(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSpace* arg0 = (cpSpace*) proxy->handle;
    bool ok = true;
    double arg1 = 0; int32_t arg2 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    ok &= jsval_to_int32( cx, args.get(1), &arg2 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpSpaceUseSpatialHash((cpSpace*)arg0 , (cpFloat)arg1 , (int)arg2  );
    args.rval().setUndefined();
    return true;
}


void JSB_cpSpace_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    JSB_cpSpace_class = (JSClass *)calloc(1, sizeof(JSClass));
    JSB_cpSpace_class->name = name;
    JSB_cpSpace_class->addProperty = JS_PropertyStub;
    JSB_cpSpace_class->delProperty = JS_DeletePropertyStub;
    JSB_cpSpace_class->getProperty = JS_PropertyStub;
    JSB_cpSpace_class->setProperty = JS_StrictPropertyStub;
    JSB_cpSpace_class->enumerate = JS_EnumerateStub;
    JSB_cpSpace_class->resolve = JS_ResolveStub;
    JSB_cpSpace_class->convert = JS_ConvertStub;
    JSB_cpSpace_class->finalize = JSB_cpSpace_finalize;
    JSB_cpSpace_class->flags = JSCLASS_HAS_PRIVATE;

    static JSPropertySpec properties[] = {
        { 0, 0, 0, 0, 0 }
    };
    static JSFunctionSpec funcs[] = {
        JS_FN("activateShapesTouchingShape", JSB_cpSpace_activateShapesTouchingShape, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("containsBody", JSB_cpSpace_containsBody, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("containsConstraint", JSB_cpSpace_containsConstraint, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("containsShape", JSB_cpSpace_containsShape, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("destroy", JSB_cpSpace_destroy, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("getCollisionBias", JSB_cpSpace_getCollisionBias, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("getCollisionPersistence", JSB_cpSpace_getCollisionPersistence, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("getCollisionSlop", JSB_cpSpace_getCollisionSlop, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("getCurrentTimeStep", JSB_cpSpace_getCurrentTimeStep, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("getDamping", JSB_cpSpace_getDamping, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("getEnableContactGraph", JSB_cpSpace_getEnableContactGraph, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("getGravity", JSB_cpSpace_getGravity, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("getIdleSpeedThreshold", JSB_cpSpace_getIdleSpeedThreshold, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("getIterations", JSB_cpSpace_getIterations, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("getSleepTimeThreshold", JSB_cpSpace_getSleepTimeThreshold, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("getStaticBody", JSB_cpSpace_getStaticBody, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("init", JSB_cpSpace_init, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("isLocked", JSB_cpSpace_isLocked, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("pointQueryFirst", JSB_cpSpace_pointQueryFirst, 3, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("reindexShape", JSB_cpSpace_reindexShape, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("reindexShapesForBody", JSB_cpSpace_reindexShapesForBody, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("reindexStatic", JSB_cpSpace_reindexStatic, 0, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("setCollisionBias", JSB_cpSpace_setCollisionBias, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("setCollisionPersistence", JSB_cpSpace_setCollisionPersistence, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("setCollisionSlop", JSB_cpSpace_setCollisionSlop, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("setDamping", JSB_cpSpace_setDamping, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("setEnableContactGraph", JSB_cpSpace_setEnableContactGraph, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("setGravity", JSB_cpSpace_setGravity, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("setIdleSpeedThreshold", JSB_cpSpace_setIdleSpeedThreshold, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("setIterations", JSB_cpSpace_setIterations, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("setSleepTimeThreshold", JSB_cpSpace_setSleepTimeThreshold, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("step", JSB_cpSpace_step, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("useSpatialHash", JSB_cpSpace_useSpatialHash, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("addShape", JSB_cpSpace_addShape, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("addCollisionHandler", JSB_cpSpace_addCollisionHandler, 6, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("setDefaultCollisionHandler", JSB_cpSpace_setDefaultCollisionHandler, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("addStaticShape", JSB_cpSpace_addStaticShape, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("removeConstraint", JSB_cpSpace_removeConstraint, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("removeBody", JSB_cpSpace_removeBody, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("removeCollisionHandler", JSB_cpSpace_removeCollisionHandler, 2, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("removeStaticShape", JSB_cpSpace_removeStaticShape, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("addConstraint", JSB_cpSpace_addConstraint, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("addBody", JSB_cpSpace_addBody, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("removeShape", JSB_cpSpace_removeShape, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("pointQuery", JSB_cpSpace_pointQuery, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("nearestPointQuery", JSB_cpSpace_nearestPointQuery, 5, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("segmentQuery", JSB_cpSpace_segmentQuery, 5, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("bbQuery", JSB_cpSpace_bbQuery, 4, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FN("addPostStepCallback", JSB_cpSpace_addPostStepCallback, 1, JSPROP_PERMANENT | JSPROP_ENUMERATE),
        JS_FS_END
    };
    static JSFunctionSpec st_funcs[] = {
        JS_FS_END
    };
    
    JS::RootedObject baseProto(cx, JSB_cpBase_object);
    JSB_cpSpace_object = JS_InitClass(cx, globalObj, baseProto, JSB_cpSpace_class, JSB_cpSpace_constructor,0,properties,funcs,NULL,st_funcs);
}

/*
 * cpBody
 */
#pragma mark - cpBody

JSClass* JSB_cpBody_class = NULL;
JSObject* JSB_cpBody_object = NULL;

// Destructor
void JSB_cpBody_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    if( proxy ) {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpBody), handle: %p", jsthis, proxy->handle);

        jsb_del_jsobject_for_proxy(proxy->handle);
        if(proxy->flags == JSB_C_FLAG_CALL_FREE)
            cpBodyFree( (cpBody*)proxy->handle);
        jsb_del_c_proxy_for_jsobject(jsthis);
    } else {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpBody)", jsthis);
    }
}

// Arguments: 
// Ret value: void
bool JSB_cpBody_activate(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;

    cpBodyActivate((cpBody*)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpShape*
// Ret value: void
bool JSB_cpBody_activateStatic(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    bool ok = true;
    cpShape* arg1 = nullptr; 

    ok &= jsval_to_c_class( cx, args.get(0), (void**)&arg1, NULL );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpBodyActivateStatic((cpBody*)arg0 , (cpShape*)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpVect, cpVect
// Ret value: void
bool JSB_cpBody_applyForce(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    bool ok = true;
    cpVect arg1; cpVect arg2; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    ok &= jsval_to_cpVect( cx, args.get(1), (cpVect*) &arg2 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpBodyApplyForce((cpBody*)arg0 , (cpVect)arg1 , (cpVect)arg2  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpVect, cpVect
// Ret value: void
bool JSB_cpBody_applyImpulse(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    bool ok = true;
    cpVect arg1; cpVect arg2; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    ok &= jsval_to_cpVect( cx, args.get(1), (cpVect*) &arg2 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpBodyApplyImpulse((cpBody*)arg0 , (cpVect)arg1 , (cpVect)arg2  );
    args.rval().setUndefined();
    return true;
}

// Arguments: 
// Ret value: void
bool JSB_cpBody_destroy(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;

    cpBodyDestroy((cpBody*)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpBody_getAngVel(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpBodyGetAngVel((cpBody*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpBody_getAngVelLimit(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpBodyGetAngVelLimit((cpBody*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpBody_getAngle(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpBodyGetAngle((cpBody*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpBody_getForce(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    cpVect ret_val;

    ret_val = cpBodyGetForce((cpBody*)arg0  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpBody_getMass(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpBodyGetMass((cpBody*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpBody_getMoment(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpBodyGetMoment((cpBody*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpBody_getPos(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    cpVect ret_val;

    ret_val = cpBodyGetPos((cpBody*)arg0  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpBody_getRot(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    cpVect ret_val;

    ret_val = cpBodyGetRot((cpBody*)arg0  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: cpSpace*
bool JSB_cpBody_getSpace(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    cpSpace* ret_val = nullptr;

    ret_val = cpBodyGetSpace((cpBody*)arg0  );
    
    JS::RootedObject spaceProto(cx, JSB_cpSpace_object);
    jsval ret_jsval = c_class_to_jsval( cx, ret_val, spaceProto, JSB_cpSpace_class, "cpSpace" );
    args.rval().set(ret_jsval);
    
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpBody_getTorque(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpBodyGetTorque((cpBody*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpBody_getVel(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    cpVect ret_val;

    ret_val = cpBodyGetVel((cpBody*)arg0  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: cpVect
// Ret value: cpVect
bool JSB_cpBody_getVelAtLocalPoint(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    bool ok = true;
    cpVect arg1; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    cpVect ret_val;

    ret_val = cpBodyGetVelAtLocalPoint((cpBody*)arg0 , (cpVect)arg1  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: cpVect
// Ret value: cpVect
bool JSB_cpBody_getVelAtWorldPoint(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    bool ok = true;
    cpVect arg1; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    cpVect ret_val;

    ret_val = cpBodyGetVelAtWorldPoint((cpBody*)arg0 , (cpVect)arg1  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpBody_getVelLimit(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpBodyGetVelLimit((cpBody*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: cpFloat, cpFloat
// Ret value: cpBody*
bool JSB_cpBody_init(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    bool ok = true;
    double arg1 = 0; double arg2 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    ok &= JS::ToNumber( cx, args.get(1), &arg2 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    cpBody* ret_val = nullptr;

    ret_val = cpBodyInit((cpBody*)arg0 , (cpFloat)arg1 , (cpFloat)arg2  );
    
    JS::RootedObject bodyProto(cx, JSB_cpBody_object);
    jsval ret_jsval = c_class_to_jsval( cx, ret_val, bodyProto, JSB_cpBody_class, "cpBody" );
    args.rval().set(ret_jsval);
    
    return true;
}

// Arguments: 
// Ret value: cpBody*
bool JSB_cpBody_initStatic(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    cpBody* ret_val = nullptr;

    ret_val = cpBodyInitStatic((cpBody*)arg0  );
    
    JS::RootedObject bodyProto(cx, JSB_cpBody_object);
    jsval ret_jsval = c_class_to_jsval( cx, ret_val, bodyProto, JSB_cpBody_class, "cpBody" );
    args.rval().set(ret_jsval);
    
    return true;
}

// Arguments: 
// Ret value: cpBool
bool JSB_cpBody_isRogue(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    cpBool ret_val;

    ret_val = cpBodyIsRogue((cpBody*)arg0  );
    args.rval().set(INT_TO_JSVAL((int32_t)ret_val));
    return true;
}

// Arguments: 
// Ret value: cpBool
bool JSB_cpBody_isSleeping(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    cpBool ret_val;

    ret_val = cpBodyIsSleeping((cpBody*)arg0  );
    args.rval().set(INT_TO_JSVAL((int32_t)ret_val));
    return true;
}

// Arguments: 
// Ret value: cpBool
bool JSB_cpBody_isStatic(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    cpBool ret_val;

    ret_val = cpBodyIsStatic((cpBody*)arg0  );
    args.rval().set(INT_TO_JSVAL((int32_t)ret_val));
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpBody_kineticEnergy(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpBodyKineticEnergy((cpBody*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: cpVect
// Ret value: cpVect
bool JSB_cpBody_local2World(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    bool ok = true;
    cpVect arg1; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    cpVect ret_val;

    ret_val = cpBodyLocal2World((cpBody*)arg0 , (cpVect)arg1  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: void
bool JSB_cpBody_resetForces(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;

    cpBodyResetForces((cpBody*)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpBody_setAngVel(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpBodySetAngVel((cpBody*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpBody_setAngVelLimit(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpBodySetAngVelLimit((cpBody*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpBody_setAngle(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpBodySetAngle((cpBody*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpBody_setForce(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    bool ok = true;
    cpVect arg1; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpBodySetForce((cpBody*)arg0 , (cpVect)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpBody_setMass(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpBodySetMass((cpBody*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpBody_setMoment(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpBodySetMoment((cpBody*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpBody_setPos(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    bool ok = true;
    cpVect arg1; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpBodySetPos((cpBody*)arg0 , (cpVect)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpBody_setTorque(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpBodySetTorque((cpBody*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpBody_setVel(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    bool ok = true;
    cpVect arg1; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpBodySetVel((cpBody*)arg0 , (cpVect)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpBody_setVelLimit(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpBodySetVelLimit((cpBody*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: 
// Ret value: void
bool JSB_cpBody_sleep(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;

    cpBodySleep((cpBody*)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpBody*
// Ret value: void
bool JSB_cpBody_sleepWithGroup(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    bool ok = true;
    cpBody* arg1 = nullptr; 

    ok &= jsval_to_c_class( cx, args.get(0), (void**)&arg1, NULL );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpBodySleepWithGroup((cpBody*)arg0 , (cpBody*)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpBody_updatePosition(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpBodyUpdatePosition((cpBody*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpVect, cpFloat, cpFloat
// Ret value: void
bool JSB_cpBody_updateVelocity(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 3, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    bool ok = true;
    cpVect arg1; double arg2 = 0; double arg3 = 0; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    ok &= JS::ToNumber( cx, args.get(1), &arg2 );
    ok &= JS::ToNumber( cx, args.get(2), &arg3 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpBodyUpdateVelocity((cpBody*)arg0 , (cpVect)arg1 , (cpFloat)arg2 , (cpFloat)arg3  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpVect
// Ret value: cpVect
bool JSB_cpBody_world2Local(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpBody* arg0 = (cpBody*) proxy->handle;
    bool ok = true;
    cpVect arg1; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    cpVect ret_val;

    ret_val = cpBodyWorld2Local((cpBody*)arg0 , (cpVect)arg1  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

bool js_get_cpBody_vx(JSContext *cx, uint32_t argc, jsval *vp)
{
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpBody* body = (cpBody*) proxy->handle;
    args.rval().set(DOUBLE_TO_JSVAL(body->v.x));
    return true;
}

bool js_get_cpBody_vy(JSContext *cx, uint32_t argc, jsval *vp)
{
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpBody* body = (cpBody*) proxy->handle;
    args.rval().set(DOUBLE_TO_JSVAL(body->v.y));
    return true;
}

bool js_get_cpBody_inverse_m(JSContext *cx, uint32_t argc, jsval *vp)
{
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpBody* body = (cpBody*) proxy->handle;
    args.rval().set(DOUBLE_TO_JSVAL(body->m_inv));
    return true;
}

bool js_get_cpBody_inverse_i(JSContext *cx, uint32_t argc, jsval *vp)
{
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpBody* body = (cpBody*) proxy->handle;
    args.rval().set(DOUBLE_TO_JSVAL(body->i_inv));
    return true;
}

void JSB_cpBody_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    JSB_cpBody_class = (JSClass *)calloc(1, sizeof(JSClass));
    JSB_cpBody_class->name = name;
    JSB_cpBody_class->addProperty = JS_PropertyStub;
    JSB_cpBody_class->delProperty = JS_DeletePropertyStub;
    JSB_cpBody_class->getProperty = JS_PropertyStub;
    JSB_cpBody_class->setProperty = JS_StrictPropertyStub;
    JSB_cpBody_class->enumerate = JS_EnumerateStub;
    JSB_cpBody_class->resolve = JS_ResolveStub;
    JSB_cpBody_class->convert = JS_ConvertStub;
    JSB_cpBody_class->finalize = JSB_cpBody_finalize;
    JSB_cpBody_class->flags = JSCLASS_HAS_PRIVATE;

    static JSPropertySpec properties[] = {
        JS_PSG("vx", js_get_cpBody_vx, JSPROP_ENUMERATE | JSPROP_PERMANENT),
        JS_PSG("vy", js_get_cpBody_vy, JSPROP_ENUMERATE | JSPROP_PERMANENT),
        JS_PSG("m_inv", js_get_cpBody_inverse_m, JSPROP_ENUMERATE | JSPROP_PERMANENT),
        JS_PSG("i_inv", js_get_cpBody_inverse_i, JSPROP_ENUMERATE | JSPROP_PERMANENT),
        JS_PS_END
    };
    static JSFunctionSpec funcs[] = {
        JS_FN("activate", JSB_cpBody_activate, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("activateStatic", JSB_cpBody_activateStatic, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("applyForce", JSB_cpBody_applyForce, 2, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("applyImpulse", JSB_cpBody_applyImpulse, 2, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("destroy", JSB_cpBody_destroy, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getAngVel", JSB_cpBody_getAngVel, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getAngVelLimit", JSB_cpBody_getAngVelLimit, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getAngle", JSB_cpBody_getAngle, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getForce", JSB_cpBody_getForce, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getMass", JSB_cpBody_getMass, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getMoment", JSB_cpBody_getMoment, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getPos", JSB_cpBody_getPos, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getRot", JSB_cpBody_getRot, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getSpace", JSB_cpBody_getSpace, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getTorque", JSB_cpBody_getTorque, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getVel", JSB_cpBody_getVel, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getVelAtLocalPoint", JSB_cpBody_getVelAtLocalPoint, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getVelAtWorldPoint", JSB_cpBody_getVelAtWorldPoint, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getVelLimit", JSB_cpBody_getVelLimit, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("init", JSB_cpBody_init, 2, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("initStatic", JSB_cpBody_initStatic, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("isRogue", JSB_cpBody_isRogue, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("isSleeping", JSB_cpBody_isSleeping, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("isStatic", JSB_cpBody_isStatic, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("kineticEnergy", JSB_cpBody_kineticEnergy, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("local2World", JSB_cpBody_local2World, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("resetForces", JSB_cpBody_resetForces, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setAngVel", JSB_cpBody_setAngVel, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setAngVelLimit", JSB_cpBody_setAngVelLimit, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setAngle", JSB_cpBody_setAngle, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setForce", JSB_cpBody_setForce, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setMass", JSB_cpBody_setMass, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setMoment", JSB_cpBody_setMoment, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setPos", JSB_cpBody_setPos, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setTorque", JSB_cpBody_setTorque, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setVel", JSB_cpBody_setVel, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setVelLimit", JSB_cpBody_setVelLimit, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("sleep", JSB_cpBody_sleep, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("sleepWithGroup", JSB_cpBody_sleepWithGroup, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("updatePosition", JSB_cpBody_updatePosition, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("updateVelocity", JSB_cpBody_updateVelocity, 3, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("world2Local", JSB_cpBody_world2Local, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setUserData", JSB_cpBody_setUserData, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getUserData", JSB_cpBody_getUserData, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("eachShape", JSB_cpBody_eachShape, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("eachConstraint", JSB_cpBody_eachConstraint, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("eachArbiter", JSB_cpBody_eachArbiter, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FS_END
    };
    static JSFunctionSpec st_funcs[] = {
        JS_FS_END
    };
    
    JS::RootedObject baseProto(cx, JSB_cpBase_object);
    JSB_cpBody_object = JS_InitClass(cx, globalObj, baseProto, JSB_cpBody_class, JSB_cpBody_constructor,0,properties,funcs,NULL,st_funcs);
}

/*
 * cpShape
 */
#pragma mark - cpShape

JSClass* JSB_cpShape_class = NULL;
JSObject* JSB_cpShape_object = NULL;

// Constructor
bool JSB_cpShape_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSB_PRECONDITION2(argc==0, cx, false, "Invalid number of arguments");
    JSB_PRECONDITION2(false, cx, true, "No constructor");

    return true;
}

// Destructor
void JSB_cpShape_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    if( proxy ) {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpShape), handle: %p", jsthis, proxy->handle);

        jsb_del_jsobject_for_proxy(proxy->handle);
        if(proxy->flags == JSB_C_FLAG_CALL_FREE)
            cpShapeFree( (cpShape*)proxy->handle);
        jsb_del_c_proxy_for_jsobject(jsthis);
    } else {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpShape)", jsthis);
    }
}

// Arguments: 
// Ret value: cpBB
bool JSB_cpShape_cacheBB(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* arg0 = (cpShape*) proxy->handle;
    cpBB ret_val;

    ret_val = cpShapeCacheBB((cpShape*)arg0  );

    jsval ret_jsval = cpBB_to_jsval( cx, (cpBB)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: void
bool JSB_cpShape_destroy(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* arg0 = (cpShape*) proxy->handle;

    cpShapeDestroy((cpShape*)arg0  );
    args.rval().setUndefined();
    return true;
}

// Arguments: 
// Ret value: cpBB
bool JSB_cpShape_getBB(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* arg0 = (cpShape*) proxy->handle;
    cpBB ret_val;

    ret_val = cpShapeGetBB((cpShape*)arg0  );

    jsval ret_jsval = cpBB_to_jsval( cx, (cpBB)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: cpBody*
bool JSB_cpShape_getBody(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* arg0 = (cpShape*) proxy->handle;
    cpBody* ret_val = nullptr;

    ret_val = cpShapeGetBody((cpShape*)arg0  );
    
    JS::RootedObject bodyProto(cx, JSB_cpBody_object);
    jsval ret_jsval = c_class_to_jsval( cx, ret_val, bodyProto, JSB_cpBody_class, "cpBody" );
    args.rval().set(ret_jsval);
    
    return true;
}

// Arguments: 
// Ret value: cpCollisionType
bool JSB_cpShape_getCollisionType(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* arg0 = (cpShape*) proxy->handle;
    cpCollisionType ret_val = 0;

    ret_val = cpShapeGetCollisionType((cpShape*)arg0  );

    jsval ret_jsval = uint32_to_jsval( cx, (uint32_t)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpShape_getElasticity(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* arg0 = (cpShape*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpShapeGetElasticity((cpShape*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpShape_getFriction(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* arg0 = (cpShape*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpShapeGetFriction((cpShape*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: 
// Ret value: cpGroup
bool JSB_cpShape_getGroup(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* arg0 = (cpShape*) proxy->handle;
    cpGroup ret_val = 0;

    ret_val = cpShapeGetGroup((cpShape*)arg0  );

    jsval ret_jsval = uint32_to_jsval( cx, (uint32_t)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: cpLayers
bool JSB_cpShape_getLayers(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* arg0 = (cpShape*) proxy->handle;
    cpLayers ret_val = 0;

    ret_val = cpShapeGetLayers((cpShape*)arg0  );
    args.rval().set(UINT_TO_JSVAL((uint32_t)ret_val));
    return true;
}

// Arguments: 
// Ret value: cpBool
bool JSB_cpShape_getSensor(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* arg0 = (cpShape*) proxy->handle;
    cpBool ret_val;

    ret_val = cpShapeGetSensor((cpShape*)arg0  );
    args.rval().set(INT_TO_JSVAL((int32_t)ret_val));
    return true;
}

// Arguments: 
// Ret value: cpSpace*
bool JSB_cpShape_getSpace(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* arg0 = (cpShape*) proxy->handle;
    cpSpace* ret_val = nullptr;

    ret_val = cpShapeGetSpace((cpShape*)arg0  );
    
    JS::RootedObject spaceProto(cx, JSB_cpSpace_object);
    jsval ret_jsval = c_class_to_jsval( cx, ret_val, spaceProto, JSB_cpSpace_class, "cpSpace" );
    args.rval().set(ret_jsval);
    
    return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpShape_getSurfaceVelocity(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* arg0 = (cpShape*) proxy->handle;
    cpVect ret_val;

    ret_val = cpShapeGetSurfaceVelocity((cpShape*)arg0  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: cpVect
// Ret value: cpBool
bool JSB_cpShape_pointQuery(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* arg0 = (cpShape*) proxy->handle;
    bool ok = true;
    cpVect arg1; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    cpBool ret_val;

    ret_val = cpShapePointQuery((cpShape*)arg0 , (cpVect)arg1  );
    args.rval().set(INT_TO_JSVAL((int32_t)ret_val));
    return true;
}

// Arguments: cpBody*
// Ret value: void
bool JSB_cpShape_setBody(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* arg0 = (cpShape*) proxy->handle;
    bool ok = true;
    cpBody* arg1 = nullptr; 

    ok &= jsval_to_c_class( cx, args.get(0), (void**)&arg1, NULL );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpShapeSetBody((cpShape*)arg0 , (cpBody*)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpCollisionType
// Ret value: void
bool JSB_cpShape_setCollisionType(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* arg0 = (cpShape*) proxy->handle;
    bool ok = true;
    cpCollisionType arg1 = 0;

    ok &= jsval_to_uint( cx, args.get(0), (unsigned int*) &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpShapeSetCollisionType((cpShape*)arg0 , (cpCollisionType)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpShape_setElasticity(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* arg0 = (cpShape*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpShapeSetElasticity((cpShape*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpFloat
// Ret value: void
bool JSB_cpShape_setFriction(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* arg0 = (cpShape*) proxy->handle;
    bool ok = true;
    double arg1 = 0; 

    ok &= JS::ToNumber( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpShapeSetFriction((cpShape*)arg0 , (cpFloat)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpGroup
// Ret value: void
bool JSB_cpShape_setGroup(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* arg0 = (cpShape*) proxy->handle;
    bool ok = true;
    cpGroup arg1 = 0; 

    ok &= jsval_to_uint( cx, args.get(0), (unsigned int*) &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpShapeSetGroup((cpShape*)arg0 , (cpGroup)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpLayers
// Ret value: void
bool JSB_cpShape_setLayers(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* arg0 = (cpShape*) proxy->handle;
    bool ok = true;
    uint32_t arg1 = 0; 

    ok &= jsval_to_uint32( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpShapeSetLayers((cpShape*)arg0 , (cpLayers)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpBool
// Ret value: void
bool JSB_cpShape_setSensor(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* arg0 = (cpShape*) proxy->handle;
    bool ok = true;
    int32_t arg1 = 0; 

    ok &= jsval_to_int32( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpShapeSetSensor((cpShape*)arg0 , (cpBool)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpVect
// Ret value: void
bool JSB_cpShape_setSurfaceVelocity(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* arg0 = (cpShape*) proxy->handle;
    bool ok = true;
    cpVect arg1; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpShapeSetSurfaceVelocity((cpShape*)arg0 , (cpVect)arg1  );
    args.rval().setUndefined();
    return true;
}

// Arguments: cpVect, cpVect
// Ret value: cpBB
bool JSB_cpShape_update(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* arg0 = (cpShape*) proxy->handle;
    bool ok = true;
    cpVect arg1; cpVect arg2; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg2 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    cpBB ret_val;

    ret_val = cpShapeUpdate((cpShape*)arg0 , (cpVect)arg1 , (cpVect)arg2  );

    jsval ret_jsval = cpBB_to_jsval( cx, (cpBB)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: void
// Ret value: cpBool
bool JSB_cpShape_active(JSContext *cx, uint32_t argc, jsval *vp){
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* arg0 = (cpShape*) proxy->handle;

    bool active = cpShapeActive(arg0);
    jsval retval = BOOLEAN_TO_JSVAL(active);
    args.rval().set(retval);
    return true;
}

bool JSB_cpShape_nearestPointQuery(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* shape = (cpShape*) proxy->handle;

    cpVect p;
    bool ok = jsval_to_cpVect(cx, args.get(0), &p);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpNearestPointQueryInfo* info = new cpNearestPointQueryInfo();
    cpShapeNearestPointQuery(shape, p, info);
    JS::RootedObject nearestPointQueryInfoProto(cx, JSB_cpNearestPointQueryInfo_object);
    JS::RootedObject jsobj(cx, JS_NewObject(cx, JSB_cpNearestPointQueryInfo_class, nearestPointQueryInfoProto, JS::NullPtr()));
    jsb_set_jsobject_for_proxy(jsobj, info);
    jsb_set_c_proxy_for_jsobject(jsobj, info, JSB_C_FLAG_CALL_FREE);
    args.rval().set(OBJECT_TO_JSVAL(jsobj));

    return true;
}

bool JSB_cpShape_segmentQuery(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpShape* shape = (cpShape*) proxy->handle;

    cpVect a;
    cpVect b;
    bool ok = jsval_to_cpVect(cx, args.get(0), &a);
    ok &= jsval_to_cpVect(cx, args.get(1), &b);
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpSegmentQueryInfo* info = new cpSegmentQueryInfo();
    if(cpShapeSegmentQuery(shape, a, b, info))
    {
        JS::RootedObject segmentQueryInfoProto(cx, JSB_cpSegmentQueryInfo_object);
        JSObject* jsobj = JS_NewObject(cx, JSB_cpSegmentQueryInfo_class, segmentQueryInfoProto, JS::NullPtr());
        jsb_set_jsobject_for_proxy(jsobj, info);
        jsb_set_c_proxy_for_jsobject(jsobj, info, JSB_C_FLAG_CALL_FREE);
        args.rval().set(OBJECT_TO_JSVAL(jsobj));
    }
    else
    {
        delete info;
        args.rval().set(JSVAL_NULL);
    }
    return true;
}

static bool js_get_cpShape_bbl(JSContext *cx, uint32_t argc, jsval *vp) {
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpShape* shape = (cpShape*) proxy->handle;
    args.rval().setNumber(shape->bb.l);
    return true;
}

static bool js_set_cpShape_bbl(JSContext *cx, uint32_t argc, jsval *vp){
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpShape* shape = (cpShape*) proxy->handle;
    shape->bb.l = args.get(0).toDouble();
    return true;
}

static bool js_get_cpShape_bbb(JSContext *cx, uint32_t argc, jsval *vp) {
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpShape* shape = (cpShape*) proxy->handle;
    args.rval().setNumber(shape->bb.b);
    return true;
}

static bool js_set_cpShape_bbb(JSContext *cx, uint32_t argc, jsval *vp){
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpShape* shape = (cpShape*) proxy->handle;
    shape->bb.b = args.get(0).toDouble();
    return true;
}
static bool js_get_cpShape_bbr(JSContext *cx, uint32_t argc, jsval *vp) {
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpShape* shape = (cpShape*) proxy->handle;
    args.rval().setNumber(shape->bb.r);
    return true;
}

static bool js_set_cpShape_bbr(JSContext *cx, uint32_t argc, jsval *vp){
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpShape* shape = (cpShape*) proxy->handle;
    shape->bb.r = args.get(0).toDouble();
    return true;
}

static bool js_get_cpShape_bbt(JSContext *cx, uint32_t argc, jsval *vp) {
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpShape* shape = (cpShape*) proxy->handle;
    args.rval().setNumber(shape->bb.t);
    return true;
}

static bool js_set_cpShape_bbt(JSContext *cx, uint32_t argc, jsval *vp){
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpShape* shape = (cpShape*) proxy->handle;
    shape->bb.t = args.get(0).toDouble();
    return true;
}

void JSB_cpShape_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    JSB_cpShape_class = (JSClass *)calloc(1, sizeof(JSClass));
    JSB_cpShape_class->name = name;
    JSB_cpShape_class->addProperty = JS_PropertyStub;
    JSB_cpShape_class->delProperty = JS_DeletePropertyStub;
    JSB_cpShape_class->getProperty = JS_PropertyStub;
    JSB_cpShape_class->setProperty = JS_StrictPropertyStub;
    JSB_cpShape_class->enumerate = JS_EnumerateStub;
    JSB_cpShape_class->resolve = JS_ResolveStub;
    JSB_cpShape_class->convert = JS_ConvertStub;
    JSB_cpShape_class->finalize = JSB_cpShape_finalize;
    JSB_cpShape_class->flags = JSCLASS_HAS_PRIVATE;

    static JSPropertySpec properties[] = {
        JS_PSGS("bb_l", js_get_cpShape_bbl, js_set_cpShape_bbl, JSPROP_ENUMERATE | JSPROP_PERMANENT),
        JS_PSGS("bb_b", js_get_cpShape_bbb, js_set_cpShape_bbb, JSPROP_ENUMERATE | JSPROP_PERMANENT),
        JS_PSGS("bb_r", js_get_cpShape_bbr, js_set_cpShape_bbr, JSPROP_ENUMERATE | JSPROP_PERMANENT),
        JS_PSGS("bb_t", js_get_cpShape_bbt, js_set_cpShape_bbt, JSPROP_ENUMERATE | JSPROP_PERMANENT),
        JS_PS_END
    };
    static JSFunctionSpec funcs[] = {
        JS_FN("cacheBB", JSB_cpShape_cacheBB, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("destroy", JSB_cpShape_destroy, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getBB", JSB_cpShape_getBB, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getBody", JSB_cpShape_getBody, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getCollisionType", JSB_cpShape_getCollisionType, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getElasticity", JSB_cpShape_getElasticity, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getFriction", JSB_cpShape_getFriction, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getGroup", JSB_cpShape_getGroup, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getLayers", JSB_cpShape_getLayers, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getSensor", JSB_cpShape_getSensor, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getSpace", JSB_cpShape_getSpace, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getSurfaceVelocity", JSB_cpShape_getSurfaceVelocity, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("pointQuery", JSB_cpShape_pointQuery, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setBody", JSB_cpShape_setBody, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setCollisionType", JSB_cpShape_setCollisionType, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setElasticity", JSB_cpShape_setElasticity, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setFriction", JSB_cpShape_setFriction, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setGroup", JSB_cpShape_setGroup, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setLayers", JSB_cpShape_setLayers, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setSensor", JSB_cpShape_setSensor, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setSurfaceVelocity", JSB_cpShape_setSurfaceVelocity, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("update", JSB_cpShape_update, 2, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("active", JSB_cpShape_active, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("nearestPointQuery", JSB_cpShape_nearestPointQuery, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("segmentQuery", JSB_cpShape_segmentQuery, 2, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FS_END
    };
    static JSFunctionSpec st_funcs[] = {
        JS_FS_END
    };
    
    JS::RootedObject baseProto(cx, JSB_cpBase_object);
    JSB_cpShape_object = JS_InitClass(cx, globalObj, baseProto, JSB_cpShape_class, JSB_cpShape_constructor,0,properties,funcs,NULL,st_funcs);
}

/*
 * cpCircleShape
 */
#pragma mark - cpCircleShape

JSClass* JSB_cpCircleShape_class = NULL;
JSObject* JSB_cpCircleShape_object = NULL;
// Arguments: cpBody*, cpFloat, cpVect
// Constructor
bool JSB_cpCircleShape_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSB_PRECONDITION2(argc==3, cx, false, "Invalid number of arguments");
    JS::RootedObject circleShapeProto(cx, JSB_cpCircleShape_object);
    JS::RootedObject jsobj(cx, JS_NewObject(cx, JSB_cpCircleShape_class, circleShapeProto, JS::NullPtr()));
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    cpBody* arg0 = nullptr; double arg1 = 0; cpVect arg2; 

    ok &= jsval_to_c_class( cx, args.get(0), (void**)&arg0, NULL );
    ok &= JS::ToNumber( cx, args.get(1), &arg1 );
    ok &= jsval_to_cpVect( cx, args.get(2), (cpVect*) &arg2 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    void*   ret_val = cpCircleShapeNew((cpBody*)arg0 , (cpFloat)arg1 , (cpVect)arg2  );

    jsb_set_jsobject_for_proxy(jsobj, ret_val);
    jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
    args.rval().set(OBJECT_TO_JSVAL(jsobj));

    return true;
}

// Destructor
void JSB_cpCircleShape_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    if( proxy ) {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpCircleShape), handle: %p", jsthis, proxy->handle);

        jsb_del_jsobject_for_proxy(proxy->handle);
        if(proxy->flags == JSB_C_FLAG_CALL_FREE)
            cpShapeFree( (cpShape*)proxy->handle);
        jsb_del_c_proxy_for_jsobject(jsthis);
    } else {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpCircleShape)", jsthis);
    }
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpCircleShape_getOffset(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpCircleShape* arg0 = (cpCircleShape*) proxy->handle;
    cpVect ret_val;

    ret_val = cpCircleShapeGetOffset((cpShape*)arg0  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpCircleShape_getRadius(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpCircleShape* arg0 = (cpCircleShape*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpCircleShapeGetRadius((cpShape*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

void JSB_cpCircleShape_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    JSB_cpCircleShape_class = (JSClass *)calloc(1, sizeof(JSClass));
    JSB_cpCircleShape_class->name = name;
    JSB_cpCircleShape_class->addProperty = JS_PropertyStub;
    JSB_cpCircleShape_class->delProperty = JS_DeletePropertyStub;
    JSB_cpCircleShape_class->getProperty = JS_PropertyStub;
    JSB_cpCircleShape_class->setProperty = JS_StrictPropertyStub;
    JSB_cpCircleShape_class->enumerate = JS_EnumerateStub;
    JSB_cpCircleShape_class->resolve = JS_ResolveStub;
    JSB_cpCircleShape_class->convert = JS_ConvertStub;
    JSB_cpCircleShape_class->finalize = JSB_cpCircleShape_finalize;
    JSB_cpCircleShape_class->flags = JSCLASS_HAS_PRIVATE;

    static JSPropertySpec properties[] = {
        JS_PS_END
    };
    static JSFunctionSpec funcs[] = {
        JS_FN("getOffset", JSB_cpCircleShape_getOffset, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getRadius", JSB_cpCircleShape_getRadius, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FS_END
    };
    static JSFunctionSpec st_funcs[] = {
        JS_FS_END
    };
    
    JS::RootedObject shapeProto(cx, JSB_cpShape_object);
    JSB_cpCircleShape_object = JS_InitClass(cx, globalObj, shapeProto, JSB_cpCircleShape_class, JSB_cpCircleShape_constructor,0,properties,funcs,NULL,st_funcs);
}

/*
 * cpSegmentShape
 */
#pragma mark - cpSegmentShape

JSClass* JSB_cpSegmentShape_class = NULL;
JSObject* JSB_cpSegmentShape_object = NULL;
// Arguments: cpBody*, cpVect, cpVect, cpFloat
// Constructor
bool JSB_cpSegmentShape_constructor(JSContext *cx, uint32_t argc, jsval *vp)
{
    JSB_PRECONDITION2(argc==4, cx, false, "Invalid number of arguments");
    JS::RootedObject segmentShapeProto(cx, JSB_cpSegmentShape_object);
    JS::RootedObject jsobj(cx, JS_NewObject(cx, JSB_cpSegmentShape_class, segmentShapeProto, JS::NullPtr()));
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    bool ok = true;
    cpBody* arg0 = nullptr; cpVect arg1; cpVect arg2; double arg3 = 0; 

    ok &= jsval_to_c_class( cx, args.get(0), (void**)&arg0, NULL );
    ok &= jsval_to_cpVect( cx, args.get(1), (cpVect*) &arg1 );
    ok &= jsval_to_cpVect( cx, args.get(2), (cpVect*) &arg2 );
    ok &= JS::ToNumber( cx, args.get(3), &arg3 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    void*   ret_val = cpSegmentShapeNew((cpBody*)arg0 , (cpVect)arg1 , (cpVect)arg2 , (cpFloat)arg3  );

    jsb_set_jsobject_for_proxy(jsobj, ret_val);
    jsb_set_c_proxy_for_jsobject(jsobj, ret_val, JSB_C_FLAG_CALL_FREE);
    args.rval().set(OBJECT_TO_JSVAL(jsobj));

    return true;
}

// Destructor
void JSB_cpSegmentShape_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    if( proxy ) {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpSegmentShape), handle: %p", jsthis, proxy->handle);

        jsb_del_jsobject_for_proxy(proxy->handle);
        if(proxy->flags == JSB_C_FLAG_CALL_FREE)
            cpShapeFree( (cpShape*)proxy->handle);
        jsb_del_c_proxy_for_jsobject(jsthis);
    } else {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpSegmentShape)", jsthis);
    }
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpSegmentShape_getA(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSegmentShape* arg0 = (cpSegmentShape*) proxy->handle;
    cpVect ret_val;

    ret_val = cpSegmentShapeGetA((cpShape*)arg0  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpSegmentShape_getB(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSegmentShape* arg0 = (cpSegmentShape*) proxy->handle;
    cpVect ret_val;

    ret_val = cpSegmentShapeGetB((cpShape*)arg0  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: cpVect
bool JSB_cpSegmentShape_getNormal(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSegmentShape* arg0 = (cpSegmentShape*) proxy->handle;
    cpVect ret_val;

    ret_val = cpSegmentShapeGetNormal((cpShape*)arg0  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

// Arguments: 
// Ret value: cpFloat
bool JSB_cpSegmentShape_getRadius(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSegmentShape* arg0 = (cpSegmentShape*) proxy->handle;
    cpFloat ret_val = 0;

    ret_val = cpSegmentShapeGetRadius((cpShape*)arg0  );
    args.rval().set(DOUBLE_TO_JSVAL(ret_val));
    return true;
}

// Arguments: cpVect, cpVect
// Ret value: void
bool JSB_cpSegmentShape_setNeighbors(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSegmentShape* arg0 = (cpSegmentShape*) proxy->handle;
    bool ok = true;
    cpVect arg1; cpVect arg2; 

    ok &= jsval_to_cpVect( cx, args.get(0), (cpVect*) &arg1 );
    ok &= jsval_to_cpVect( cx, args.get(1), (cpVect*) &arg2 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

    cpSegmentShapeSetNeighbors((cpShape*)arg0 , (cpVect)arg1 , (cpVect)arg2  );
    args.rval().setUndefined();
    return true;
}

static bool js_get_cpSegmentShape_a_tangent(JSContext *cx, uint32_t argc, jsval *vp)
{
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpSegmentShape* shape = (cpSegmentShape*) proxy->handle;
    cpVect vec = shape->a_tangent;
    jsval ret = cpVect_to_jsval( cx, vec);
    args.rval().set(ret);
    return true;
}

static bool js_get_cpSegmentShape_b_tangent(JSContext *cx, uint32_t argc, jsval *vp)
{
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpSegmentShape* shape = (cpSegmentShape*) proxy->handle;
    cpVect vec = shape->b_tangent;
    jsval ret = cpVect_to_jsval( cx, vec);
    args.rval().set(ret);
    return true;
}

void JSB_cpSegmentShape_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    JSB_cpSegmentShape_class = (JSClass *)calloc(1, sizeof(JSClass));
    JSB_cpSegmentShape_class->name = name;
    JSB_cpSegmentShape_class->addProperty = JS_PropertyStub;
    JSB_cpSegmentShape_class->delProperty = JS_DeletePropertyStub;
    JSB_cpSegmentShape_class->getProperty = JS_PropertyStub;
    JSB_cpSegmentShape_class->setProperty = JS_StrictPropertyStub;
    JSB_cpSegmentShape_class->enumerate = JS_EnumerateStub;
    JSB_cpSegmentShape_class->resolve = JS_ResolveStub;
    JSB_cpSegmentShape_class->convert = JS_ConvertStub;
    JSB_cpSegmentShape_class->finalize = JSB_cpSegmentShape_finalize;
    JSB_cpSegmentShape_class->flags = JSCLASS_HAS_PRIVATE;

    static JSPropertySpec properties[] = {
        JS_PSG("a_tangent", js_get_cpSegmentShape_a_tangent, JSPROP_ENUMERATE | JSPROP_PERMANENT),
        JS_PSG("b_tangent", js_get_cpSegmentShape_a_tangent, JSPROP_ENUMERATE | JSPROP_PERMANENT),
        JS_PS_END
    };
    static JSFunctionSpec funcs[] = {
        JS_FN("getA", JSB_cpSegmentShape_getA, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getB", JSB_cpSegmentShape_getB, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getNormal", JSB_cpSegmentShape_getNormal, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getRadius", JSB_cpSegmentShape_getRadius, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("setNeighbors", JSB_cpSegmentShape_setNeighbors, 2, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FS_END
    };
    static JSFunctionSpec st_funcs[] = {
        JS_FS_END
    };
    
    JS::RootedObject shapeProto(cx, JSB_cpShape_object);
    JSB_cpSegmentShape_object = JS_InitClass(cx, globalObj, shapeProto, JSB_cpSegmentShape_class, JSB_cpSegmentShape_constructor,0,properties,funcs,NULL,st_funcs);
}

/*
 * cpPolyShape
 */
#pragma mark - cpPolyShape

JSClass* JSB_cpPolyShape_class = NULL;
JSObject* JSB_cpPolyShape_object = NULL;

// Destructor
void JSB_cpPolyShape_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    if( proxy ) {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpPolyShape), handle: %p", jsthis, proxy->handle);

        jsb_del_jsobject_for_proxy(proxy->handle);
        if(proxy->flags == JSB_C_FLAG_CALL_FREE)
            cpShapeFree( (cpShape*)proxy->handle);
        jsb_del_c_proxy_for_jsobject(jsthis);
    } else {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpPolyShape)", jsthis);
    }
}

// Arguments: 
// Ret value: int
bool JSB_cpPolyShape_getNumVerts(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 0, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpPolyShape* arg0 = (cpPolyShape*) proxy->handle;
    int ret_val = 0;

    ret_val = cpPolyShapeGetNumVerts((cpShape*)arg0  );
    args.rval().set(INT_TO_JSVAL((int32_t)ret_val));
    return true;
}

// Arguments: int
// Ret value: cpVect
bool JSB_cpPolyShape_getVert(JSContext *cx, uint32_t argc, jsval *vp) {
    JSB_PRECONDITION2( argc == 1, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpPolyShape* arg0 = (cpPolyShape*) proxy->handle;
    bool ok = true;
    int32_t arg1 = 0; 

    ok &= jsval_to_int32( cx, args.get(0), &arg1 );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    cpVect ret_val;

    ret_val = cpPolyShapeGetVert((cpShape*)arg0 , (int)arg1  );

    jsval ret_jsval = cpVect_to_jsval( cx, (cpVect)ret_val );
    args.rval().set(ret_jsval);

    return true;
}

static bool js_get_cpPolyShape_verts(JSContext *cx, uint32_t argc, jsval *vp)
{
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpPolyShape* shape = (cpPolyShape*) proxy->handle;
    int numVerts = shape->numVerts;
    cpVect* verts = shape->verts;

    JS::RootedObject jsretArr(cx, JS_NewArrayObject(cx, 0));
    int i = 0;
    while (i < numVerts) {
        cpVect vec = verts[i];

        JS::RootedValue x(cx);
        JS::RootedValue y(cx);
        x = DOUBLE_TO_JSVAL(vec.x);
        y = DOUBLE_TO_JSVAL(vec.y);
        JS_SetElement(cx, jsretArr, i*2, x);
        JS_SetElement(cx, jsretArr, i*2+1, y);
        i++;
    }
    args.rval().set(OBJECT_TO_JSVAL(jsretArr));
    return true;
}

static bool js_get_cpPolyShape_planes(JSContext *cx, uint32_t argc, jsval *vp)
{
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpPolyShape* shape = (cpPolyShape*) proxy->handle;
    int numVerts = shape->numVerts;
    cpSplittingPlane* planes = shape->planes;

    JS::RootedObject jsretArr(cx, JS_NewArrayObject(cx, 0));
    int i = 0;
    while(i < numVerts){
        cpSplittingPlane *plane = planes + i;
        JS::RootedValue elem(cx);

        JS::RootedObject jsobj(cx, jsb_get_jsobject_for_proxy(plane));
        if(!jsobj)
        {
            JS::RootedObject splittingPlaneProto(cx, JSB_cpSplittingPlane_object);
            jsobj = JS_NewObject(cx, JSB_cpSplittingPlane_class, splittingPlaneProto, JS::NullPtr());
            jsb_set_jsobject_for_proxy(jsobj, plane);
            jsb_set_c_proxy_for_jsobject(jsobj, plane, JSB_C_FLAG_DO_NOT_CALL_FREE);
        }

        elem = OBJECT_TO_JSVAL(jsobj);
        JS_SetElement(cx, jsretArr, i, elem);
        i++;
    }
    args.rval().set(OBJECT_TO_JSVAL(jsretArr));
    return true;
}

void JSB_cpPolyShape_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    JSB_cpPolyShape_class = (JSClass *)calloc(1, sizeof(JSClass));
    JSB_cpPolyShape_class->name = name;
    JSB_cpPolyShape_class->addProperty = JS_PropertyStub;
    JSB_cpPolyShape_class->delProperty = JS_DeletePropertyStub;
    JSB_cpPolyShape_class->getProperty = JS_PropertyStub;
    JSB_cpPolyShape_class->setProperty = JS_StrictPropertyStub;
    JSB_cpPolyShape_class->enumerate = JS_EnumerateStub;
    JSB_cpPolyShape_class->resolve = JS_ResolveStub;
    JSB_cpPolyShape_class->convert = JS_ConvertStub;
    JSB_cpPolyShape_class->finalize = JSB_cpPolyShape_finalize;
    JSB_cpPolyShape_class->flags = JSCLASS_HAS_PRIVATE;

    static JSPropertySpec properties[] = {
        JS_PSG("verts", js_get_cpPolyShape_verts, JSPROP_ENUMERATE | JSPROP_PERMANENT),
        JS_PSG("planes", js_get_cpPolyShape_planes, JSPROP_ENUMERATE | JSPROP_PERMANENT),
        JS_PS_END
    };
    static JSFunctionSpec funcs[] = {
        JS_FN("getNumVerts", JSB_cpPolyShape_getNumVerts, 0, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("getVert", JSB_cpPolyShape_getVert, 1, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FS_END
    };
    static JSFunctionSpec st_funcs[] = {
        JS_FS_END
    };
    
    JS::RootedObject shapeProto(cx, JSB_cpShape_object);
    JSB_cpPolyShape_object = JS_InitClass(cx, globalObj, shapeProto, JSB_cpPolyShape_class, JSB_cpPolyShape_constructor,0,properties,funcs,NULL,st_funcs);
}

// SplittingPlane
JSObject *JSB_cpSplittingPlane_object = NULL;
JSClass *JSB_cpSplittingPlane_class = NULL;

// Destructor
void JSB_cpSplittingPlane_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    if( proxy ) {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpSplittingPlane), handle: %p", jsthis, proxy->handle);

        jsb_del_jsobject_for_proxy(proxy->handle);
        jsb_del_c_proxy_for_jsobject(jsthis);

        //no need to free cpSplittingPlane, cpSplittingPlane will be freed by it's shape
    }
}

bool js_get_cpSplitting_n(JSContext *cx, uint32_t argc, jsval *vp)
{
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpSplittingPlane* plane = (cpSplittingPlane*) proxy->handle;
    cpVect vec = plane->n;
    args.rval().set(cpVect_to_jsval(cx, vec));
    return true;
}

bool js_get_cpSplitting_d(JSContext *cx, uint32_t argc, jsval *vp)
{
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpSplittingPlane* plane = (cpSplittingPlane*) proxy->handle;
    args.rval().set(DOUBLE_TO_JSVAL(plane->d));
    return true;
}

void JSB_cpSplittingPlane_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    JSB_cpSplittingPlane_class = (JSClass *)calloc(1, sizeof(JSClass));
    JSB_cpSplittingPlane_class->name = name;
    JSB_cpSplittingPlane_class->addProperty = JS_PropertyStub;
    JSB_cpSplittingPlane_class->delProperty = JS_DeletePropertyStub;
    JSB_cpSplittingPlane_class->getProperty = JS_PropertyStub;
    JSB_cpSplittingPlane_class->setProperty = JS_StrictPropertyStub;
    JSB_cpSplittingPlane_class->enumerate = JS_EnumerateStub;
    JSB_cpSplittingPlane_class->resolve = JS_ResolveStub;
    JSB_cpSplittingPlane_class->convert = JS_ConvertStub;
    JSB_cpSplittingPlane_class->finalize = JSB_cpSplittingPlane_finalize;
    JSB_cpSplittingPlane_class->flags = JSCLASS_HAS_PRIVATE;

    static JSPropertySpec properties[] = {
        JS_PSG("n", js_get_cpSplitting_n, JSPROP_ENUMERATE | JSPROP_PERMANENT),
        JS_PSG("d", js_get_cpSplitting_d, JSPROP_ENUMERATE | JSPROP_PERMANENT),
        JS_PS_END
    };
    static JSFunctionSpec funcs[] = {
        JS_FS_END
    };
    static JSFunctionSpec st_funcs[] = {
        JS_FS_END
    };

    JSB_cpSplittingPlane_object = JS_InitClass(cx, globalObj, JS::NullPtr(), JSB_cpSplittingPlane_class, NULL,0,properties,funcs,NULL,st_funcs);
}

bool JSB_cpSegmentQueryInfo_hitPoint(JSContext *cx, uint32_t argc, jsval *vp){
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSegmentQueryInfo* info = (cpSegmentQueryInfo*) proxy->handle;

    cpVect start;
    cpVect end;
    
    bool ok = true;
    ok &= jsval_to_cpVect( cx, args.get(0), &start );
    ok &= jsval_to_cpVect( cx, args.get(1), &end );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    cpVect ret = cpSegmentQueryHitPoint(start, end, *info);

    jsval ret_jsval = cpVect_to_jsval( cx, ret );
    args.rval().set(ret_jsval);
    return true;
}

bool JSB_cpSegmentQueryInfo_hitDist(JSContext *cx, uint32_t argc, jsval *vp){
    JSB_PRECONDITION2( argc == 2, cx, false, "Invalid number of arguments" );
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    JS::RootedObject jsthis(cx, args.thisv().toObjectOrNull());
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    cpSegmentQueryInfo* info = (cpSegmentQueryInfo*) proxy->handle;

    cpVect start;
    cpVect end;
    
    bool ok = true;
    ok &= jsval_to_cpVect( cx, args.get(0), &start );
    ok &= jsval_to_cpVect( cx, args.get(1), &end );
    JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
    float ret = cpSegmentQueryHitDist(start, end, *info);

    jsval ret_jsval = DOUBLE_TO_JSVAL(ret);
    args.rval().set(ret_jsval);
    return true;
}

JSClass* JSB_cpSegmentQueryInfo_class = NULL;
JSObject* JSB_cpSegmentQueryInfo_object = NULL;

// Destructor
void JSB_cpSegmentQueryInfo_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    if( proxy ) {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpSegmentQueryInfo), handle: %p", jsthis, proxy->handle);

        jsb_del_jsobject_for_proxy(proxy->handle);
        if(proxy->flags == JSB_C_FLAG_CALL_FREE)
            delete ( (cpSegmentQueryInfo*)proxy->handle);
        jsb_del_c_proxy_for_jsobject(jsthis);
    } else {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpSegmentQueryInfo)", jsthis);
    }
}

bool js_get_cpSegmentQueryInfo_shape(JSContext *cx, uint32_t argc, jsval *vp)
{
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpSegmentQueryInfo* info = (cpSegmentQueryInfo*) proxy->handle;
    cpShape* shape = info->shape;
    
    if(shape){
        JS::RootedObject shapeProto(cx, JSB_cpShape_object);
        JS::RootedObject jsobj(cx, JS_NewObject(cx, JSB_cpShape_class, shapeProto, JS::NullPtr()));
        //jsb_set_jsobject_for_proxy(jsobj, shape);
        jsb_set_c_proxy_for_jsobject(jsobj, shape, JSB_C_FLAG_DO_NOT_CALL_FREE);
        args.rval().set(OBJECT_TO_JSVAL(jsobj));
    }else{
        args.rval().setUndefined();
    }
    
    return true;
}

bool js_set_cpSegmentQueryInfo_shape(JSContext *cx, uint32_t argc, jsval *vp)
{
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpSegmentQueryInfo* info = (cpSegmentQueryInfo*) proxy->handle;

    cpShape* shape = nullptr;
    struct jsb_c_proxy_s *retproxy = nullptr;
    jsval_to_c_class( cx, args.get(0), (void**)&shape, &retproxy );

    info->shape = shape;
    return true;
}

bool js_get_cpSegmentQueryInfo_t(JSContext *cx, uint32_t argc, jsval *vp)
{
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpSegmentQueryInfo* info = (cpSegmentQueryInfo*) proxy->handle;
    args.rval().setNumber(info->t);
    return true;
}

bool js_set_cpSegmentQueryInfo_t(JSContext *cx, uint32_t argc, jsval *vp)
{
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpSegmentQueryInfo* info = (cpSegmentQueryInfo*) proxy->handle;
    info->t = args.get(0).toDouble();
    return true;
}

bool js_get_cpSegmentQueryInfo_n(JSContext *cx, uint32_t argc, jsval *vp)
{
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpSegmentQueryInfo* info = (cpSegmentQueryInfo*) proxy->handle;
    args.rval().set(cpVect_to_jsval(cx, info->n));
    return true;
}

bool js_set_cpSegmentQueryInfo_n(JSContext *cx, uint32_t argc, jsval *vp)
{
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpSegmentQueryInfo* info = (cpSegmentQueryInfo*) proxy->handle;
    cpVect v;
    bool ok = jsval_to_cpVect(cx, args.get(0), &v);
    if(ok)
        info->n = v;
    return true;
}

void JSB_cpSegmentQueryInfo_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    JSB_cpSegmentQueryInfo_class = (JSClass *)calloc(1, sizeof(JSClass));
    JSB_cpSegmentQueryInfo_class->name = name;
    JSB_cpSegmentQueryInfo_class->addProperty = JS_PropertyStub;
    JSB_cpSegmentQueryInfo_class->delProperty = JS_DeletePropertyStub;
    JSB_cpSegmentQueryInfo_class->getProperty = JS_PropertyStub;
    JSB_cpSegmentQueryInfo_class->setProperty = JS_StrictPropertyStub;
    JSB_cpSegmentQueryInfo_class->enumerate = JS_EnumerateStub;
    JSB_cpSegmentQueryInfo_class->resolve = JS_ResolveStub;
    JSB_cpSegmentQueryInfo_class->convert = JS_ConvertStub;
    JSB_cpSegmentQueryInfo_class->finalize = JSB_cpSegmentQueryInfo_finalize;
    JSB_cpSegmentQueryInfo_class->flags = JSCLASS_HAS_PRIVATE;

    static JSPropertySpec properties[] = {
        JS_PSGS("shape", js_get_cpSegmentQueryInfo_shape, js_set_cpSegmentQueryInfo_shape, JSPROP_ENUMERATE | JSPROP_PERMANENT),
        JS_PSGS("t", js_get_cpSegmentQueryInfo_t, js_set_cpSegmentQueryInfo_t, JSPROP_ENUMERATE | JSPROP_PERMANENT),
        JS_PSGS("n", js_get_cpSegmentQueryInfo_n, js_set_cpSegmentQueryInfo_n, JSPROP_ENUMERATE | JSPROP_PERMANENT),
        JS_PS_END
    };
    static JSFunctionSpec funcs[] = {
        JS_FN("hitPoint", JSB_cpSegmentQueryInfo_hitPoint, 2, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FN("hitDist", JSB_cpSegmentQueryInfo_hitDist, 2, JSPROP_PERMANENT  | JSPROP_ENUMERATE),
        JS_FS_END
    };
    static JSFunctionSpec st_funcs[] = {
        JS_FS_END
    };

    JSB_cpSegmentQueryInfo_object = JS_InitClass(cx, globalObj, JS::NullPtr(), JSB_cpSegmentQueryInfo_class, NULL,0,properties,funcs,NULL,st_funcs);
}

bool js_get_cpNearestPointQueryInfo_shape(JSContext *cx, uint32_t argc, jsval *vp)
{
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpNearestPointQueryInfo* info = (cpNearestPointQueryInfo*) proxy->handle;
    cpShape* shape = info->shape;
    
    if(shape){
        JS::RootedObject shapeProto(cx, JSB_cpShape_object);
        JS::RootedObject jsobj(cx, JS_NewObject(cx, JSB_cpShape_class, shapeProto, JS::NullPtr()));
        //jsb_set_jsobject_for_proxy(jsobj, shape);
        jsb_set_c_proxy_for_jsobject(jsobj, shape, JSB_C_FLAG_DO_NOT_CALL_FREE);
        args.rval().set(OBJECT_TO_JSVAL(jsobj));
    }else{
        args.rval().setUndefined();
    }
    
    return true;
}

bool js_set_cpNearestPointQueryInfo_shape(JSContext *cx, uint32_t argc, jsval *vp)
{
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpNearestPointQueryInfo* info = (cpNearestPointQueryInfo*) proxy->handle;

    cpShape* shape = nullptr;
    struct jsb_c_proxy_s *retproxy = nullptr;
    jsval_to_c_class( cx, args.get(0), (void**)&shape, &retproxy );

    info->shape = shape;
    return true;
}

bool js_get_cpNearestPointQueryInfo_p(JSContext *cx, uint32_t argc, jsval *vp)
{
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpNearestPointQueryInfo* info = (cpNearestPointQueryInfo*) proxy->handle;
    args.rval().set(cpVect_to_jsval(cx, info->p));
    return true;
}

bool js_set_cpNearestPointQueryInfo_p(JSContext *cx, uint32_t argc, jsval *vp)
{
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpNearestPointQueryInfo* info = (cpNearestPointQueryInfo*) proxy->handle;
    cpVect v;
    bool ok = jsval_to_cpVect(cx, args.get(0), &v);
    if(ok)
        info->p = v;
    return true;
}

bool js_get_cpNearestPointQueryInfo_d(JSContext *cx, uint32_t argc, jsval *vp)
{
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpNearestPointQueryInfo* info = (cpNearestPointQueryInfo*) proxy->handle;
    args.rval().setNumber(info->d);
    return true;
}

bool js_set_cpNearestPointQueryInfo_d(JSContext *cx, uint32_t argc, jsval *vp)
{
    JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(args.thisv().toObjectOrNull());
    cpNearestPointQueryInfo* info = (cpNearestPointQueryInfo*) proxy->handle;
    info->d = args.get(0).toDouble();
    return true;
}

JSClass* JSB_cpNearestPointQueryInfo_class = NULL;
JSObject* JSB_cpNearestPointQueryInfo_object = NULL;

// Destructor
void JSB_cpNearestPointQueryInfo_finalize(JSFreeOp *fop, JSObject *jsthis)
{
    struct jsb_c_proxy_s *proxy = jsb_get_c_proxy_for_jsobject(jsthis);
    if( proxy ) {
        CCLOGINFO("jsbindings: finalizing JS object %p (cpSegmentQueryInfo), handle: %p", jsthis, proxy->handle);

        jsb_del_jsobject_for_proxy(proxy->handle);
        if(proxy->flags == JSB_C_FLAG_CALL_FREE)
            delete ( (cpNearestPointQueryInfo*)proxy->handle);
        jsb_del_c_proxy_for_jsobject(jsthis);
    } else {
        CCLOGINFO("jsbindings: finalizing uninitialized JS object %p (cpSegmentQueryInfo)", jsthis);
    }
}

void JSB_cpNearestPointQueryInfo_createClass(JSContext *cx, JS::HandleObject globalObj, const char* name )
{
    JSB_cpNearestPointQueryInfo_class = (JSClass *)calloc(1, sizeof(JSClass));
    JSB_cpNearestPointQueryInfo_class->name = name;
    JSB_cpNearestPointQueryInfo_class->addProperty = JS_PropertyStub;
    JSB_cpNearestPointQueryInfo_class->delProperty = JS_DeletePropertyStub;
    JSB_cpNearestPointQueryInfo_class->getProperty = JS_PropertyStub;
    JSB_cpNearestPointQueryInfo_class->setProperty = JS_StrictPropertyStub;
    JSB_cpNearestPointQueryInfo_class->enumerate = JS_EnumerateStub;
    JSB_cpNearestPointQueryInfo_class->resolve = JS_ResolveStub;
    JSB_cpNearestPointQueryInfo_class->convert = JS_ConvertStub;
    JSB_cpNearestPointQueryInfo_class->finalize = JSB_cpNearestPointQueryInfo_finalize;
    JSB_cpNearestPointQueryInfo_class->flags = JSCLASS_HAS_PRIVATE;

    static JSPropertySpec properties[] = {
        JS_PSGS("shape", js_get_cpNearestPointQueryInfo_shape, js_set_cpNearestPointQueryInfo_shape, JSPROP_ENUMERATE | JSPROP_PERMANENT),
        JS_PSGS("p", js_get_cpNearestPointQueryInfo_p, js_set_cpNearestPointQueryInfo_p, JSPROP_ENUMERATE | JSPROP_PERMANENT),
        JS_PSGS("d", js_get_cpNearestPointQueryInfo_d, js_set_cpNearestPointQueryInfo_d, JSPROP_ENUMERATE | JSPROP_PERMANENT),
        JS_PS_END
    };
    static JSFunctionSpec funcs[] = {
        JS_FS_END
    };
    static JSFunctionSpec st_funcs[] = {
        JS_FS_END
    };

    JSB_cpNearestPointQueryInfo_object = JS_InitClass(cx, globalObj, JS::NullPtr(), JSB_cpNearestPointQueryInfo_class, NULL,0,properties,funcs,NULL,st_funcs);
}
#endif // JSB_INCLUDE_CHIPMUNK

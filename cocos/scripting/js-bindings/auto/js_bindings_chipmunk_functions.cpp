/*
* AUTOGENERATED FILE. DO NOT EDIT IT
* Generated by "generate_jsb.py -c chipmunk_jsb.ini" on 2016-02-23
* Script version: v0.10
*/
#include "scripting/js-bindings/manual/js_bindings_config.h"
#ifdef JSB_INCLUDE_CHIPMUNK

#include "scripting/js-bindings/manual/chipmunk/js_bindings_chipmunk_manual.h"

#include "jsfriendapi.h"
#include "scripting/js-bindings/manual/js_bindings_config.h"
#include "scripting/js-bindings/manual/js_manual_conversions.h"
#include "scripting/js-bindings/auto/js_bindings_chipmunk_functions.h"

// Arguments: cpArbiter*, cpSpace*
// Ret value: cpBool
bool JSB_cpArbiterCallWildcardBeginA(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpArbiter* arg0; cpSpace* arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpArbiterCallWildcardBeginA((cpArbiter*)arg0 , (cpSpace*)arg1  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpArbiter*, cpSpace*
// Ret value: cpBool
bool JSB_cpArbiterCallWildcardBeginB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpArbiter* arg0; cpSpace* arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpArbiterCallWildcardBeginB((cpArbiter*)arg0 , (cpSpace*)arg1  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpArbiter*, cpSpace*
// Ret value: void
bool JSB_cpArbiterCallWildcardPostSolveA(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpArbiter* arg0; cpSpace* arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpArbiterCallWildcardPostSolveA((cpArbiter*)arg0 , (cpSpace*)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpArbiter*, cpSpace*
// Ret value: void
bool JSB_cpArbiterCallWildcardPostSolveB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpArbiter* arg0; cpSpace* arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpArbiterCallWildcardPostSolveB((cpArbiter*)arg0 , (cpSpace*)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpArbiter*, cpSpace*
// Ret value: cpBool
bool JSB_cpArbiterCallWildcardPreSolveA(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpArbiter* arg0; cpSpace* arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpArbiterCallWildcardPreSolveA((cpArbiter*)arg0 , (cpSpace*)arg1  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpArbiter*, cpSpace*
// Ret value: cpBool
bool JSB_cpArbiterCallWildcardPreSolveB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpArbiter* arg0; cpSpace* arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpArbiterCallWildcardPreSolveB((cpArbiter*)arg0 , (cpSpace*)arg1  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpArbiter*, cpSpace*
// Ret value: void
bool JSB_cpArbiterCallWildcardSeparateA(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpArbiter* arg0; cpSpace* arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpArbiterCallWildcardSeparateA((cpArbiter*)arg0 , (cpSpace*)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpArbiter*, cpSpace*
// Ret value: void
bool JSB_cpArbiterCallWildcardSeparateB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpArbiter* arg0; cpSpace* arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpArbiterCallWildcardSeparateB((cpArbiter*)arg0 , (cpSpace*)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpArbiter*
// Ret value: int
bool JSB_cpArbiterGetCount(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpArbiter* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	int ret_val;

	ret_val = cpArbiterGetCount((cpArbiter*)arg0  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpArbiter*, int
// Ret value: cpFloat
bool JSB_cpArbiterGetDepth(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpArbiter* arg0; int32_t arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_int32( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpArbiterGetDepth((cpArbiter*)arg0 , (int)arg1  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpArbiter*
// Ret value: cpFloat
bool JSB_cpArbiterGetFriction(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpArbiter* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpArbiterGetFriction((cpArbiter*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpArbiter*
// Ret value: cpVect
bool JSB_cpArbiterGetNormal(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpArbiter* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpArbiterGetNormal((cpArbiter*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpArbiter*, int
// Ret value: cpVect
bool JSB_cpArbiterGetPointA(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpArbiter* arg0; int32_t arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_int32( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpArbiterGetPointA((cpArbiter*)arg0 , (int)arg1  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpArbiter*, int
// Ret value: cpVect
bool JSB_cpArbiterGetPointB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpArbiter* arg0; int32_t arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_int32( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpArbiterGetPointB((cpArbiter*)arg0 , (int)arg1  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpArbiter*
// Ret value: cpFloat
bool JSB_cpArbiterGetRestitution(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpArbiter* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpArbiterGetRestitution((cpArbiter*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpArbiter*
// Ret value: cpVect
bool JSB_cpArbiterGetSurfaceVelocity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpArbiter* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpArbiterGetSurfaceVelocity((cpArbiter*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpArbiter*
// Ret value: cpBool
bool JSB_cpArbiterIgnore(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpArbiter* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpArbiterIgnore((cpArbiter*)arg0  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpArbiter*
// Ret value: cpBool
bool JSB_cpArbiterIsFirstContact(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpArbiter* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpArbiterIsFirstContact((cpArbiter*)arg0  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpArbiter*
// Ret value: cpBool
bool JSB_cpArbiterIsRemoval(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpArbiter* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpArbiterIsRemoval((cpArbiter*)arg0  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpArbiter*, cpFloat
// Ret value: void
bool JSB_cpArbiterSetFriction(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpArbiter* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpArbiterSetFriction((cpArbiter*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpArbiter*, cpFloat
// Ret value: void
bool JSB_cpArbiterSetRestitution(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpArbiter* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpArbiterSetRestitution((cpArbiter*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpArbiter*, cpVect
// Ret value: void
bool JSB_cpArbiterSetSurfaceVelocity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpArbiter* arg0; cpVect arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpArbiterSetSurfaceVelocity((cpArbiter*)arg0 , (cpVect)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpArbiter*
// Ret value: cpVect
bool JSB_cpArbiterTotalImpulse(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpArbiter* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpArbiterTotalImpulse((cpArbiter*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpArbiter*
// Ret value: cpFloat
bool JSB_cpArbiterTotalKE(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpArbiter* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpArbiterTotalKE((cpArbiter*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpFloat, cpFloat
// Ret value: cpFloat
bool JSB_cpAreaForCircle(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	double arg0; double arg1; 

	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpAreaForCircle((cpFloat)arg0 , (cpFloat)arg1  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpVect, cpVect, cpFloat
// Ret value: cpFloat
bool JSB_cpAreaForSegment(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; cpVect arg1; double arg2; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpAreaForSegment((cpVect)arg0 , (cpVect)arg1 , (cpFloat)arg2  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpBB
// Ret value: cpFloat
bool JSB_cpBBArea(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBB arg0; 

	ok &= jsval_to_cpBB( cx, args.get(arg_idx++), (cpBB*) &arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpBBArea((cpBB)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpBB
// Ret value: cpVect
bool JSB_cpBBCenter(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBB arg0; 

	ok &= jsval_to_cpBB( cx, args.get(arg_idx++), (cpBB*) &arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpBBCenter((cpBB)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpBB, cpVect
// Ret value: cpVect
bool JSB_cpBBClampVect(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBB arg0; cpVect arg1; 

	ok &= jsval_to_cpBB( cx, args.get(arg_idx++), (cpBB*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpBBClampVect((cpBB)arg0 , (cpVect)arg1  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpBB, cpBB
// Ret value: cpBool
bool JSB_cpBBContainsBB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBB arg0; cpBB arg1; 

	ok &= jsval_to_cpBB( cx, args.get(arg_idx++), (cpBB*) &arg0 );
	ok &= jsval_to_cpBB( cx, args.get(arg_idx++), (cpBB*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpBBContainsBB((cpBB)arg0 , (cpBB)arg1  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpBB, cpVect
// Ret value: cpBool
bool JSB_cpBBContainsVect(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBB arg0; cpVect arg1; 

	ok &= jsval_to_cpBB( cx, args.get(arg_idx++), (cpBB*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpBBContainsVect((cpBB)arg0 , (cpVect)arg1  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpBB, cpVect
// Ret value: cpBB
bool JSB_cpBBExpand(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBB arg0; cpVect arg1; 

	ok &= jsval_to_cpBB( cx, args.get(arg_idx++), (cpBB*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBB ret_val;

	ret_val = cpBBExpand((cpBB)arg0 , (cpVect)arg1  );

	args.rval().set(cpBB_to_jsval( cx, (cpBB)ret_val ));

	return true;
}

// Arguments: cpBB, cpBB
// Ret value: cpBool
bool JSB_cpBBIntersects(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBB arg0; cpBB arg1; 

	ok &= jsval_to_cpBB( cx, args.get(arg_idx++), (cpBB*) &arg0 );
	ok &= jsval_to_cpBB( cx, args.get(arg_idx++), (cpBB*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpBBIntersects((cpBB)arg0 , (cpBB)arg1  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpBB, cpVect, cpVect
// Ret value: cpBool
bool JSB_cpBBIntersectsSegment(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBB arg0; cpVect arg1; cpVect arg2; 

	ok &= jsval_to_cpBB( cx, args.get(arg_idx++), (cpBB*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpBBIntersectsSegment((cpBB)arg0 , (cpVect)arg1 , (cpVect)arg2  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpBB, cpBB
// Ret value: cpBB
bool JSB_cpBBMerge(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBB arg0; cpBB arg1; 

	ok &= jsval_to_cpBB( cx, args.get(arg_idx++), (cpBB*) &arg0 );
	ok &= jsval_to_cpBB( cx, args.get(arg_idx++), (cpBB*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBB ret_val;

	ret_val = cpBBMerge((cpBB)arg0 , (cpBB)arg1  );

	args.rval().set(cpBB_to_jsval( cx, (cpBB)ret_val ));

	return true;
}

// Arguments: cpBB, cpBB
// Ret value: cpFloat
bool JSB_cpBBMergedArea(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBB arg0; cpBB arg1; 

	ok &= jsval_to_cpBB( cx, args.get(arg_idx++), (cpBB*) &arg0 );
	ok &= jsval_to_cpBB( cx, args.get(arg_idx++), (cpBB*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpBBMergedArea((cpBB)arg0 , (cpBB)arg1  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpFloat, cpFloat, cpFloat, cpFloat
// Ret value: cpBB
bool JSB_cpBBNew(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 4, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	double arg0; double arg1; double arg2; double arg3; 

	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg3 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBB ret_val;

	ret_val = cpBBNew((cpFloat)arg0 , (cpFloat)arg1 , (cpFloat)arg2 , (cpFloat)arg3  );

	args.rval().set(cpBB_to_jsval( cx, (cpBB)ret_val ));

	return true;
}

// Arguments: cpVect, cpFloat
// Ret value: cpBB
bool JSB_cpBBNewForCircle(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; double arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBB ret_val;

	ret_val = cpBBNewForCircle((cpVect)arg0 , (cpFloat)arg1  );

	args.rval().set(cpBB_to_jsval( cx, (cpBB)ret_val ));

	return true;
}

// Arguments: cpVect, cpFloat, cpFloat
// Ret value: cpBB
bool JSB_cpBBNewForExtents(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; double arg1; double arg2; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBB ret_val;

	ret_val = cpBBNewForExtents((cpVect)arg0 , (cpFloat)arg1 , (cpFloat)arg2  );

	args.rval().set(cpBB_to_jsval( cx, (cpBB)ret_val ));

	return true;
}

// Arguments: cpBB, cpVect
// Ret value: cpBB
bool JSB_cpBBOffset(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBB arg0; cpVect arg1; 

	ok &= jsval_to_cpBB( cx, args.get(arg_idx++), (cpBB*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBB ret_val;

	ret_val = cpBBOffset((cpBB)arg0 , (cpVect)arg1  );

	args.rval().set(cpBB_to_jsval( cx, (cpBB)ret_val ));

	return true;
}

// Arguments: cpBB, cpVect, cpVect
// Ret value: cpFloat
bool JSB_cpBBSegmentQuery(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBB arg0; cpVect arg1; cpVect arg2; 

	ok &= jsval_to_cpBB( cx, args.get(arg_idx++), (cpBB*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpBBSegmentQuery((cpBB)arg0 , (cpVect)arg1 , (cpVect)arg2  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpBB, cpVect
// Ret value: cpVect
bool JSB_cpBBWrapVect(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBB arg0; cpVect arg1; 

	ok &= jsval_to_cpBB( cx, args.get(arg_idx++), (cpBB*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpBBWrapVect((cpBB)arg0 , (cpVect)arg1  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpBody*
// Ret value: void
bool JSB_cpBodyActivate(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodyActivate((cpBody*)arg0  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpBody*, cpShape*
// Ret value: void
bool JSB_cpBodyActivateStatic(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpShape* arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodyActivateStatic((cpBody*)arg0 , (cpShape*)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpBody*, cpVect, cpVect
// Ret value: void
bool JSB_cpBodyApplyForceAtLocalPoint(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpVect arg1; cpVect arg2; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodyApplyForceAtLocalPoint((cpBody*)arg0 , (cpVect)arg1 , (cpVect)arg2  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpBody*, cpVect, cpVect
// Ret value: void
bool JSB_cpBodyApplyForceAtWorldPoint(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpVect arg1; cpVect arg2; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodyApplyForceAtWorldPoint((cpBody*)arg0 , (cpVect)arg1 , (cpVect)arg2  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpBody*, cpVect, cpVect
// Ret value: void
bool JSB_cpBodyApplyImpulseAtLocalPoint(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpVect arg1; cpVect arg2; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodyApplyImpulseAtLocalPoint((cpBody*)arg0 , (cpVect)arg1 , (cpVect)arg2  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpBody*, cpVect, cpVect
// Ret value: void
bool JSB_cpBodyApplyImpulseAtWorldPoint(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpVect arg1; cpVect arg2; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodyApplyImpulseAtWorldPoint((cpBody*)arg0 , (cpVect)arg1 , (cpVect)arg2  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpBody*
// Ret value: void
bool JSB_cpBodyDestroy(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodyDestroy((cpBody*)arg0  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpBody*
// Ret value: void
bool JSB_cpBodyFree(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodyFree((cpBody*)arg0  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpBody*
// Ret value: cpFloat
bool JSB_cpBodyGetAngle(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpBodyGetAngle((cpBody*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpBody*
// Ret value: cpFloat
bool JSB_cpBodyGetAngularVelocity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpBodyGetAngularVelocity((cpBody*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpBody*
// Ret value: cpVect
bool JSB_cpBodyGetCenterOfGravity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpBodyGetCenterOfGravity((cpBody*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpBody*
// Ret value: cpVect
bool JSB_cpBodyGetForce(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpBodyGetForce((cpBody*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpBody*
// Ret value: cpFloat
bool JSB_cpBodyGetMass(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpBodyGetMass((cpBody*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpBody*
// Ret value: cpFloat
bool JSB_cpBodyGetMoment(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpBodyGetMoment((cpBody*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpBody*
// Ret value: cpVect
bool JSB_cpBodyGetPosition(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpBodyGetPosition((cpBody*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpBody*
// Ret value: cpVect
bool JSB_cpBodyGetRotation(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpBodyGetRotation((cpBody*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpBody*
// Ret value: cpSpace*
bool JSB_cpBodyGetSpace(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpSpace* ret_val;

	ret_val = cpBodyGetSpace((cpBody*)arg0  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpBody*
// Ret value: cpFloat
bool JSB_cpBodyGetTorque(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpBodyGetTorque((cpBody*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpBody*
// Ret value: cpBodyType
bool JSB_cpBodyGetType(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBodyType ret_val;

	ret_val = cpBodyGetType((cpBody*)arg0  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpBody*
// Ret value: cpVect
bool JSB_cpBodyGetVelocity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpBodyGetVelocity((cpBody*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpBody*, cpVect
// Ret value: cpVect
bool JSB_cpBodyGetVelocityAtLocalPoint(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpVect arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpBodyGetVelocityAtLocalPoint((cpBody*)arg0 , (cpVect)arg1  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpBody*, cpVect
// Ret value: cpVect
bool JSB_cpBodyGetVelocityAtWorldPoint(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpVect arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpBodyGetVelocityAtWorldPoint((cpBody*)arg0 , (cpVect)arg1  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpBody*, cpFloat, cpFloat
// Ret value: cpBody*
bool JSB_cpBodyInit(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; double arg1; double arg2; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBody* ret_val;

	ret_val = cpBodyInit((cpBody*)arg0 , (cpFloat)arg1 , (cpFloat)arg2  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpBody*
// Ret value: cpBool
bool JSB_cpBodyIsSleeping(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpBodyIsSleeping((cpBody*)arg0  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpBody*
// Ret value: cpFloat
bool JSB_cpBodyKineticEnergy(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpBodyKineticEnergy((cpBody*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpBody*, cpVect
// Ret value: cpVect
bool JSB_cpBodyLocalToWorld(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpVect arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpBodyLocalToWorld((cpBody*)arg0 , (cpVect)arg1  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpFloat, cpFloat
// Ret value: cpBody*
bool JSB_cpBodyNew(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	double arg0; double arg1; 

	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBody* ret_val;

	ret_val = cpBodyNew((cpFloat)arg0 , (cpFloat)arg1  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: 
// Ret value: cpBody*
bool JSB_cpBodyNewKinematic(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
	cpBody* ret_val;

	ret_val = cpBodyNewKinematic( );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: 
// Ret value: cpBody*
bool JSB_cpBodyNewStatic(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
	cpBody* ret_val;

	ret_val = cpBodyNewStatic( );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpBody*, cpFloat
// Ret value: void
bool JSB_cpBodySetAngle(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodySetAngle((cpBody*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpBody*, cpFloat
// Ret value: void
bool JSB_cpBodySetAngularVelocity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodySetAngularVelocity((cpBody*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpBody*, cpVect
// Ret value: void
bool JSB_cpBodySetCenterOfGravity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpVect arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodySetCenterOfGravity((cpBody*)arg0 , (cpVect)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpBody*, cpVect
// Ret value: void
bool JSB_cpBodySetForce(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpVect arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodySetForce((cpBody*)arg0 , (cpVect)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpBody*, cpFloat
// Ret value: void
bool JSB_cpBodySetMass(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodySetMass((cpBody*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpBody*, cpFloat
// Ret value: void
bool JSB_cpBodySetMoment(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodySetMoment((cpBody*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpBody*, cpVect
// Ret value: void
bool JSB_cpBodySetPosition(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpVect arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodySetPosition((cpBody*)arg0 , (cpVect)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpBody*, cpFloat
// Ret value: void
bool JSB_cpBodySetTorque(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodySetTorque((cpBody*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpBody*, cpBodyType
// Ret value: void
bool JSB_cpBodySetType(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; int32_t arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_int32( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodySetType((cpBody*)arg0 , (cpBodyType)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpBody*, cpVect
// Ret value: void
bool JSB_cpBodySetVelocity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpVect arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodySetVelocity((cpBody*)arg0 , (cpVect)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpBody*
// Ret value: void
bool JSB_cpBodySleep(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodySleep((cpBody*)arg0  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpBody*, cpBody*
// Ret value: void
bool JSB_cpBodySleepWithGroup(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpBody* arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodySleepWithGroup((cpBody*)arg0 , (cpBody*)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpBody*, cpFloat
// Ret value: void
bool JSB_cpBodyUpdatePosition(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodyUpdatePosition((cpBody*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpBody*, cpVect, cpFloat, cpFloat
// Ret value: void
bool JSB_cpBodyUpdateVelocity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 4, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpVect arg1; double arg2; double arg3; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg3 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpBodyUpdateVelocity((cpBody*)arg0 , (cpVect)arg1 , (cpFloat)arg2 , (cpFloat)arg3  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpBody*, cpVect
// Ret value: cpVect
bool JSB_cpBodyWorldToLocal(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpVect arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpBodyWorldToLocal((cpBody*)arg0 , (cpVect)arg1  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpBody*, cpFloat, cpFloat, cpFloat
// Ret value: cpShape*
bool JSB_cpBoxShapeNew(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 4, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; double arg1; double arg2; double arg3; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg3 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpShape* ret_val;

	ret_val = cpBoxShapeNew((cpBody*)arg0 , (cpFloat)arg1 , (cpFloat)arg2 , (cpFloat)arg3  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpBody*, cpBB, cpFloat
// Ret value: cpShape*
bool JSB_cpBoxShapeNew2(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpBB arg1; double arg2; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpBB( cx, args.get(arg_idx++), (cpBB*) &arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpShape* ret_val;

	ret_val = cpBoxShapeNew2((cpBody*)arg0 , (cpBB)arg1 , (cpFloat)arg2  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpShape*
// Ret value: cpVect
bool JSB_cpCircleShapeGetOffset(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpCircleShapeGetOffset((cpShape*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpShape*
// Ret value: cpFloat
bool JSB_cpCircleShapeGetRadius(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpCircleShapeGetRadius((cpShape*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpBody*, cpFloat, cpVect
// Ret value: cpShape*
bool JSB_cpCircleShapeNew(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; double arg1; cpVect arg2; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpShape* ret_val;

	ret_val = cpCircleShapeNew((cpBody*)arg0 , (cpFloat)arg1 , (cpVect)arg2  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpConstraint*
// Ret value: void
bool JSB_cpConstraintDestroy(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpConstraintDestroy((cpConstraint*)arg0  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*
// Ret value: void
bool JSB_cpConstraintFree(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpConstraintFree((cpConstraint*)arg0  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpBody*
bool JSB_cpConstraintGetBodyA(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBody* ret_val;

	ret_val = cpConstraintGetBodyA((cpConstraint*)arg0  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpBody*
bool JSB_cpConstraintGetBodyB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBody* ret_val;

	ret_val = cpConstraintGetBodyB((cpConstraint*)arg0  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpBool
bool JSB_cpConstraintGetCollideBodies(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpConstraintGetCollideBodies((cpConstraint*)arg0  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpFloat
bool JSB_cpConstraintGetErrorBias(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpConstraintGetErrorBias((cpConstraint*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpFloat
bool JSB_cpConstraintGetImpulse(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpConstraintGetImpulse((cpConstraint*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpFloat
bool JSB_cpConstraintGetMaxBias(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpConstraintGetMaxBias((cpConstraint*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpFloat
bool JSB_cpConstraintGetMaxForce(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpConstraintGetMaxForce((cpConstraint*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpSpace*
bool JSB_cpConstraintGetSpace(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpSpace* ret_val;

	ret_val = cpConstraintGetSpace((cpConstraint*)arg0  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpBool
bool JSB_cpConstraintIsDampedRotarySpring(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpConstraintIsDampedRotarySpring((cpConstraint*)arg0  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpBool
bool JSB_cpConstraintIsDampedSpring(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpConstraintIsDampedSpring((cpConstraint*)arg0  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpBool
bool JSB_cpConstraintIsGearJoint(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpConstraintIsGearJoint((cpConstraint*)arg0  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpBool
bool JSB_cpConstraintIsGrooveJoint(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpConstraintIsGrooveJoint((cpConstraint*)arg0  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpBool
bool JSB_cpConstraintIsPinJoint(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpConstraintIsPinJoint((cpConstraint*)arg0  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpBool
bool JSB_cpConstraintIsPivotJoint(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpConstraintIsPivotJoint((cpConstraint*)arg0  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpBool
bool JSB_cpConstraintIsRatchetJoint(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpConstraintIsRatchetJoint((cpConstraint*)arg0  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpBool
bool JSB_cpConstraintIsRotaryLimitJoint(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpConstraintIsRotaryLimitJoint((cpConstraint*)arg0  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpBool
bool JSB_cpConstraintIsSimpleMotor(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpConstraintIsSimpleMotor((cpConstraint*)arg0  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpBool
bool JSB_cpConstraintIsSlideJoint(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpConstraintIsSlideJoint((cpConstraint*)arg0  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpConstraint*, cpBool
// Ret value: void
bool JSB_cpConstraintSetCollideBodies(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; uint16_t arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_uint16( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpConstraintSetCollideBodies((cpConstraint*)arg0 , (cpBool)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*, cpFloat
// Ret value: void
bool JSB_cpConstraintSetErrorBias(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpConstraintSetErrorBias((cpConstraint*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*, cpFloat
// Ret value: void
bool JSB_cpConstraintSetMaxBias(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpConstraintSetMaxBias((cpConstraint*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*, cpFloat
// Ret value: void
bool JSB_cpConstraintSetMaxForce(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpConstraintSetMaxForce((cpConstraint*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpFloat
bool JSB_cpDampedRotarySpringGetDamping(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpDampedRotarySpringGetDamping((cpConstraint*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpFloat
bool JSB_cpDampedRotarySpringGetRestAngle(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpDampedRotarySpringGetRestAngle((cpConstraint*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpFloat
bool JSB_cpDampedRotarySpringGetStiffness(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpDampedRotarySpringGetStiffness((cpConstraint*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpBody*, cpBody*, cpFloat, cpFloat, cpFloat
// Ret value: cpConstraint*
bool JSB_cpDampedRotarySpringNew(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 5, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpBody* arg1; double arg2; double arg3; double arg4; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg3 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg4 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpConstraint* ret_val;

	ret_val = cpDampedRotarySpringNew((cpBody*)arg0 , (cpBody*)arg1 , (cpFloat)arg2 , (cpFloat)arg3 , (cpFloat)arg4  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpConstraint*, cpFloat
// Ret value: void
bool JSB_cpDampedRotarySpringSetDamping(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpDampedRotarySpringSetDamping((cpConstraint*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*, cpFloat
// Ret value: void
bool JSB_cpDampedRotarySpringSetRestAngle(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpDampedRotarySpringSetRestAngle((cpConstraint*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*, cpFloat
// Ret value: void
bool JSB_cpDampedRotarySpringSetStiffness(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpDampedRotarySpringSetStiffness((cpConstraint*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpVect
bool JSB_cpDampedSpringGetAnchorA(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpDampedSpringGetAnchorA((cpConstraint*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpVect
bool JSB_cpDampedSpringGetAnchorB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpDampedSpringGetAnchorB((cpConstraint*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpFloat
bool JSB_cpDampedSpringGetDamping(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpDampedSpringGetDamping((cpConstraint*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpFloat
bool JSB_cpDampedSpringGetRestLength(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpDampedSpringGetRestLength((cpConstraint*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpFloat
bool JSB_cpDampedSpringGetStiffness(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpDampedSpringGetStiffness((cpConstraint*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpBody*, cpBody*, cpVect, cpVect, cpFloat, cpFloat, cpFloat
// Ret value: cpConstraint*
bool JSB_cpDampedSpringNew(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 7, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpBody* arg1; cpVect arg2; cpVect arg3; double arg4; double arg5; double arg6; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg3 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg4 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg5 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg6 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpConstraint* ret_val;

	ret_val = cpDampedSpringNew((cpBody*)arg0 , (cpBody*)arg1 , (cpVect)arg2 , (cpVect)arg3 , (cpFloat)arg4 , (cpFloat)arg5 , (cpFloat)arg6  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpConstraint*, cpVect
// Ret value: void
bool JSB_cpDampedSpringSetAnchorA(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; cpVect arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpDampedSpringSetAnchorA((cpConstraint*)arg0 , (cpVect)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*, cpVect
// Ret value: void
bool JSB_cpDampedSpringSetAnchorB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; cpVect arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpDampedSpringSetAnchorB((cpConstraint*)arg0 , (cpVect)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*, cpFloat
// Ret value: void
bool JSB_cpDampedSpringSetDamping(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpDampedSpringSetDamping((cpConstraint*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*, cpFloat
// Ret value: void
bool JSB_cpDampedSpringSetRestLength(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpDampedSpringSetRestLength((cpConstraint*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*, cpFloat
// Ret value: void
bool JSB_cpDampedSpringSetStiffness(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpDampedSpringSetStiffness((cpConstraint*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpFloat
bool JSB_cpGearJointGetPhase(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpGearJointGetPhase((cpConstraint*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpFloat
bool JSB_cpGearJointGetRatio(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpGearJointGetRatio((cpConstraint*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpBody*, cpBody*, cpFloat, cpFloat
// Ret value: cpConstraint*
bool JSB_cpGearJointNew(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 4, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpBody* arg1; double arg2; double arg3; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg3 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpConstraint* ret_val;

	ret_val = cpGearJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpFloat)arg2 , (cpFloat)arg3  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpConstraint*, cpFloat
// Ret value: void
bool JSB_cpGearJointSetPhase(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpGearJointSetPhase((cpConstraint*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*, cpFloat
// Ret value: void
bool JSB_cpGearJointSetRatio(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpGearJointSetRatio((cpConstraint*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpVect
bool JSB_cpGrooveJointGetAnchorB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpGrooveJointGetAnchorB((cpConstraint*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpVect
bool JSB_cpGrooveJointGetGrooveA(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpGrooveJointGetGrooveA((cpConstraint*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpVect
bool JSB_cpGrooveJointGetGrooveB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpGrooveJointGetGrooveB((cpConstraint*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpBody*, cpBody*, cpVect, cpVect, cpVect
// Ret value: cpConstraint*
bool JSB_cpGrooveJointNew(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 5, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpBody* arg1; cpVect arg2; cpVect arg3; cpVect arg4; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg3 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg4 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpConstraint* ret_val;

	ret_val = cpGrooveJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpVect)arg2 , (cpVect)arg3 , (cpVect)arg4  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpConstraint*, cpVect
// Ret value: void
bool JSB_cpGrooveJointSetAnchorB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; cpVect arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpGrooveJointSetAnchorB((cpConstraint*)arg0 , (cpVect)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*, cpVect
// Ret value: void
bool JSB_cpGrooveJointSetGrooveA(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; cpVect arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpGrooveJointSetGrooveA((cpConstraint*)arg0 , (cpVect)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*, cpVect
// Ret value: void
bool JSB_cpGrooveJointSetGrooveB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; cpVect arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpGrooveJointSetGrooveB((cpConstraint*)arg0 , (cpVect)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: char*, char*, int, int, int, char*
// Ret value: void
bool JSB_cpMessage(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 6, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	const char* arg0; const char* arg1; int32_t arg2; int32_t arg3; int32_t arg4; const char* arg5; 

	ok &= jsval_to_charptr( cx, args.get(arg_idx++), &arg0 );
	ok &= jsval_to_charptr( cx, args.get(arg_idx++), &arg1 );
	ok &= jsval_to_int32( cx, args.get(arg_idx++), &arg2 );
	ok &= jsval_to_int32( cx, args.get(arg_idx++), &arg3 );
	ok &= jsval_to_int32( cx, args.get(arg_idx++), &arg4 );
	ok &= jsval_to_charptr( cx, args.get(arg_idx++), &arg5 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpMessage((char*)arg0 , (char*)arg1 , (int)arg2 , (int)arg3 , (int)arg4 , (char*)arg5  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpFloat, cpFloat, cpFloat
// Ret value: cpFloat
bool JSB_cpMomentForBox(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	double arg0; double arg1; double arg2; 

	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpMomentForBox((cpFloat)arg0 , (cpFloat)arg1 , (cpFloat)arg2  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpFloat, cpBB
// Ret value: cpFloat
bool JSB_cpMomentForBox2(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	double arg0; cpBB arg1; 

	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg0 );
	ok &= jsval_to_cpBB( cx, args.get(arg_idx++), (cpBB*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpMomentForBox2((cpFloat)arg0 , (cpBB)arg1  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpFloat, cpFloat, cpFloat, cpVect
// Ret value: cpFloat
bool JSB_cpMomentForCircle(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 4, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	double arg0; double arg1; double arg2; cpVect arg3; 

	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg3 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpMomentForCircle((cpFloat)arg0 , (cpFloat)arg1 , (cpFloat)arg2 , (cpVect)arg3  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpVect
bool JSB_cpPinJointGetAnchorA(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpPinJointGetAnchorA((cpConstraint*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpVect
bool JSB_cpPinJointGetAnchorB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpPinJointGetAnchorB((cpConstraint*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpFloat
bool JSB_cpPinJointGetDist(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpPinJointGetDist((cpConstraint*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpBody*, cpBody*, cpVect, cpVect
// Ret value: cpConstraint*
bool JSB_cpPinJointNew(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 4, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpBody* arg1; cpVect arg2; cpVect arg3; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg3 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpConstraint* ret_val;

	ret_val = cpPinJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpVect)arg2 , (cpVect)arg3  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpConstraint*, cpVect
// Ret value: void
bool JSB_cpPinJointSetAnchorA(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; cpVect arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpPinJointSetAnchorA((cpConstraint*)arg0 , (cpVect)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*, cpVect
// Ret value: void
bool JSB_cpPinJointSetAnchorB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; cpVect arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpPinJointSetAnchorB((cpConstraint*)arg0 , (cpVect)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*, cpFloat
// Ret value: void
bool JSB_cpPinJointSetDist(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpPinJointSetDist((cpConstraint*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpVect
bool JSB_cpPivotJointGetAnchorA(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpPivotJointGetAnchorA((cpConstraint*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpVect
bool JSB_cpPivotJointGetAnchorB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpPivotJointGetAnchorB((cpConstraint*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpBody*, cpBody*, cpVect
// Ret value: cpConstraint*
bool JSB_cpPivotJointNew(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpBody* arg1; cpVect arg2; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpConstraint* ret_val;

	ret_val = cpPivotJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpVect)arg2  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpBody*, cpBody*, cpVect, cpVect
// Ret value: cpConstraint*
bool JSB_cpPivotJointNew2(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 4, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpBody* arg1; cpVect arg2; cpVect arg3; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg3 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpConstraint* ret_val;

	ret_val = cpPivotJointNew2((cpBody*)arg0 , (cpBody*)arg1 , (cpVect)arg2 , (cpVect)arg3  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpConstraint*, cpVect
// Ret value: void
bool JSB_cpPivotJointSetAnchorA(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; cpVect arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpPivotJointSetAnchorA((cpConstraint*)arg0 , (cpVect)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*, cpVect
// Ret value: void
bool JSB_cpPivotJointSetAnchorB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; cpVect arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpPivotJointSetAnchorB((cpConstraint*)arg0 , (cpVect)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpShape*
// Ret value: int
bool JSB_cpPolyShapeGetCount(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	int ret_val;

	ret_val = cpPolyShapeGetCount((cpShape*)arg0  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpShape*
// Ret value: cpFloat
bool JSB_cpPolyShapeGetRadius(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpPolyShapeGetRadius((cpShape*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpShape*, int
// Ret value: cpVect
bool JSB_cpPolyShapeGetVert(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; int32_t arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_int32( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpPolyShapeGetVert((cpShape*)arg0 , (int)arg1  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpFloat
bool JSB_cpRatchetJointGetAngle(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpRatchetJointGetAngle((cpConstraint*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpFloat
bool JSB_cpRatchetJointGetPhase(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpRatchetJointGetPhase((cpConstraint*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpFloat
bool JSB_cpRatchetJointGetRatchet(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpRatchetJointGetRatchet((cpConstraint*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpBody*, cpBody*, cpFloat, cpFloat
// Ret value: cpConstraint*
bool JSB_cpRatchetJointNew(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 4, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpBody* arg1; double arg2; double arg3; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg3 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpConstraint* ret_val;

	ret_val = cpRatchetJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpFloat)arg2 , (cpFloat)arg3  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpConstraint*, cpFloat
// Ret value: void
bool JSB_cpRatchetJointSetAngle(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpRatchetJointSetAngle((cpConstraint*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*, cpFloat
// Ret value: void
bool JSB_cpRatchetJointSetPhase(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpRatchetJointSetPhase((cpConstraint*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*, cpFloat
// Ret value: void
bool JSB_cpRatchetJointSetRatchet(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpRatchetJointSetRatchet((cpConstraint*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpFloat
bool JSB_cpRotaryLimitJointGetMax(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpRotaryLimitJointGetMax((cpConstraint*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpFloat
bool JSB_cpRotaryLimitJointGetMin(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpRotaryLimitJointGetMin((cpConstraint*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpBody*, cpBody*, cpFloat, cpFloat
// Ret value: cpConstraint*
bool JSB_cpRotaryLimitJointNew(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 4, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpBody* arg1; double arg2; double arg3; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg3 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpConstraint* ret_val;

	ret_val = cpRotaryLimitJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpFloat)arg2 , (cpFloat)arg3  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpConstraint*, cpFloat
// Ret value: void
bool JSB_cpRotaryLimitJointSetMax(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpRotaryLimitJointSetMax((cpConstraint*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*, cpFloat
// Ret value: void
bool JSB_cpRotaryLimitJointSetMin(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpRotaryLimitJointSetMin((cpConstraint*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpShape*
// Ret value: cpVect
bool JSB_cpSegmentShapeGetA(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpSegmentShapeGetA((cpShape*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpShape*
// Ret value: cpVect
bool JSB_cpSegmentShapeGetB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpSegmentShapeGetB((cpShape*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpShape*
// Ret value: cpVect
bool JSB_cpSegmentShapeGetNormal(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpSegmentShapeGetNormal((cpShape*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpShape*
// Ret value: cpFloat
bool JSB_cpSegmentShapeGetRadius(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpSegmentShapeGetRadius((cpShape*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpBody*, cpVect, cpVect, cpFloat
// Ret value: cpShape*
bool JSB_cpSegmentShapeNew(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 4, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpVect arg1; cpVect arg2; double arg3; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg3 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpShape* ret_val;

	ret_val = cpSegmentShapeNew((cpBody*)arg0 , (cpVect)arg1 , (cpVect)arg2 , (cpFloat)arg3  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpShape*, cpVect, cpVect
// Ret value: void
bool JSB_cpSegmentShapeSetNeighbors(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; cpVect arg1; cpVect arg2; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSegmentShapeSetNeighbors((cpShape*)arg0 , (cpVect)arg1 , (cpVect)arg2  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpShape*
// Ret value: cpBB
bool JSB_cpShapeCacheBB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBB ret_val;

	ret_val = cpShapeCacheBB((cpShape*)arg0  );

	args.rval().set(cpBB_to_jsval( cx, (cpBB)ret_val ));

	return true;
}

// Arguments: cpShape*
// Ret value: void
bool JSB_cpShapeDestroy(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpShapeDestroy((cpShape*)arg0  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpGroup, cpBitmask, cpBitmask
// Ret value: cpShapeFilter
bool JSB_cpShapeFilterNew(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpGroup arg0; uint32_t arg1; uint32_t arg2; 

	ok &= jsval_to_long( cx, args.get(arg_idx++), (long*) &arg0 );
	ok &= jsval_to_uint32( cx, args.get(arg_idx++), &arg1 );
	ok &= jsval_to_uint32( cx, args.get(arg_idx++), &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpShapeFilter ret_val;

	ret_val = cpShapeFilterNew((cpGroup)arg0 , (cpBitmask)arg1 , (cpBitmask)arg2  );

	args.rval().set(cpShapeFilter_to_jsval( cx, (cpShapeFilter)ret_val ));

	return true;
}

// Arguments: cpShape*
// Ret value: void
bool JSB_cpShapeFree(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpShapeFree((cpShape*)arg0  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpShape*
// Ret value: cpFloat
bool JSB_cpShapeGetArea(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpShapeGetArea((cpShape*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpShape*
// Ret value: cpBB
bool JSB_cpShapeGetBB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBB ret_val;

	ret_val = cpShapeGetBB((cpShape*)arg0  );

	args.rval().set(cpBB_to_jsval( cx, (cpBB)ret_val ));

	return true;
}

// Arguments: cpShape*
// Ret value: cpBody*
bool JSB_cpShapeGetBody(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBody* ret_val;

	ret_val = cpShapeGetBody((cpShape*)arg0  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpShape*
// Ret value: cpVect
bool JSB_cpShapeGetCenterOfGravity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpShapeGetCenterOfGravity((cpShape*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpShape*
// Ret value: cpCollisionType
bool JSB_cpShapeGetCollisionType(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpCollisionType ret_val;

	ret_val = cpShapeGetCollisionType((cpShape*)arg0  );

	args.rval().set(long_to_jsval( cx, (cpCollisionType)ret_val ));

	return true;
}

// Arguments: cpShape*
// Ret value: cpFloat
bool JSB_cpShapeGetDensity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpShapeGetDensity((cpShape*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpShape*
// Ret value: cpFloat
bool JSB_cpShapeGetElasticity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpShapeGetElasticity((cpShape*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpShape*
// Ret value: cpShapeFilter
bool JSB_cpShapeGetFilter(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpShapeFilter ret_val;

	ret_val = cpShapeGetFilter((cpShape*)arg0  );

	args.rval().set(cpShapeFilter_to_jsval( cx, (cpShapeFilter)ret_val ));

	return true;
}

// Arguments: cpShape*
// Ret value: cpFloat
bool JSB_cpShapeGetFriction(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpShapeGetFriction((cpShape*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpShape*
// Ret value: cpFloat
bool JSB_cpShapeGetMass(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpShapeGetMass((cpShape*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpShape*
// Ret value: cpFloat
bool JSB_cpShapeGetMoment(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpShapeGetMoment((cpShape*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpShape*
// Ret value: cpBool
bool JSB_cpShapeGetSensor(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpShapeGetSensor((cpShape*)arg0  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpShape*
// Ret value: cpSpace*
bool JSB_cpShapeGetSpace(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpSpace* ret_val;

	ret_val = cpShapeGetSpace((cpShape*)arg0  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpShape*
// Ret value: cpVect
bool JSB_cpShapeGetSurfaceVelocity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpShapeGetSurfaceVelocity((cpShape*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpShape*, cpBody*
// Ret value: void
bool JSB_cpShapeSetBody(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; cpBody* arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpShapeSetBody((cpShape*)arg0 , (cpBody*)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpShape*, cpCollisionType
// Ret value: void
bool JSB_cpShapeSetCollisionType(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; cpCollisionType arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_long( cx, args.get(arg_idx++), (long*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpShapeSetCollisionType((cpShape*)arg0 , (cpCollisionType)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpShape*, cpFloat
// Ret value: void
bool JSB_cpShapeSetDensity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpShapeSetDensity((cpShape*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpShape*, cpFloat
// Ret value: void
bool JSB_cpShapeSetElasticity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpShapeSetElasticity((cpShape*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpShape*, cpShapeFilter
// Ret value: void
bool JSB_cpShapeSetFilter(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; cpShapeFilter arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpShapeFilter( cx, args.get(arg_idx++), (cpShapeFilter*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpShapeSetFilter((cpShape*)arg0 , (cpShapeFilter)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpShape*, cpFloat
// Ret value: void
bool JSB_cpShapeSetFriction(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpShapeSetFriction((cpShape*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpShape*, cpFloat
// Ret value: void
bool JSB_cpShapeSetMass(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpShapeSetMass((cpShape*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpShape*, cpBool
// Ret value: void
bool JSB_cpShapeSetSensor(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; uint16_t arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_uint16( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpShapeSetSensor((cpShape*)arg0 , (cpBool)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpShape*, cpVect
// Ret value: void
bool JSB_cpShapeSetSurfaceVelocity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; cpVect arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpShapeSetSurfaceVelocity((cpShape*)arg0 , (cpVect)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpShape*, cpTransform
// Ret value: cpBB
bool JSB_cpShapeUpdate(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpShape* arg0; cpTransform arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpTransform( cx, args.get(arg_idx++), (cpTransform*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBB ret_val;

	ret_val = cpShapeUpdate((cpShape*)arg0 , (cpTransform)arg1  );

	args.rval().set(cpBB_to_jsval( cx, (cpBB)ret_val ));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpFloat
bool JSB_cpSimpleMotorGetRate(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpSimpleMotorGetRate((cpConstraint*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpBody*, cpBody*, cpFloat
// Ret value: cpConstraint*
bool JSB_cpSimpleMotorNew(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpBody* arg1; double arg2; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpConstraint* ret_val;

	ret_val = cpSimpleMotorNew((cpBody*)arg0 , (cpBody*)arg1 , (cpFloat)arg2  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpConstraint*, cpFloat
// Ret value: void
bool JSB_cpSimpleMotorSetRate(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSimpleMotorSetRate((cpConstraint*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpVect
bool JSB_cpSlideJointGetAnchorA(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpSlideJointGetAnchorA((cpConstraint*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpVect
bool JSB_cpSlideJointGetAnchorB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpSlideJointGetAnchorB((cpConstraint*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpFloat
bool JSB_cpSlideJointGetMax(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpSlideJointGetMax((cpConstraint*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpConstraint*
// Ret value: cpFloat
bool JSB_cpSlideJointGetMin(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpSlideJointGetMin((cpConstraint*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpBody*, cpBody*, cpVect, cpVect, cpFloat, cpFloat
// Ret value: cpConstraint*
bool JSB_cpSlideJointNew(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 6, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBody* arg0; cpBody* arg1; cpVect arg2; cpVect arg3; double arg4; double arg5; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg2 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg3 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg4 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg5 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpConstraint* ret_val;

	ret_val = cpSlideJointNew((cpBody*)arg0 , (cpBody*)arg1 , (cpVect)arg2 , (cpVect)arg3 , (cpFloat)arg4 , (cpFloat)arg5  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpConstraint*, cpVect
// Ret value: void
bool JSB_cpSlideJointSetAnchorA(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; cpVect arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSlideJointSetAnchorA((cpConstraint*)arg0 , (cpVect)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*, cpVect
// Ret value: void
bool JSB_cpSlideJointSetAnchorB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; cpVect arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSlideJointSetAnchorB((cpConstraint*)arg0 , (cpVect)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*, cpFloat
// Ret value: void
bool JSB_cpSlideJointSetMax(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSlideJointSetMax((cpConstraint*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpConstraint*, cpFloat
// Ret value: void
bool JSB_cpSlideJointSetMin(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpConstraint* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSlideJointSetMin((cpConstraint*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpSpace*, cpBody*
// Ret value: cpBody*
bool JSB_cpSpaceAddBody(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; cpBody* arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBody* ret_val;

	ret_val = cpSpaceAddBody((cpSpace*)arg0 , (cpBody*)arg1  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpSpace*, cpConstraint*
// Ret value: cpConstraint*
bool JSB_cpSpaceAddConstraint(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; cpConstraint* arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpConstraint* ret_val;

	ret_val = cpSpaceAddConstraint((cpSpace*)arg0 , (cpConstraint*)arg1  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpSpace*, cpShape*
// Ret value: cpShape*
bool JSB_cpSpaceAddShape(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; cpShape* arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpShape* ret_val;

	ret_val = cpSpaceAddShape((cpSpace*)arg0 , (cpShape*)arg1  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpSpace*, cpBody*
// Ret value: cpBool
bool JSB_cpSpaceContainsBody(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; cpBody* arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpSpaceContainsBody((cpSpace*)arg0 , (cpBody*)arg1  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpSpace*, cpConstraint*
// Ret value: cpBool
bool JSB_cpSpaceContainsConstraint(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; cpConstraint* arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpSpaceContainsConstraint((cpSpace*)arg0 , (cpConstraint*)arg1  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpSpace*, cpShape*
// Ret value: cpBool
bool JSB_cpSpaceContainsShape(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; cpShape* arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpSpaceContainsShape((cpSpace*)arg0 , (cpShape*)arg1  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpSpace*
// Ret value: void
bool JSB_cpSpaceDestroy(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSpaceDestroy((cpSpace*)arg0  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpSpace*
// Ret value: void
bool JSB_cpSpaceFree(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSpaceFree((cpSpace*)arg0  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpSpace*
// Ret value: cpFloat
bool JSB_cpSpaceGetCollisionBias(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpSpaceGetCollisionBias((cpSpace*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpSpace*
// Ret value: cpTimestamp
bool JSB_cpSpaceGetCollisionPersistence(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpTimestamp ret_val;

	ret_val = cpSpaceGetCollisionPersistence((cpSpace*)arg0  );

	args.rval().set(UINT_TO_JSVAL((uint32_t)ret_val));

	return true;
}

// Arguments: cpSpace*
// Ret value: cpFloat
bool JSB_cpSpaceGetCollisionSlop(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpSpaceGetCollisionSlop((cpSpace*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpSpace*
// Ret value: cpFloat
bool JSB_cpSpaceGetCurrentTimeStep(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpSpaceGetCurrentTimeStep((cpSpace*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpSpace*
// Ret value: cpFloat
bool JSB_cpSpaceGetDamping(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpSpaceGetDamping((cpSpace*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpSpace*
// Ret value: cpVect
bool JSB_cpSpaceGetGravity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpSpaceGetGravity((cpSpace*)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpSpace*
// Ret value: cpFloat
bool JSB_cpSpaceGetIdleSpeedThreshold(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpSpaceGetIdleSpeedThreshold((cpSpace*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpSpace*
// Ret value: int
bool JSB_cpSpaceGetIterations(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	int ret_val;

	ret_val = cpSpaceGetIterations((cpSpace*)arg0  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpSpace*
// Ret value: cpFloat
bool JSB_cpSpaceGetSleepTimeThreshold(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpSpaceGetSleepTimeThreshold((cpSpace*)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpSpace*
// Ret value: cpBody*
bool JSB_cpSpaceGetStaticBody(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBody* ret_val;

	ret_val = cpSpaceGetStaticBody((cpSpace*)arg0  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpSpace*
// Ret value: cpSpace*
bool JSB_cpSpaceInit(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpSpace* ret_val;

	ret_val = cpSpaceInit((cpSpace*)arg0  );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpSpace*
// Ret value: cpBool
bool JSB_cpSpaceIsLocked(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpSpaceIsLocked((cpSpace*)arg0  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: 
// Ret value: cpSpace*
bool JSB_cpSpaceNew(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 0, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);
	cpSpace* ret_val;

	ret_val = cpSpaceNew( );

	args.rval().set(opaque_to_jsval( cx, ret_val ));

	return true;
}

// Arguments: cpSpace*, cpShape*
// Ret value: void
bool JSB_cpSpaceReindexShape(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; cpShape* arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSpaceReindexShape((cpSpace*)arg0 , (cpShape*)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpSpace*, cpBody*
// Ret value: void
bool JSB_cpSpaceReindexShapesForBody(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; cpBody* arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSpaceReindexShapesForBody((cpSpace*)arg0 , (cpBody*)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpSpace*
// Ret value: void
bool JSB_cpSpaceReindexStatic(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSpaceReindexStatic((cpSpace*)arg0  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpSpace*, cpBody*
// Ret value: void
bool JSB_cpSpaceRemoveBody(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; cpBody* arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSpaceRemoveBody((cpSpace*)arg0 , (cpBody*)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpSpace*, cpConstraint*
// Ret value: void
bool JSB_cpSpaceRemoveConstraint(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; cpConstraint* arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSpaceRemoveConstraint((cpSpace*)arg0 , (cpConstraint*)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpSpace*, cpShape*
// Ret value: void
bool JSB_cpSpaceRemoveShape(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; cpShape* arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSpaceRemoveShape((cpSpace*)arg0 , (cpShape*)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpSpace*, cpFloat
// Ret value: void
bool JSB_cpSpaceSetCollisionBias(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSpaceSetCollisionBias((cpSpace*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpSpace*, cpTimestamp
// Ret value: void
bool JSB_cpSpaceSetCollisionPersistence(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; uint32_t arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_uint32( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSpaceSetCollisionPersistence((cpSpace*)arg0 , (cpTimestamp)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpSpace*, cpFloat
// Ret value: void
bool JSB_cpSpaceSetCollisionSlop(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSpaceSetCollisionSlop((cpSpace*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpSpace*, cpFloat
// Ret value: void
bool JSB_cpSpaceSetDamping(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSpaceSetDamping((cpSpace*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpSpace*, cpVect
// Ret value: void
bool JSB_cpSpaceSetGravity(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; cpVect arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSpaceSetGravity((cpSpace*)arg0 , (cpVect)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpSpace*, cpFloat
// Ret value: void
bool JSB_cpSpaceSetIdleSpeedThreshold(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSpaceSetIdleSpeedThreshold((cpSpace*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpSpace*, int
// Ret value: void
bool JSB_cpSpaceSetIterations(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; int32_t arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= jsval_to_int32( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSpaceSetIterations((cpSpace*)arg0 , (int)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpSpace*, cpFloat
// Ret value: void
bool JSB_cpSpaceSetSleepTimeThreshold(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSpaceSetSleepTimeThreshold((cpSpace*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpSpace*, cpFloat
// Ret value: void
bool JSB_cpSpaceStep(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; double arg1; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSpaceStep((cpSpace*)arg0 , (cpFloat)arg1  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpSpace*, cpFloat, int
// Ret value: void
bool JSB_cpSpaceUseSpatialHash(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpSpace* arg0; double arg1; int32_t arg2; 

	ok &= jsval_to_opaque( cx, args.get(arg_idx++), (void**)&arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	ok &= jsval_to_int32( cx, args.get(arg_idx++), &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");

	cpSpaceUseSpatialHash((cpSpace*)arg0 , (cpFloat)arg1 , (int)arg2  );

	args.rval().set(JSVAL_VOID);

	return true;
}

// Arguments: cpVect, cpVect, cpFloat
// Ret value: cpTransform
bool JSB_cpTransformAxialScale(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; cpVect arg1; double arg2; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpTransform ret_val;

	ret_val = cpTransformAxialScale((cpVect)arg0 , (cpVect)arg1 , (cpFloat)arg2  );

	args.rval().set(cpTransform_to_jsval( cx, (cpTransform)ret_val ));

	return true;
}

// Arguments: cpVect, cpVect
// Ret value: cpTransform
bool JSB_cpTransformBoneScale(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpTransform ret_val;

	ret_val = cpTransformBoneScale((cpVect)arg0 , (cpVect)arg1  );

	args.rval().set(cpTransform_to_jsval( cx, (cpTransform)ret_val ));

	return true;
}

// Arguments: cpTransform
// Ret value: cpTransform
bool JSB_cpTransformInverse(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpTransform arg0; 

	ok &= jsval_to_cpTransform( cx, args.get(arg_idx++), (cpTransform*) &arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpTransform ret_val;

	ret_val = cpTransformInverse((cpTransform)arg0  );

	args.rval().set(cpTransform_to_jsval( cx, (cpTransform)ret_val ));

	return true;
}

// Arguments: cpTransform, cpTransform
// Ret value: cpTransform
bool JSB_cpTransformMult(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpTransform arg0; cpTransform arg1; 

	ok &= jsval_to_cpTransform( cx, args.get(arg_idx++), (cpTransform*) &arg0 );
	ok &= jsval_to_cpTransform( cx, args.get(arg_idx++), (cpTransform*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpTransform ret_val;

	ret_val = cpTransformMult((cpTransform)arg0 , (cpTransform)arg1  );

	args.rval().set(cpTransform_to_jsval( cx, (cpTransform)ret_val ));

	return true;
}

// Arguments: cpFloat, cpFloat, cpFloat, cpFloat, cpFloat, cpFloat
// Ret value: cpTransform
bool JSB_cpTransformNew(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 6, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	double arg0; double arg1; double arg2; double arg3; double arg4; double arg5; 

	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg3 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg4 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg5 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpTransform ret_val;

	ret_val = cpTransformNew((cpFloat)arg0 , (cpFloat)arg1 , (cpFloat)arg2 , (cpFloat)arg3 , (cpFloat)arg4 , (cpFloat)arg5  );

	args.rval().set(cpTransform_to_jsval( cx, (cpTransform)ret_val ));

	return true;
}

// Arguments: cpFloat, cpFloat, cpFloat, cpFloat, cpFloat, cpFloat
// Ret value: cpTransform
bool JSB_cpTransformNewTranspose(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 6, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	double arg0; double arg1; double arg2; double arg3; double arg4; double arg5; 

	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg3 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg4 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg5 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpTransform ret_val;

	ret_val = cpTransformNewTranspose((cpFloat)arg0 , (cpFloat)arg1 , (cpFloat)arg2 , (cpFloat)arg3 , (cpFloat)arg4 , (cpFloat)arg5  );

	args.rval().set(cpTransform_to_jsval( cx, (cpTransform)ret_val ));

	return true;
}

// Arguments: cpBB
// Ret value: cpTransform
bool JSB_cpTransformOrtho(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpBB arg0; 

	ok &= jsval_to_cpBB( cx, args.get(arg_idx++), (cpBB*) &arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpTransform ret_val;

	ret_val = cpTransformOrtho((cpBB)arg0  );

	args.rval().set(cpTransform_to_jsval( cx, (cpTransform)ret_val ));

	return true;
}

// Arguments: cpTransform, cpVect
// Ret value: cpVect
bool JSB_cpTransformPoint(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpTransform arg0; cpVect arg1; 

	ok &= jsval_to_cpTransform( cx, args.get(arg_idx++), (cpTransform*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpTransformPoint((cpTransform)arg0 , (cpVect)arg1  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpVect, cpFloat
// Ret value: cpTransform
bool JSB_cpTransformRigid(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; double arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpTransform ret_val;

	ret_val = cpTransformRigid((cpVect)arg0 , (cpFloat)arg1  );

	args.rval().set(cpTransform_to_jsval( cx, (cpTransform)ret_val ));

	return true;
}

// Arguments: cpTransform
// Ret value: cpTransform
bool JSB_cpTransformRigidInverse(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpTransform arg0; 

	ok &= jsval_to_cpTransform( cx, args.get(arg_idx++), (cpTransform*) &arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpTransform ret_val;

	ret_val = cpTransformRigidInverse((cpTransform)arg0  );

	args.rval().set(cpTransform_to_jsval( cx, (cpTransform)ret_val ));

	return true;
}

// Arguments: cpFloat
// Ret value: cpTransform
bool JSB_cpTransformRotate(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	double arg0; 

	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpTransform ret_val;

	ret_val = cpTransformRotate((cpFloat)arg0  );

	args.rval().set(cpTransform_to_jsval( cx, (cpTransform)ret_val ));

	return true;
}

// Arguments: cpFloat, cpFloat
// Ret value: cpTransform
bool JSB_cpTransformScale(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	double arg0; double arg1; 

	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpTransform ret_val;

	ret_val = cpTransformScale((cpFloat)arg0 , (cpFloat)arg1  );

	args.rval().set(cpTransform_to_jsval( cx, (cpTransform)ret_val ));

	return true;
}

// Arguments: cpVect
// Ret value: cpTransform
bool JSB_cpTransformTranslate(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpTransform ret_val;

	ret_val = cpTransformTranslate((cpVect)arg0  );

	args.rval().set(cpTransform_to_jsval( cx, (cpTransform)ret_val ));

	return true;
}

// Arguments: cpTransform, cpVect
// Ret value: cpVect
bool JSB_cpTransformVect(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpTransform arg0; cpVect arg1; 

	ok &= jsval_to_cpTransform( cx, args.get(arg_idx++), (cpTransform*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpTransformVect((cpTransform)arg0 , (cpVect)arg1  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpTransform, cpTransform
// Ret value: cpTransform
bool JSB_cpTransformWrap(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpTransform arg0; cpTransform arg1; 

	ok &= jsval_to_cpTransform( cx, args.get(arg_idx++), (cpTransform*) &arg0 );
	ok &= jsval_to_cpTransform( cx, args.get(arg_idx++), (cpTransform*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpTransform ret_val;

	ret_val = cpTransformWrap((cpTransform)arg0 , (cpTransform)arg1  );

	args.rval().set(cpTransform_to_jsval( cx, (cpTransform)ret_val ));

	return true;
}

// Arguments: cpTransform, cpTransform
// Ret value: cpTransform
bool JSB_cpTransformWrapInverse(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpTransform arg0; cpTransform arg1; 

	ok &= jsval_to_cpTransform( cx, args.get(arg_idx++), (cpTransform*) &arg0 );
	ok &= jsval_to_cpTransform( cx, args.get(arg_idx++), (cpTransform*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpTransform ret_val;

	ret_val = cpTransformWrapInverse((cpTransform)arg0 , (cpTransform)arg1  );

	args.rval().set(cpTransform_to_jsval( cx, (cpTransform)ret_val ));

	return true;
}

// Arguments: cpTransform, cpBB
// Ret value: cpBB
bool JSB_cpTransformbBB(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpTransform arg0; cpBB arg1; 

	ok &= jsval_to_cpTransform( cx, args.get(arg_idx++), (cpTransform*) &arg0 );
	ok &= jsval_to_cpBB( cx, args.get(arg_idx++), (cpBB*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBB ret_val;

	ret_val = cpTransformbBB((cpTransform)arg0 , (cpBB)arg1  );

	args.rval().set(cpBB_to_jsval( cx, (cpBB)ret_val ));

	return true;
}

// Arguments: cpFloat
// Ret value: cpFloat
bool JSB_cpfabs(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	double arg0; 

	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpfabs((cpFloat)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpFloat, cpFloat, cpFloat
// Ret value: cpFloat
bool JSB_cpfclamp(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	double arg0; double arg1; double arg2; 

	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpfclamp((cpFloat)arg0 , (cpFloat)arg1 , (cpFloat)arg2  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpFloat
// Ret value: cpFloat
bool JSB_cpfclamp01(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	double arg0; 

	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpfclamp01((cpFloat)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpFloat, cpFloat, cpFloat
// Ret value: cpFloat
bool JSB_cpflerp(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	double arg0; double arg1; double arg2; 

	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpflerp((cpFloat)arg0 , (cpFloat)arg1 , (cpFloat)arg2  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpFloat, cpFloat, cpFloat
// Ret value: cpFloat
bool JSB_cpflerpconst(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	double arg0; double arg1; double arg2; 

	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpflerpconst((cpFloat)arg0 , (cpFloat)arg1 , (cpFloat)arg2  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpFloat, cpFloat
// Ret value: cpFloat
bool JSB_cpfmax(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	double arg0; double arg1; 

	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpfmax((cpFloat)arg0 , (cpFloat)arg1  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpFloat, cpFloat
// Ret value: cpFloat
bool JSB_cpfmin(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	double arg0; double arg1; 

	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpfmin((cpFloat)arg0 , (cpFloat)arg1  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpVect, cpVect
// Ret value: cpVect
bool JSB_cpvadd(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpvadd((cpVect)arg0 , (cpVect)arg1  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpVect, cpFloat
// Ret value: cpVect
bool JSB_cpvclamp(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; double arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpvclamp((cpVect)arg0 , (cpFloat)arg1  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpVect, cpVect
// Ret value: cpFloat
bool JSB_cpvcross(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpvcross((cpVect)arg0 , (cpVect)arg1  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpVect, cpVect
// Ret value: cpFloat
bool JSB_cpvdist(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpvdist((cpVect)arg0 , (cpVect)arg1  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpVect, cpVect
// Ret value: cpFloat
bool JSB_cpvdistsq(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpvdistsq((cpVect)arg0 , (cpVect)arg1  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpVect, cpVect
// Ret value: cpFloat
bool JSB_cpvdot(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpvdot((cpVect)arg0 , (cpVect)arg1  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpVect, cpVect
// Ret value: cpBool
bool JSB_cpveql(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpveql((cpVect)arg0 , (cpVect)arg1  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpFloat
// Ret value: cpVect
bool JSB_cpvforangle(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	double arg0; 

	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpvforangle((cpFloat)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpVect
// Ret value: cpFloat
bool JSB_cpvlength(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpvlength((cpVect)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpVect
// Ret value: cpFloat
bool JSB_cpvlengthsq(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpvlengthsq((cpVect)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpVect, cpVect, cpFloat
// Ret value: cpVect
bool JSB_cpvlerp(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; cpVect arg1; double arg2; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpvlerp((cpVect)arg0 , (cpVect)arg1 , (cpFloat)arg2  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpVect, cpVect, cpFloat
// Ret value: cpVect
bool JSB_cpvlerpconst(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; cpVect arg1; double arg2; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpvlerpconst((cpVect)arg0 , (cpVect)arg1 , (cpFloat)arg2  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpVect, cpFloat
// Ret value: cpVect
bool JSB_cpvmult(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; double arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpvmult((cpVect)arg0 , (cpFloat)arg1  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpVect, cpVect, cpFloat
// Ret value: cpBool
bool JSB_cpvnear(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; cpVect arg1; double arg2; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpBool ret_val;

	ret_val = cpvnear((cpVect)arg0 , (cpVect)arg1 , (cpFloat)arg2  );

	args.rval().set(INT_TO_JSVAL((int32_t)ret_val));

	return true;
}

// Arguments: cpVect
// Ret value: cpVect
bool JSB_cpvneg(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpvneg((cpVect)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpVect
// Ret value: cpVect
bool JSB_cpvnormalize(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpvnormalize((cpVect)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpVect
// Ret value: cpVect
bool JSB_cpvperp(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpvperp((cpVect)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpVect, cpVect
// Ret value: cpVect
bool JSB_cpvproject(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpvproject((cpVect)arg0 , (cpVect)arg1  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpVect, cpVect
// Ret value: cpVect
bool JSB_cpvrotate(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpvrotate((cpVect)arg0 , (cpVect)arg1  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpVect
// Ret value: cpVect
bool JSB_cpvrperp(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpvrperp((cpVect)arg0  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpVect, cpVect, cpFloat
// Ret value: cpVect
bool JSB_cpvslerp(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; cpVect arg1; double arg2; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpvslerp((cpVect)arg0 , (cpVect)arg1 , (cpFloat)arg2  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpVect, cpVect, cpFloat
// Ret value: cpVect
bool JSB_cpvslerpconst(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 3, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; cpVect arg1; double arg2; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	ok &= JS::ToNumber( cx, args.get(arg_idx++), &arg2 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpvslerpconst((cpVect)arg0 , (cpVect)arg1 , (cpFloat)arg2  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpVect, cpVect
// Ret value: cpVect
bool JSB_cpvsub(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpvsub((cpVect)arg0 , (cpVect)arg1  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}

// Arguments: cpVect
// Ret value: cpFloat
bool JSB_cpvtoangle(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 1, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpFloat ret_val;

	ret_val = cpvtoangle((cpVect)arg0  );

	args.rval().set(DOUBLE_TO_JSVAL(ret_val));

	return true;
}

// Arguments: cpVect, cpVect
// Ret value: cpVect
bool JSB_cpvunrotate(JSContext *cx, uint32_t argc, jsval *vp) {
	JSB_PRECONDITION2(argc == 2, cx, false, "Invalid number of arguments" );
	JS::CallArgs args = JS::CallArgsFromVp(argc, vp);

	int arg_idx=0; // #001
	bool ok = true;
	cpVect arg0; cpVect arg1; 

	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg0 );
	ok &= jsval_to_cpVect( cx, args.get(arg_idx++), (cpVect*) &arg1 );
	JSB_PRECONDITION2(ok, cx, false, "Error processing arguments");
	cpVect ret_val;

	ret_val = cpvunrotate((cpVect)arg0 , (cpVect)arg1  );

	args.rval().set(cpVect_to_jsval( cx, (cpVect)ret_val ));

	return true;
}


#endif // JSB_INCLUDE_CHIPMUNK

// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: CSParseBinary.proto

#ifndef PROTOBUF_CSParseBinary_2eproto__INCLUDED
#define PROTOBUF_CSParseBinary_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 2005000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 2005000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
// @@protoc_insertion_point(includes)

namespace protocolbuffers {

// Internal implementation detail -- do not call these.
void  protobuf_AddDesc_CSParseBinary_2eproto();
void protobuf_AssignDesc_CSParseBinary_2eproto();
void protobuf_ShutdownFile_CSParseBinary_2eproto();

class CSParseBinary;
class NodeTree;
class WidgetOptions;
class LayoutParameter;
class ButtonOptions;
class ResourceData;
class CheckBoxOptions;
class ImageViewOptions;
class TextAtlasOptions;
class TextBMFontOptions;
class TextOptions;
class LoadingBarOptions;
class ListViewOptions;
class PageViewOptions;
class PanelOptions;
class ScrollViewOptions;
class SliderOptions;
class SpriteOptions;
class TextFieldOptions;
class TMXTiledMapOptions;
class ParticleSystemOptions;
class ProjectNodeOptions;
class ComponentOptions;
class ComAudioOptions;
class NodeAction;
class TimeLine;
class Frame;
class TimeLineBoolFrame;
class TimeLineIntFrame;
class TimeLineStringFrame;
class TimeLinePointFrame;
class TimeLineColorFrame;
class TimeLineTextureFrame;

// ===================================================================

class CSParseBinary : public ::google::protobuf::MessageLite {
 public:
  CSParseBinary();
  virtual ~CSParseBinary();

  CSParseBinary(const CSParseBinary& from);

  inline CSParseBinary& operator=(const CSParseBinary& from) {
    CopyFrom(from);
    return *this;
  }

  static const CSParseBinary& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CSParseBinary* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CSParseBinary* other);

  // implements Message ----------------------------------------------

  CSParseBinary* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CSParseBinary& from);
  void MergeFrom(const CSParseBinary& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string version = 1;
  inline bool has_version() const;
  inline void clear_version();
  static const int kVersionFieldNumber = 1;
  inline const ::std::string& version() const;
  inline void set_version(const ::std::string& value);
  inline void set_version(const char* value);
  inline void set_version(const char* value, size_t size);
  inline ::std::string* mutable_version();
  inline ::std::string* release_version();
  inline void set_allocated_version(::std::string* version);

  // optional string cocos2dVersion = 2;
  inline bool has_cocos2dversion() const;
  inline void clear_cocos2dversion();
  static const int kCocos2DVersionFieldNumber = 2;
  inline const ::std::string& cocos2dversion() const;
  inline void set_cocos2dversion(const ::std::string& value);
  inline void set_cocos2dversion(const char* value);
  inline void set_cocos2dversion(const char* value, size_t size);
  inline ::std::string* mutable_cocos2dversion();
  inline ::std::string* release_cocos2dversion();
  inline void set_allocated_cocos2dversion(::std::string* cocos2dversion);

  // optional string editorType = 3;
  inline bool has_editortype() const;
  inline void clear_editortype();
  static const int kEditorTypeFieldNumber = 3;
  inline const ::std::string& editortype() const;
  inline void set_editortype(const ::std::string& value);
  inline void set_editortype(const char* value);
  inline void set_editortype(const char* value, size_t size);
  inline ::std::string* mutable_editortype();
  inline ::std::string* release_editortype();
  inline void set_allocated_editortype(::std::string* editortype);

  // optional float dataScale = 4;
  inline bool has_datascale() const;
  inline void clear_datascale();
  static const int kDataScaleFieldNumber = 4;
  inline float datascale() const;
  inline void set_datascale(float value);

  // optional int32 designHeight = 5;
  inline bool has_designheight() const;
  inline void clear_designheight();
  static const int kDesignHeightFieldNumber = 5;
  inline ::google::protobuf::int32 designheight() const;
  inline void set_designheight(::google::protobuf::int32 value);

  // optional int32 designWidth = 6;
  inline bool has_designwidth() const;
  inline void clear_designwidth();
  static const int kDesignWidthFieldNumber = 6;
  inline ::google::protobuf::int32 designwidth() const;
  inline void set_designwidth(::google::protobuf::int32 value);

  // repeated string textures = 7;
  inline int textures_size() const;
  inline void clear_textures();
  static const int kTexturesFieldNumber = 7;
  inline const ::std::string& textures(int index) const;
  inline ::std::string* mutable_textures(int index);
  inline void set_textures(int index, const ::std::string& value);
  inline void set_textures(int index, const char* value);
  inline void set_textures(int index, const char* value, size_t size);
  inline ::std::string* add_textures();
  inline void add_textures(const ::std::string& value);
  inline void add_textures(const char* value);
  inline void add_textures(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& textures() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_textures();

  // repeated string texturesPng = 8;
  inline int texturespng_size() const;
  inline void clear_texturespng();
  static const int kTexturesPngFieldNumber = 8;
  inline const ::std::string& texturespng(int index) const;
  inline ::std::string* mutable_texturespng(int index);
  inline void set_texturespng(int index, const ::std::string& value);
  inline void set_texturespng(int index, const char* value);
  inline void set_texturespng(int index, const char* value, size_t size);
  inline ::std::string* add_texturespng();
  inline void add_texturespng(const ::std::string& value);
  inline void add_texturespng(const char* value);
  inline void add_texturespng(const char* value, size_t size);
  inline const ::google::protobuf::RepeatedPtrField< ::std::string>& texturespng() const;
  inline ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_texturespng();

  // optional .protocolbuffers.NodeTree nodeTree = 9;
  inline bool has_nodetree() const;
  inline void clear_nodetree();
  static const int kNodeTreeFieldNumber = 9;
  inline const ::protocolbuffers::NodeTree& nodetree() const;
  inline ::protocolbuffers::NodeTree* mutable_nodetree();
  inline ::protocolbuffers::NodeTree* release_nodetree();
  inline void set_allocated_nodetree(::protocolbuffers::NodeTree* nodetree);

  // optional .protocolbuffers.NodeAction action = 10;
  inline bool has_action() const;
  inline void clear_action();
  static const int kActionFieldNumber = 10;
  inline const ::protocolbuffers::NodeAction& action() const;
  inline ::protocolbuffers::NodeAction* mutable_action();
  inline ::protocolbuffers::NodeAction* release_action();
  inline void set_allocated_action(::protocolbuffers::NodeAction* action);

  // @@protoc_insertion_point(class_scope:protocolbuffers.CSParseBinary)
 private:
  inline void set_has_version();
  inline void clear_has_version();
  inline void set_has_cocos2dversion();
  inline void clear_has_cocos2dversion();
  inline void set_has_editortype();
  inline void clear_has_editortype();
  inline void set_has_datascale();
  inline void clear_has_datascale();
  inline void set_has_designheight();
  inline void clear_has_designheight();
  inline void set_has_designwidth();
  inline void clear_has_designwidth();
  inline void set_has_nodetree();
  inline void clear_has_nodetree();
  inline void set_has_action();
  inline void clear_has_action();

  ::std::string* version_;
  ::std::string* cocos2dversion_;
  ::std::string* editortype_;
  float datascale_;
  ::google::protobuf::int32 designheight_;
  ::google::protobuf::RepeatedPtrField< ::std::string> textures_;
  ::google::protobuf::RepeatedPtrField< ::std::string> texturespng_;
  ::protocolbuffers::NodeTree* nodetree_;
  ::protocolbuffers::NodeAction* action_;
  ::google::protobuf::int32 designwidth_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(10 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static CSParseBinary* default_instance_;
};
// -------------------------------------------------------------------

class NodeTree : public ::google::protobuf::MessageLite {
 public:
  NodeTree();
  virtual ~NodeTree();

  NodeTree(const NodeTree& from);

  inline NodeTree& operator=(const NodeTree& from) {
    CopyFrom(from);
    return *this;
  }

  static const NodeTree& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NodeTree* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NodeTree* other);

  // implements Message ----------------------------------------------

  NodeTree* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NodeTree& from);
  void MergeFrom(const NodeTree& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string classname = 1;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 1;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  inline void set_allocated_classname(::std::string* classname);

  // optional string name = 2;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 2;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // repeated .protocolbuffers.NodeTree children = 3;
  inline int children_size() const;
  inline void clear_children();
  static const int kChildrenFieldNumber = 3;
  inline const ::protocolbuffers::NodeTree& children(int index) const;
  inline ::protocolbuffers::NodeTree* mutable_children(int index);
  inline ::protocolbuffers::NodeTree* add_children();
  inline const ::google::protobuf::RepeatedPtrField< ::protocolbuffers::NodeTree >&
      children() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocolbuffers::NodeTree >*
      mutable_children();

  // optional .protocolbuffers.WidgetOptions widgetOptions = 4;
  inline bool has_widgetoptions() const;
  inline void clear_widgetoptions();
  static const int kWidgetOptionsFieldNumber = 4;
  inline const ::protocolbuffers::WidgetOptions& widgetoptions() const;
  inline ::protocolbuffers::WidgetOptions* mutable_widgetoptions();
  inline ::protocolbuffers::WidgetOptions* release_widgetoptions();
  inline void set_allocated_widgetoptions(::protocolbuffers::WidgetOptions* widgetoptions);

  // optional .protocolbuffers.ButtonOptions buttonOptions = 5;
  inline bool has_buttonoptions() const;
  inline void clear_buttonoptions();
  static const int kButtonOptionsFieldNumber = 5;
  inline const ::protocolbuffers::ButtonOptions& buttonoptions() const;
  inline ::protocolbuffers::ButtonOptions* mutable_buttonoptions();
  inline ::protocolbuffers::ButtonOptions* release_buttonoptions();
  inline void set_allocated_buttonoptions(::protocolbuffers::ButtonOptions* buttonoptions);

  // optional .protocolbuffers.CheckBoxOptions checkBoxOptions = 6;
  inline bool has_checkboxoptions() const;
  inline void clear_checkboxoptions();
  static const int kCheckBoxOptionsFieldNumber = 6;
  inline const ::protocolbuffers::CheckBoxOptions& checkboxoptions() const;
  inline ::protocolbuffers::CheckBoxOptions* mutable_checkboxoptions();
  inline ::protocolbuffers::CheckBoxOptions* release_checkboxoptions();
  inline void set_allocated_checkboxoptions(::protocolbuffers::CheckBoxOptions* checkboxoptions);

  // optional .protocolbuffers.ImageViewOptions imageViewOptions = 7;
  inline bool has_imageviewoptions() const;
  inline void clear_imageviewoptions();
  static const int kImageViewOptionsFieldNumber = 7;
  inline const ::protocolbuffers::ImageViewOptions& imageviewoptions() const;
  inline ::protocolbuffers::ImageViewOptions* mutable_imageviewoptions();
  inline ::protocolbuffers::ImageViewOptions* release_imageviewoptions();
  inline void set_allocated_imageviewoptions(::protocolbuffers::ImageViewOptions* imageviewoptions);

  // optional .protocolbuffers.TextAtlasOptions textAtlasOptions = 8;
  inline bool has_textatlasoptions() const;
  inline void clear_textatlasoptions();
  static const int kTextAtlasOptionsFieldNumber = 8;
  inline const ::protocolbuffers::TextAtlasOptions& textatlasoptions() const;
  inline ::protocolbuffers::TextAtlasOptions* mutable_textatlasoptions();
  inline ::protocolbuffers::TextAtlasOptions* release_textatlasoptions();
  inline void set_allocated_textatlasoptions(::protocolbuffers::TextAtlasOptions* textatlasoptions);

  // optional .protocolbuffers.TextBMFontOptions textBMFontOptions = 9;
  inline bool has_textbmfontoptions() const;
  inline void clear_textbmfontoptions();
  static const int kTextBMFontOptionsFieldNumber = 9;
  inline const ::protocolbuffers::TextBMFontOptions& textbmfontoptions() const;
  inline ::protocolbuffers::TextBMFontOptions* mutable_textbmfontoptions();
  inline ::protocolbuffers::TextBMFontOptions* release_textbmfontoptions();
  inline void set_allocated_textbmfontoptions(::protocolbuffers::TextBMFontOptions* textbmfontoptions);

  // optional .protocolbuffers.TextOptions textOptions = 10;
  inline bool has_textoptions() const;
  inline void clear_textoptions();
  static const int kTextOptionsFieldNumber = 10;
  inline const ::protocolbuffers::TextOptions& textoptions() const;
  inline ::protocolbuffers::TextOptions* mutable_textoptions();
  inline ::protocolbuffers::TextOptions* release_textoptions();
  inline void set_allocated_textoptions(::protocolbuffers::TextOptions* textoptions);

  // optional .protocolbuffers.LoadingBarOptions loadingBarOptions = 11;
  inline bool has_loadingbaroptions() const;
  inline void clear_loadingbaroptions();
  static const int kLoadingBarOptionsFieldNumber = 11;
  inline const ::protocolbuffers::LoadingBarOptions& loadingbaroptions() const;
  inline ::protocolbuffers::LoadingBarOptions* mutable_loadingbaroptions();
  inline ::protocolbuffers::LoadingBarOptions* release_loadingbaroptions();
  inline void set_allocated_loadingbaroptions(::protocolbuffers::LoadingBarOptions* loadingbaroptions);

  // optional .protocolbuffers.SliderOptions sliderOptions = 12;
  inline bool has_slideroptions() const;
  inline void clear_slideroptions();
  static const int kSliderOptionsFieldNumber = 12;
  inline const ::protocolbuffers::SliderOptions& slideroptions() const;
  inline ::protocolbuffers::SliderOptions* mutable_slideroptions();
  inline ::protocolbuffers::SliderOptions* release_slideroptions();
  inline void set_allocated_slideroptions(::protocolbuffers::SliderOptions* slideroptions);

  // optional .protocolbuffers.TextFieldOptions textFieldOptions = 13;
  inline bool has_textfieldoptions() const;
  inline void clear_textfieldoptions();
  static const int kTextFieldOptionsFieldNumber = 13;
  inline const ::protocolbuffers::TextFieldOptions& textfieldoptions() const;
  inline ::protocolbuffers::TextFieldOptions* mutable_textfieldoptions();
  inline ::protocolbuffers::TextFieldOptions* release_textfieldoptions();
  inline void set_allocated_textfieldoptions(::protocolbuffers::TextFieldOptions* textfieldoptions);

  // optional .protocolbuffers.ScrollViewOptions scrollViewOptions = 14;
  inline bool has_scrollviewoptions() const;
  inline void clear_scrollviewoptions();
  static const int kScrollViewOptionsFieldNumber = 14;
  inline const ::protocolbuffers::ScrollViewOptions& scrollviewoptions() const;
  inline ::protocolbuffers::ScrollViewOptions* mutable_scrollviewoptions();
  inline ::protocolbuffers::ScrollViewOptions* release_scrollviewoptions();
  inline void set_allocated_scrollviewoptions(::protocolbuffers::ScrollViewOptions* scrollviewoptions);

  // optional .protocolbuffers.PageViewOptions pageViewOptions = 15;
  inline bool has_pageviewoptions() const;
  inline void clear_pageviewoptions();
  static const int kPageViewOptionsFieldNumber = 15;
  inline const ::protocolbuffers::PageViewOptions& pageviewoptions() const;
  inline ::protocolbuffers::PageViewOptions* mutable_pageviewoptions();
  inline ::protocolbuffers::PageViewOptions* release_pageviewoptions();
  inline void set_allocated_pageviewoptions(::protocolbuffers::PageViewOptions* pageviewoptions);

  // optional .protocolbuffers.ListViewOptions listViewOptions = 16;
  inline bool has_listviewoptions() const;
  inline void clear_listviewoptions();
  static const int kListViewOptionsFieldNumber = 16;
  inline const ::protocolbuffers::ListViewOptions& listviewoptions() const;
  inline ::protocolbuffers::ListViewOptions* mutable_listviewoptions();
  inline ::protocolbuffers::ListViewOptions* release_listviewoptions();
  inline void set_allocated_listviewoptions(::protocolbuffers::ListViewOptions* listviewoptions);

  // optional .protocolbuffers.PanelOptions PanelOptions = 17;
  inline bool has_paneloptions() const;
  inline void clear_paneloptions();
  static const int kPanelOptionsFieldNumber = 17;
  inline const ::protocolbuffers::PanelOptions& paneloptions() const;
  inline ::protocolbuffers::PanelOptions* mutable_paneloptions();
  inline ::protocolbuffers::PanelOptions* release_paneloptions();
  inline void set_allocated_paneloptions(::protocolbuffers::PanelOptions* paneloptions);

  // optional .protocolbuffers.SpriteOptions spriteOptions = 18;
  inline bool has_spriteoptions() const;
  inline void clear_spriteoptions();
  static const int kSpriteOptionsFieldNumber = 18;
  inline const ::protocolbuffers::SpriteOptions& spriteoptions() const;
  inline ::protocolbuffers::SpriteOptions* mutable_spriteoptions();
  inline ::protocolbuffers::SpriteOptions* release_spriteoptions();
  inline void set_allocated_spriteoptions(::protocolbuffers::SpriteOptions* spriteoptions);

  // optional .protocolbuffers.TMXTiledMapOptions tmxTiledMapOptions = 19;
  inline bool has_tmxtiledmapoptions() const;
  inline void clear_tmxtiledmapoptions();
  static const int kTmxTiledMapOptionsFieldNumber = 19;
  inline const ::protocolbuffers::TMXTiledMapOptions& tmxtiledmapoptions() const;
  inline ::protocolbuffers::TMXTiledMapOptions* mutable_tmxtiledmapoptions();
  inline ::protocolbuffers::TMXTiledMapOptions* release_tmxtiledmapoptions();
  inline void set_allocated_tmxtiledmapoptions(::protocolbuffers::TMXTiledMapOptions* tmxtiledmapoptions);

  // optional .protocolbuffers.ParticleSystemOptions particleSystemOptions = 20;
  inline bool has_particlesystemoptions() const;
  inline void clear_particlesystemoptions();
  static const int kParticleSystemOptionsFieldNumber = 20;
  inline const ::protocolbuffers::ParticleSystemOptions& particlesystemoptions() const;
  inline ::protocolbuffers::ParticleSystemOptions* mutable_particlesystemoptions();
  inline ::protocolbuffers::ParticleSystemOptions* release_particlesystemoptions();
  inline void set_allocated_particlesystemoptions(::protocolbuffers::ParticleSystemOptions* particlesystemoptions);

  // optional .protocolbuffers.ProjectNodeOptions projectNodeOptions = 21;
  inline bool has_projectnodeoptions() const;
  inline void clear_projectnodeoptions();
  static const int kProjectNodeOptionsFieldNumber = 21;
  inline const ::protocolbuffers::ProjectNodeOptions& projectnodeoptions() const;
  inline ::protocolbuffers::ProjectNodeOptions* mutable_projectnodeoptions();
  inline ::protocolbuffers::ProjectNodeOptions* release_projectnodeoptions();
  inline void set_allocated_projectnodeoptions(::protocolbuffers::ProjectNodeOptions* projectnodeoptions);

  // @@protoc_insertion_point(class_scope:protocolbuffers.NodeTree)
 private:
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_widgetoptions();
  inline void clear_has_widgetoptions();
  inline void set_has_buttonoptions();
  inline void clear_has_buttonoptions();
  inline void set_has_checkboxoptions();
  inline void clear_has_checkboxoptions();
  inline void set_has_imageviewoptions();
  inline void clear_has_imageviewoptions();
  inline void set_has_textatlasoptions();
  inline void clear_has_textatlasoptions();
  inline void set_has_textbmfontoptions();
  inline void clear_has_textbmfontoptions();
  inline void set_has_textoptions();
  inline void clear_has_textoptions();
  inline void set_has_loadingbaroptions();
  inline void clear_has_loadingbaroptions();
  inline void set_has_slideroptions();
  inline void clear_has_slideroptions();
  inline void set_has_textfieldoptions();
  inline void clear_has_textfieldoptions();
  inline void set_has_scrollviewoptions();
  inline void clear_has_scrollviewoptions();
  inline void set_has_pageviewoptions();
  inline void clear_has_pageviewoptions();
  inline void set_has_listviewoptions();
  inline void clear_has_listviewoptions();
  inline void set_has_paneloptions();
  inline void clear_has_paneloptions();
  inline void set_has_spriteoptions();
  inline void clear_has_spriteoptions();
  inline void set_has_tmxtiledmapoptions();
  inline void clear_has_tmxtiledmapoptions();
  inline void set_has_particlesystemoptions();
  inline void clear_has_particlesystemoptions();
  inline void set_has_projectnodeoptions();
  inline void clear_has_projectnodeoptions();

  ::std::string* classname_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::protocolbuffers::NodeTree > children_;
  ::protocolbuffers::WidgetOptions* widgetoptions_;
  ::protocolbuffers::ButtonOptions* buttonoptions_;
  ::protocolbuffers::CheckBoxOptions* checkboxoptions_;
  ::protocolbuffers::ImageViewOptions* imageviewoptions_;
  ::protocolbuffers::TextAtlasOptions* textatlasoptions_;
  ::protocolbuffers::TextBMFontOptions* textbmfontoptions_;
  ::protocolbuffers::TextOptions* textoptions_;
  ::protocolbuffers::LoadingBarOptions* loadingbaroptions_;
  ::protocolbuffers::SliderOptions* slideroptions_;
  ::protocolbuffers::TextFieldOptions* textfieldoptions_;
  ::protocolbuffers::ScrollViewOptions* scrollviewoptions_;
  ::protocolbuffers::PageViewOptions* pageviewoptions_;
  ::protocolbuffers::ListViewOptions* listviewoptions_;
  ::protocolbuffers::PanelOptions* paneloptions_;
  ::protocolbuffers::SpriteOptions* spriteoptions_;
  ::protocolbuffers::TMXTiledMapOptions* tmxtiledmapoptions_;
  ::protocolbuffers::ParticleSystemOptions* particlesystemoptions_;
  ::protocolbuffers::ProjectNodeOptions* projectnodeoptions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(21 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static NodeTree* default_instance_;
};
// -------------------------------------------------------------------

class WidgetOptions : public ::google::protobuf::MessageLite {
 public:
  WidgetOptions();
  virtual ~WidgetOptions();

  WidgetOptions(const WidgetOptions& from);

  inline WidgetOptions& operator=(const WidgetOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const WidgetOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const WidgetOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(WidgetOptions* other);

  // implements Message ----------------------------------------------

  WidgetOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const WidgetOptions& from);
  void MergeFrom(const WidgetOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float x = 1;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 1;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 2;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 2;
  inline float y() const;
  inline void set_y(float value);

  // optional float scaleX = 3;
  inline bool has_scalex() const;
  inline void clear_scalex();
  static const int kScaleXFieldNumber = 3;
  inline float scalex() const;
  inline void set_scalex(float value);

  // optional float scaleY = 4;
  inline bool has_scaley() const;
  inline void clear_scaley();
  static const int kScaleYFieldNumber = 4;
  inline float scaley() const;
  inline void set_scaley(float value);

  // optional float rotation = 5;
  inline bool has_rotation() const;
  inline void clear_rotation();
  static const int kRotationFieldNumber = 5;
  inline float rotation() const;
  inline void set_rotation(float value);

  // optional bool flipX = 6;
  inline bool has_flipx() const;
  inline void clear_flipx();
  static const int kFlipXFieldNumber = 6;
  inline bool flipx() const;
  inline void set_flipx(bool value);

  // optional bool flipY = 7;
  inline bool has_flipy() const;
  inline void clear_flipy();
  static const int kFlipYFieldNumber = 7;
  inline bool flipy() const;
  inline void set_flipy(bool value);

  // optional int32 colorB = 8;
  inline bool has_colorb() const;
  inline void clear_colorb();
  static const int kColorBFieldNumber = 8;
  inline ::google::protobuf::int32 colorb() const;
  inline void set_colorb(::google::protobuf::int32 value);

  // optional int32 colorG = 9;
  inline bool has_colorg() const;
  inline void clear_colorg();
  static const int kColorGFieldNumber = 9;
  inline ::google::protobuf::int32 colorg() const;
  inline void set_colorg(::google::protobuf::int32 value);

  // optional int32 colorR = 10;
  inline bool has_colorr() const;
  inline void clear_colorr();
  static const int kColorRFieldNumber = 10;
  inline ::google::protobuf::int32 colorr() const;
  inline void set_colorr(::google::protobuf::int32 value);

  // optional int32 opacity = 11;
  inline bool has_opacity() const;
  inline void clear_opacity();
  static const int kOpacityFieldNumber = 11;
  inline ::google::protobuf::int32 opacity() const;
  inline void set_opacity(::google::protobuf::int32 value);

  // optional bool touchAble = 12;
  inline bool has_touchable() const;
  inline void clear_touchable();
  static const int kTouchAbleFieldNumber = 12;
  inline bool touchable() const;
  inline void set_touchable(bool value);

  // optional bool visible = 13;
  inline bool has_visible() const;
  inline void clear_visible();
  static const int kVisibleFieldNumber = 13;
  inline bool visible() const;
  inline void set_visible(bool value);

  // optional int32 zorder = 14;
  inline bool has_zorder() const;
  inline void clear_zorder();
  static const int kZorderFieldNumber = 14;
  inline ::google::protobuf::int32 zorder() const;
  inline void set_zorder(::google::protobuf::int32 value);

  // optional string classType = 15;
  inline bool has_classtype() const;
  inline void clear_classtype();
  static const int kClassTypeFieldNumber = 15;
  inline const ::std::string& classtype() const;
  inline void set_classtype(const ::std::string& value);
  inline void set_classtype(const char* value);
  inline void set_classtype(const char* value, size_t size);
  inline ::std::string* mutable_classtype();
  inline ::std::string* release_classtype();
  inline void set_allocated_classtype(::std::string* classtype);

  // optional float width = 16;
  inline bool has_width() const;
  inline void clear_width();
  static const int kWidthFieldNumber = 16;
  inline float width() const;
  inline void set_width(float value);

  // optional float height = 17;
  inline bool has_height() const;
  inline void clear_height();
  static const int kHeightFieldNumber = 17;
  inline float height() const;
  inline void set_height(float value);

  // optional int32 positionType = 18;
  inline bool has_positiontype() const;
  inline void clear_positiontype();
  static const int kPositionTypeFieldNumber = 18;
  inline ::google::protobuf::int32 positiontype() const;
  inline void set_positiontype(::google::protobuf::int32 value);

  // optional float positionPercentX = 19;
  inline bool has_positionpercentx() const;
  inline void clear_positionpercentx();
  static const int kPositionPercentXFieldNumber = 19;
  inline float positionpercentx() const;
  inline void set_positionpercentx(float value);

  // optional float positionPercentY = 20;
  inline bool has_positionpercenty() const;
  inline void clear_positionpercenty();
  static const int kPositionPercentYFieldNumber = 20;
  inline float positionpercenty() const;
  inline void set_positionpercenty(float value);

  // optional int32 sizeType = 21;
  inline bool has_sizetype() const;
  inline void clear_sizetype();
  static const int kSizeTypeFieldNumber = 21;
  inline ::google::protobuf::int32 sizetype() const;
  inline void set_sizetype(::google::protobuf::int32 value);

  // optional float sizePercentX = 22;
  inline bool has_sizepercentx() const;
  inline void clear_sizepercentx();
  static const int kSizePercentXFieldNumber = 22;
  inline float sizepercentx() const;
  inline void set_sizepercentx(float value);

  // optional float sizePercentY = 23;
  inline bool has_sizepercenty() const;
  inline void clear_sizepercenty();
  static const int kSizePercentYFieldNumber = 23;
  inline float sizepercenty() const;
  inline void set_sizepercenty(float value);

  // optional bool useMergedTexture = 24;
  inline bool has_usemergedtexture() const;
  inline void clear_usemergedtexture();
  static const int kUseMergedTextureFieldNumber = 24;
  inline bool usemergedtexture() const;
  inline void set_usemergedtexture(bool value);

  // optional int32 actionTag = 25;
  inline bool has_actiontag() const;
  inline void clear_actiontag();
  static const int kActionTagFieldNumber = 25;
  inline ::google::protobuf::int32 actiontag() const;
  inline void set_actiontag(::google::protobuf::int32 value);

  // optional int32 tag = 26;
  inline bool has_tag() const;
  inline void clear_tag();
  static const int kTagFieldNumber = 26;
  inline ::google::protobuf::int32 tag() const;
  inline void set_tag(::google::protobuf::int32 value);

  // optional float anchorPointX = 27;
  inline bool has_anchorpointx() const;
  inline void clear_anchorpointx();
  static const int kAnchorPointXFieldNumber = 27;
  inline float anchorpointx() const;
  inline void set_anchorpointx(float value);

  // optional float anchorPointY = 28;
  inline bool has_anchorpointy() const;
  inline void clear_anchorpointy();
  static const int kAnchorPointYFieldNumber = 28;
  inline float anchorpointy() const;
  inline void set_anchorpointy(float value);

  // optional bool ignoreSize = 29;
  inline bool has_ignoresize() const;
  inline void clear_ignoresize();
  static const int kIgnoreSizeFieldNumber = 29;
  inline bool ignoresize() const;
  inline void set_ignoresize(bool value);

  // optional float rotationSkewX = 30;
  inline bool has_rotationskewx() const;
  inline void clear_rotationskewx();
  static const int kRotationSkewXFieldNumber = 30;
  inline float rotationskewx() const;
  inline void set_rotationskewx(float value);

  // optional float rotationSkewY = 31;
  inline bool has_rotationskewy() const;
  inline void clear_rotationskewy();
  static const int kRotationSkewYFieldNumber = 31;
  inline float rotationskewy() const;
  inline void set_rotationskewy(float value);

  // optional .protocolbuffers.LayoutParameter layoutParameter = 32;
  inline bool has_layoutparameter() const;
  inline void clear_layoutparameter();
  static const int kLayoutParameterFieldNumber = 32;
  inline const ::protocolbuffers::LayoutParameter& layoutparameter() const;
  inline ::protocolbuffers::LayoutParameter* mutable_layoutparameter();
  inline ::protocolbuffers::LayoutParameter* release_layoutparameter();
  inline void set_allocated_layoutparameter(::protocolbuffers::LayoutParameter* layoutparameter);

  // optional string customProperty = 33;
  inline bool has_customproperty() const;
  inline void clear_customproperty();
  static const int kCustomPropertyFieldNumber = 33;
  inline const ::std::string& customproperty() const;
  inline void set_customproperty(const ::std::string& value);
  inline void set_customproperty(const char* value);
  inline void set_customproperty(const char* value, size_t size);
  inline ::std::string* mutable_customproperty();
  inline ::std::string* release_customproperty();
  inline void set_allocated_customproperty(::std::string* customproperty);

  // optional string frameEvent = 34;
  inline bool has_frameevent() const;
  inline void clear_frameevent();
  static const int kFrameEventFieldNumber = 34;
  inline const ::std::string& frameevent() const;
  inline void set_frameevent(const ::std::string& value);
  inline void set_frameevent(const char* value);
  inline void set_frameevent(const char* value, size_t size);
  inline ::std::string* mutable_frameevent();
  inline ::std::string* release_frameevent();
  inline void set_allocated_frameevent(::std::string* frameevent);

  // optional string name = 35;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 35;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional int32 Alpha = 37;
  inline bool has_alpha() const;
  inline void clear_alpha();
  static const int kAlphaFieldNumber = 37;
  inline ::google::protobuf::int32 alpha() const;
  inline void set_alpha(::google::protobuf::int32 value);

  // repeated .protocolbuffers.ComponentOptions componentOptions = 36;
  inline int componentoptions_size() const;
  inline void clear_componentoptions();
  static const int kComponentOptionsFieldNumber = 36;
  inline const ::protocolbuffers::ComponentOptions& componentoptions(int index) const;
  inline ::protocolbuffers::ComponentOptions* mutable_componentoptions(int index);
  inline ::protocolbuffers::ComponentOptions* add_componentoptions();
  inline const ::google::protobuf::RepeatedPtrField< ::protocolbuffers::ComponentOptions >&
      componentoptions() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocolbuffers::ComponentOptions >*
      mutable_componentoptions();

  // @@protoc_insertion_point(class_scope:protocolbuffers.WidgetOptions)
 private:
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();
  inline void set_has_scalex();
  inline void clear_has_scalex();
  inline void set_has_scaley();
  inline void clear_has_scaley();
  inline void set_has_rotation();
  inline void clear_has_rotation();
  inline void set_has_flipx();
  inline void clear_has_flipx();
  inline void set_has_flipy();
  inline void clear_has_flipy();
  inline void set_has_colorb();
  inline void clear_has_colorb();
  inline void set_has_colorg();
  inline void clear_has_colorg();
  inline void set_has_colorr();
  inline void clear_has_colorr();
  inline void set_has_opacity();
  inline void clear_has_opacity();
  inline void set_has_touchable();
  inline void clear_has_touchable();
  inline void set_has_visible();
  inline void clear_has_visible();
  inline void set_has_zorder();
  inline void clear_has_zorder();
  inline void set_has_classtype();
  inline void clear_has_classtype();
  inline void set_has_width();
  inline void clear_has_width();
  inline void set_has_height();
  inline void clear_has_height();
  inline void set_has_positiontype();
  inline void clear_has_positiontype();
  inline void set_has_positionpercentx();
  inline void clear_has_positionpercentx();
  inline void set_has_positionpercenty();
  inline void clear_has_positionpercenty();
  inline void set_has_sizetype();
  inline void clear_has_sizetype();
  inline void set_has_sizepercentx();
  inline void clear_has_sizepercentx();
  inline void set_has_sizepercenty();
  inline void clear_has_sizepercenty();
  inline void set_has_usemergedtexture();
  inline void clear_has_usemergedtexture();
  inline void set_has_actiontag();
  inline void clear_has_actiontag();
  inline void set_has_tag();
  inline void clear_has_tag();
  inline void set_has_anchorpointx();
  inline void clear_has_anchorpointx();
  inline void set_has_anchorpointy();
  inline void clear_has_anchorpointy();
  inline void set_has_ignoresize();
  inline void clear_has_ignoresize();
  inline void set_has_rotationskewx();
  inline void clear_has_rotationskewx();
  inline void set_has_rotationskewy();
  inline void clear_has_rotationskewy();
  inline void set_has_layoutparameter();
  inline void clear_has_layoutparameter();
  inline void set_has_customproperty();
  inline void clear_has_customproperty();
  inline void set_has_frameevent();
  inline void clear_has_frameevent();
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_alpha();
  inline void clear_has_alpha();

  float x_;
  float y_;
  float scalex_;
  float scaley_;
  float rotation_;
  ::google::protobuf::int32 colorb_;
  ::google::protobuf::int32 colorg_;
  bool flipx_;
  bool flipy_;
  bool touchable_;
  bool visible_;
  ::google::protobuf::int32 colorr_;
  ::google::protobuf::int32 opacity_;
  ::std::string* classtype_;
  ::google::protobuf::int32 zorder_;
  float width_;
  float height_;
  ::google::protobuf::int32 positiontype_;
  float positionpercentx_;
  float positionpercenty_;
  ::google::protobuf::int32 sizetype_;
  float sizepercentx_;
  float sizepercenty_;
  ::google::protobuf::int32 actiontag_;
  ::google::protobuf::int32 tag_;
  bool usemergedtexture_;
  bool ignoresize_;
  float anchorpointx_;
  float anchorpointy_;
  float rotationskewx_;
  float rotationskewy_;
  ::protocolbuffers::LayoutParameter* layoutparameter_;
  ::std::string* customproperty_;
  ::std::string* frameevent_;
  ::std::string* name_;
  ::google::protobuf::RepeatedPtrField< ::protocolbuffers::ComponentOptions > componentoptions_;
  ::google::protobuf::int32 alpha_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(37 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static WidgetOptions* default_instance_;
};
// -------------------------------------------------------------------

class LayoutParameter : public ::google::protobuf::MessageLite {
 public:
  LayoutParameter();
  virtual ~LayoutParameter();

  LayoutParameter(const LayoutParameter& from);

  inline LayoutParameter& operator=(const LayoutParameter& from) {
    CopyFrom(from);
    return *this;
  }

  static const LayoutParameter& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LayoutParameter* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LayoutParameter* other);

  // implements Message ----------------------------------------------

  LayoutParameter* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LayoutParameter& from);
  void MergeFrom(const LayoutParameter& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline ::google::protobuf::int32 type() const;
  inline void set_type(::google::protobuf::int32 value);

  // optional int32 gravity = 2;
  inline bool has_gravity() const;
  inline void clear_gravity();
  static const int kGravityFieldNumber = 2;
  inline ::google::protobuf::int32 gravity() const;
  inline void set_gravity(::google::protobuf::int32 value);

  // optional string relativeName = 3;
  inline bool has_relativename() const;
  inline void clear_relativename();
  static const int kRelativeNameFieldNumber = 3;
  inline const ::std::string& relativename() const;
  inline void set_relativename(const ::std::string& value);
  inline void set_relativename(const char* value);
  inline void set_relativename(const char* value, size_t size);
  inline ::std::string* mutable_relativename();
  inline ::std::string* release_relativename();
  inline void set_allocated_relativename(::std::string* relativename);

  // optional string relativeToName = 4;
  inline bool has_relativetoname() const;
  inline void clear_relativetoname();
  static const int kRelativeToNameFieldNumber = 4;
  inline const ::std::string& relativetoname() const;
  inline void set_relativetoname(const ::std::string& value);
  inline void set_relativetoname(const char* value);
  inline void set_relativetoname(const char* value, size_t size);
  inline ::std::string* mutable_relativetoname();
  inline ::std::string* release_relativetoname();
  inline void set_allocated_relativetoname(::std::string* relativetoname);

  // optional int32 align = 5;
  inline bool has_align() const;
  inline void clear_align();
  static const int kAlignFieldNumber = 5;
  inline ::google::protobuf::int32 align() const;
  inline void set_align(::google::protobuf::int32 value);

  // optional int32 marginLeft = 6;
  inline bool has_marginleft() const;
  inline void clear_marginleft();
  static const int kMarginLeftFieldNumber = 6;
  inline ::google::protobuf::int32 marginleft() const;
  inline void set_marginleft(::google::protobuf::int32 value);

  // optional int32 marginTop = 7;
  inline bool has_margintop() const;
  inline void clear_margintop();
  static const int kMarginTopFieldNumber = 7;
  inline ::google::protobuf::int32 margintop() const;
  inline void set_margintop(::google::protobuf::int32 value);

  // optional int32 marginRight = 8;
  inline bool has_marginright() const;
  inline void clear_marginright();
  static const int kMarginRightFieldNumber = 8;
  inline ::google::protobuf::int32 marginright() const;
  inline void set_marginright(::google::protobuf::int32 value);

  // optional int32 marginDown = 9;
  inline bool has_margindown() const;
  inline void clear_margindown();
  static const int kMarginDownFieldNumber = 9;
  inline ::google::protobuf::int32 margindown() const;
  inline void set_margindown(::google::protobuf::int32 value);

  // optional int32 layoutEageType = 10;
  inline bool has_layouteagetype() const;
  inline void clear_layouteagetype();
  static const int kLayoutEageTypeFieldNumber = 10;
  inline ::google::protobuf::int32 layouteagetype() const;
  inline void set_layouteagetype(::google::protobuf::int32 value);

  // optional int32 layoutNormalHorizontal = 11;
  inline bool has_layoutnormalhorizontal() const;
  inline void clear_layoutnormalhorizontal();
  static const int kLayoutNormalHorizontalFieldNumber = 11;
  inline ::google::protobuf::int32 layoutnormalhorizontal() const;
  inline void set_layoutnormalhorizontal(::google::protobuf::int32 value);

  // optional int32 layoutNormalVertical = 12;
  inline bool has_layoutnormalvertical() const;
  inline void clear_layoutnormalvertical();
  static const int kLayoutNormalVerticalFieldNumber = 12;
  inline ::google::protobuf::int32 layoutnormalvertical() const;
  inline void set_layoutnormalvertical(::google::protobuf::int32 value);

  // optional int32 layoutParentHorizontal = 13;
  inline bool has_layoutparenthorizontal() const;
  inline void clear_layoutparenthorizontal();
  static const int kLayoutParentHorizontalFieldNumber = 13;
  inline ::google::protobuf::int32 layoutparenthorizontal() const;
  inline void set_layoutparenthorizontal(::google::protobuf::int32 value);

  // optional int32 layoutParentVertical = 14;
  inline bool has_layoutparentvertical() const;
  inline void clear_layoutparentvertical();
  static const int kLayoutParentVerticalFieldNumber = 14;
  inline ::google::protobuf::int32 layoutparentvertical() const;
  inline void set_layoutparentvertical(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocolbuffers.LayoutParameter)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_gravity();
  inline void clear_has_gravity();
  inline void set_has_relativename();
  inline void clear_has_relativename();
  inline void set_has_relativetoname();
  inline void clear_has_relativetoname();
  inline void set_has_align();
  inline void clear_has_align();
  inline void set_has_marginleft();
  inline void clear_has_marginleft();
  inline void set_has_margintop();
  inline void clear_has_margintop();
  inline void set_has_marginright();
  inline void clear_has_marginright();
  inline void set_has_margindown();
  inline void clear_has_margindown();
  inline void set_has_layouteagetype();
  inline void clear_has_layouteagetype();
  inline void set_has_layoutnormalhorizontal();
  inline void clear_has_layoutnormalhorizontal();
  inline void set_has_layoutnormalvertical();
  inline void clear_has_layoutnormalvertical();
  inline void set_has_layoutparenthorizontal();
  inline void clear_has_layoutparenthorizontal();
  inline void set_has_layoutparentvertical();
  inline void clear_has_layoutparentvertical();

  ::google::protobuf::int32 type_;
  ::google::protobuf::int32 gravity_;
  ::std::string* relativename_;
  ::std::string* relativetoname_;
  ::google::protobuf::int32 align_;
  ::google::protobuf::int32 marginleft_;
  ::google::protobuf::int32 margintop_;
  ::google::protobuf::int32 marginright_;
  ::google::protobuf::int32 margindown_;
  ::google::protobuf::int32 layouteagetype_;
  ::google::protobuf::int32 layoutnormalhorizontal_;
  ::google::protobuf::int32 layoutnormalvertical_;
  ::google::protobuf::int32 layoutparenthorizontal_;
  ::google::protobuf::int32 layoutparentvertical_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static LayoutParameter* default_instance_;
};
// -------------------------------------------------------------------

class ButtonOptions : public ::google::protobuf::MessageLite {
 public:
  ButtonOptions();
  virtual ~ButtonOptions();

  ButtonOptions(const ButtonOptions& from);

  inline ButtonOptions& operator=(const ButtonOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const ButtonOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ButtonOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ButtonOptions* other);

  // implements Message ----------------------------------------------

  ButtonOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ButtonOptions& from);
  void MergeFrom(const ButtonOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string classname = 2;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 2;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  inline void set_allocated_classname(::std::string* classname);

  // optional string normal = 3;
  inline bool has_normal() const;
  inline void clear_normal();
  static const int kNormalFieldNumber = 3;
  inline const ::std::string& normal() const;
  inline void set_normal(const ::std::string& value);
  inline void set_normal(const char* value);
  inline void set_normal(const char* value, size_t size);
  inline ::std::string* mutable_normal();
  inline ::std::string* release_normal();
  inline void set_allocated_normal(::std::string* normal);

  // optional string pressed = 4;
  inline bool has_pressed() const;
  inline void clear_pressed();
  static const int kPressedFieldNumber = 4;
  inline const ::std::string& pressed() const;
  inline void set_pressed(const ::std::string& value);
  inline void set_pressed(const char* value);
  inline void set_pressed(const char* value, size_t size);
  inline ::std::string* mutable_pressed();
  inline ::std::string* release_pressed();
  inline void set_allocated_pressed(::std::string* pressed);

  // optional string disabled = 5;
  inline bool has_disabled() const;
  inline void clear_disabled();
  static const int kDisabledFieldNumber = 5;
  inline const ::std::string& disabled() const;
  inline void set_disabled(const ::std::string& value);
  inline void set_disabled(const char* value);
  inline void set_disabled(const char* value, size_t size);
  inline ::std::string* mutable_disabled();
  inline ::std::string* release_disabled();
  inline void set_allocated_disabled(::std::string* disabled);

  // optional .protocolbuffers.ResourceData normalData = 6;
  inline bool has_normaldata() const;
  inline void clear_normaldata();
  static const int kNormalDataFieldNumber = 6;
  inline const ::protocolbuffers::ResourceData& normaldata() const;
  inline ::protocolbuffers::ResourceData* mutable_normaldata();
  inline ::protocolbuffers::ResourceData* release_normaldata();
  inline void set_allocated_normaldata(::protocolbuffers::ResourceData* normaldata);

  // optional .protocolbuffers.ResourceData pressedData = 7;
  inline bool has_presseddata() const;
  inline void clear_presseddata();
  static const int kPressedDataFieldNumber = 7;
  inline const ::protocolbuffers::ResourceData& presseddata() const;
  inline ::protocolbuffers::ResourceData* mutable_presseddata();
  inline ::protocolbuffers::ResourceData* release_presseddata();
  inline void set_allocated_presseddata(::protocolbuffers::ResourceData* presseddata);

  // optional .protocolbuffers.ResourceData disabledData = 8;
  inline bool has_disableddata() const;
  inline void clear_disableddata();
  static const int kDisabledDataFieldNumber = 8;
  inline const ::protocolbuffers::ResourceData& disableddata() const;
  inline ::protocolbuffers::ResourceData* mutable_disableddata();
  inline ::protocolbuffers::ResourceData* release_disableddata();
  inline void set_allocated_disableddata(::protocolbuffers::ResourceData* disableddata);

  // optional string text = 9;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 9;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional string fontName = 10;
  inline bool has_fontname() const;
  inline void clear_fontname();
  static const int kFontNameFieldNumber = 10;
  inline const ::std::string& fontname() const;
  inline void set_fontname(const ::std::string& value);
  inline void set_fontname(const char* value);
  inline void set_fontname(const char* value, size_t size);
  inline ::std::string* mutable_fontname();
  inline ::std::string* release_fontname();
  inline void set_allocated_fontname(::std::string* fontname);

  // optional int32 fontSize = 11;
  inline bool has_fontsize() const;
  inline void clear_fontsize();
  static const int kFontSizeFieldNumber = 11;
  inline ::google::protobuf::int32 fontsize() const;
  inline void set_fontsize(::google::protobuf::int32 value);

  // optional int32 textColorR = 12;
  inline bool has_textcolorr() const;
  inline void clear_textcolorr();
  static const int kTextColorRFieldNumber = 12;
  inline ::google::protobuf::int32 textcolorr() const;
  inline void set_textcolorr(::google::protobuf::int32 value);

  // optional int32 textColorG = 13;
  inline bool has_textcolorg() const;
  inline void clear_textcolorg();
  static const int kTextColorGFieldNumber = 13;
  inline ::google::protobuf::int32 textcolorg() const;
  inline void set_textcolorg(::google::protobuf::int32 value);

  // optional int32 textColorB = 14;
  inline bool has_textcolorb() const;
  inline void clear_textcolorb();
  static const int kTextColorBFieldNumber = 14;
  inline ::google::protobuf::int32 textcolorb() const;
  inline void set_textcolorb(::google::protobuf::int32 value);

  // optional float capInsetsX = 15;
  inline bool has_capinsetsx() const;
  inline void clear_capinsetsx();
  static const int kCapInsetsXFieldNumber = 15;
  inline float capinsetsx() const;
  inline void set_capinsetsx(float value);

  // optional float capInsetsY = 16;
  inline bool has_capinsetsy() const;
  inline void clear_capinsetsy();
  static const int kCapInsetsYFieldNumber = 16;
  inline float capinsetsy() const;
  inline void set_capinsetsy(float value);

  // optional float capInsetsWidth = 17;
  inline bool has_capinsetswidth() const;
  inline void clear_capinsetswidth();
  static const int kCapInsetsWidthFieldNumber = 17;
  inline float capinsetswidth() const;
  inline void set_capinsetswidth(float value);

  // optional float capInsetsHeight = 18;
  inline bool has_capinsetsheight() const;
  inline void clear_capinsetsheight();
  static const int kCapInsetsHeightFieldNumber = 18;
  inline float capinsetsheight() const;
  inline void set_capinsetsheight(float value);

  // optional float scale9Width = 19;
  inline bool has_scale9width() const;
  inline void clear_scale9width();
  static const int kScale9WidthFieldNumber = 19;
  inline float scale9width() const;
  inline void set_scale9width(float value);

  // optional float scale9Height = 20;
  inline bool has_scale9height() const;
  inline void clear_scale9height();
  static const int kScale9HeightFieldNumber = 20;
  inline float scale9height() const;
  inline void set_scale9height(float value);

  // optional bool scale9Enable = 21;
  inline bool has_scale9enable() const;
  inline void clear_scale9enable();
  static const int kScale9EnableFieldNumber = 21;
  inline bool scale9enable() const;
  inline void set_scale9enable(bool value);

  // optional bool displaystate = 22;
  inline bool has_displaystate() const;
  inline void clear_displaystate();
  static const int kDisplaystateFieldNumber = 22;
  inline bool displaystate() const;
  inline void set_displaystate(bool value);

  // optional .protocolbuffers.ResourceData fontResource = 23;
  inline bool has_fontresource() const;
  inline void clear_fontresource();
  static const int kFontResourceFieldNumber = 23;
  inline const ::protocolbuffers::ResourceData& fontresource() const;
  inline ::protocolbuffers::ResourceData* mutable_fontresource();
  inline ::protocolbuffers::ResourceData* release_fontresource();
  inline void set_allocated_fontresource(::protocolbuffers::ResourceData* fontresource);

  // @@protoc_insertion_point(class_scope:protocolbuffers.ButtonOptions)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_normal();
  inline void clear_has_normal();
  inline void set_has_pressed();
  inline void clear_has_pressed();
  inline void set_has_disabled();
  inline void clear_has_disabled();
  inline void set_has_normaldata();
  inline void clear_has_normaldata();
  inline void set_has_presseddata();
  inline void clear_has_presseddata();
  inline void set_has_disableddata();
  inline void clear_has_disableddata();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_fontname();
  inline void clear_has_fontname();
  inline void set_has_fontsize();
  inline void clear_has_fontsize();
  inline void set_has_textcolorr();
  inline void clear_has_textcolorr();
  inline void set_has_textcolorg();
  inline void clear_has_textcolorg();
  inline void set_has_textcolorb();
  inline void clear_has_textcolorb();
  inline void set_has_capinsetsx();
  inline void clear_has_capinsetsx();
  inline void set_has_capinsetsy();
  inline void clear_has_capinsetsy();
  inline void set_has_capinsetswidth();
  inline void clear_has_capinsetswidth();
  inline void set_has_capinsetsheight();
  inline void clear_has_capinsetsheight();
  inline void set_has_scale9width();
  inline void clear_has_scale9width();
  inline void set_has_scale9height();
  inline void clear_has_scale9height();
  inline void set_has_scale9enable();
  inline void clear_has_scale9enable();
  inline void set_has_displaystate();
  inline void clear_has_displaystate();
  inline void set_has_fontresource();
  inline void clear_has_fontresource();

  ::std::string* name_;
  ::std::string* classname_;
  ::std::string* normal_;
  ::std::string* pressed_;
  ::std::string* disabled_;
  ::protocolbuffers::ResourceData* normaldata_;
  ::protocolbuffers::ResourceData* presseddata_;
  ::protocolbuffers::ResourceData* disableddata_;
  ::std::string* text_;
  ::std::string* fontname_;
  ::google::protobuf::int32 fontsize_;
  ::google::protobuf::int32 textcolorr_;
  ::google::protobuf::int32 textcolorg_;
  ::google::protobuf::int32 textcolorb_;
  float capinsetsx_;
  float capinsetsy_;
  float capinsetswidth_;
  float capinsetsheight_;
  float scale9width_;
  float scale9height_;
  ::protocolbuffers::ResourceData* fontresource_;
  bool scale9enable_;
  bool displaystate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(23 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static ButtonOptions* default_instance_;
};
// -------------------------------------------------------------------

class ResourceData : public ::google::protobuf::MessageLite {
 public:
  ResourceData();
  virtual ~ResourceData();

  ResourceData(const ResourceData& from);

  inline ResourceData& operator=(const ResourceData& from) {
    CopyFrom(from);
    return *this;
  }

  static const ResourceData& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ResourceData* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ResourceData* other);

  // implements Message ----------------------------------------------

  ResourceData* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ResourceData& from);
  void MergeFrom(const ResourceData& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string path = 1;
  inline bool has_path() const;
  inline void clear_path();
  static const int kPathFieldNumber = 1;
  inline const ::std::string& path() const;
  inline void set_path(const ::std::string& value);
  inline void set_path(const char* value);
  inline void set_path(const char* value, size_t size);
  inline ::std::string* mutable_path();
  inline ::std::string* release_path();
  inline void set_allocated_path(::std::string* path);

  // optional string plistFile = 2;
  inline bool has_plistfile() const;
  inline void clear_plistfile();
  static const int kPlistFileFieldNumber = 2;
  inline const ::std::string& plistfile() const;
  inline void set_plistfile(const ::std::string& value);
  inline void set_plistfile(const char* value);
  inline void set_plistfile(const char* value, size_t size);
  inline ::std::string* mutable_plistfile();
  inline ::std::string* release_plistfile();
  inline void set_allocated_plistfile(::std::string* plistfile);

  // optional int32 resourceType = 3;
  inline bool has_resourcetype() const;
  inline void clear_resourcetype();
  static const int kResourceTypeFieldNumber = 3;
  inline ::google::protobuf::int32 resourcetype() const;
  inline void set_resourcetype(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocolbuffers.ResourceData)
 private:
  inline void set_has_path();
  inline void clear_has_path();
  inline void set_has_plistfile();
  inline void clear_has_plistfile();
  inline void set_has_resourcetype();
  inline void clear_has_resourcetype();

  ::std::string* path_;
  ::std::string* plistfile_;
  ::google::protobuf::int32 resourcetype_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static ResourceData* default_instance_;
};
// -------------------------------------------------------------------

class CheckBoxOptions : public ::google::protobuf::MessageLite {
 public:
  CheckBoxOptions();
  virtual ~CheckBoxOptions();

  CheckBoxOptions(const CheckBoxOptions& from);

  inline CheckBoxOptions& operator=(const CheckBoxOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const CheckBoxOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const CheckBoxOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(CheckBoxOptions* other);

  // implements Message ----------------------------------------------

  CheckBoxOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const CheckBoxOptions& from);
  void MergeFrom(const CheckBoxOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string classname = 2;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 2;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  inline void set_allocated_classname(::std::string* classname);

  // optional string backGroundBox = 3;
  inline bool has_backgroundbox() const;
  inline void clear_backgroundbox();
  static const int kBackGroundBoxFieldNumber = 3;
  inline const ::std::string& backgroundbox() const;
  inline void set_backgroundbox(const ::std::string& value);
  inline void set_backgroundbox(const char* value);
  inline void set_backgroundbox(const char* value, size_t size);
  inline ::std::string* mutable_backgroundbox();
  inline ::std::string* release_backgroundbox();
  inline void set_allocated_backgroundbox(::std::string* backgroundbox);

  // optional string backGroundBoxSelected = 4;
  inline bool has_backgroundboxselected() const;
  inline void clear_backgroundboxselected();
  static const int kBackGroundBoxSelectedFieldNumber = 4;
  inline const ::std::string& backgroundboxselected() const;
  inline void set_backgroundboxselected(const ::std::string& value);
  inline void set_backgroundboxselected(const char* value);
  inline void set_backgroundboxselected(const char* value, size_t size);
  inline ::std::string* mutable_backgroundboxselected();
  inline ::std::string* release_backgroundboxselected();
  inline void set_allocated_backgroundboxselected(::std::string* backgroundboxselected);

  // optional string backGroundBoxDisabled = 5;
  inline bool has_backgroundboxdisabled() const;
  inline void clear_backgroundboxdisabled();
  static const int kBackGroundBoxDisabledFieldNumber = 5;
  inline const ::std::string& backgroundboxdisabled() const;
  inline void set_backgroundboxdisabled(const ::std::string& value);
  inline void set_backgroundboxdisabled(const char* value);
  inline void set_backgroundboxdisabled(const char* value, size_t size);
  inline ::std::string* mutable_backgroundboxdisabled();
  inline ::std::string* release_backgroundboxdisabled();
  inline void set_allocated_backgroundboxdisabled(::std::string* backgroundboxdisabled);

  // optional string frontCross = 6;
  inline bool has_frontcross() const;
  inline void clear_frontcross();
  static const int kFrontCrossFieldNumber = 6;
  inline const ::std::string& frontcross() const;
  inline void set_frontcross(const ::std::string& value);
  inline void set_frontcross(const char* value);
  inline void set_frontcross(const char* value, size_t size);
  inline ::std::string* mutable_frontcross();
  inline ::std::string* release_frontcross();
  inline void set_allocated_frontcross(::std::string* frontcross);

  // optional string frontCrossDisabled = 7;
  inline bool has_frontcrossdisabled() const;
  inline void clear_frontcrossdisabled();
  static const int kFrontCrossDisabledFieldNumber = 7;
  inline const ::std::string& frontcrossdisabled() const;
  inline void set_frontcrossdisabled(const ::std::string& value);
  inline void set_frontcrossdisabled(const char* value);
  inline void set_frontcrossdisabled(const char* value, size_t size);
  inline ::std::string* mutable_frontcrossdisabled();
  inline ::std::string* release_frontcrossdisabled();
  inline void set_allocated_frontcrossdisabled(::std::string* frontcrossdisabled);

  // optional .protocolbuffers.ResourceData backGroundBoxData = 8;
  inline bool has_backgroundboxdata() const;
  inline void clear_backgroundboxdata();
  static const int kBackGroundBoxDataFieldNumber = 8;
  inline const ::protocolbuffers::ResourceData& backgroundboxdata() const;
  inline ::protocolbuffers::ResourceData* mutable_backgroundboxdata();
  inline ::protocolbuffers::ResourceData* release_backgroundboxdata();
  inline void set_allocated_backgroundboxdata(::protocolbuffers::ResourceData* backgroundboxdata);

  // optional .protocolbuffers.ResourceData backGroundBoxSelectedData = 9;
  inline bool has_backgroundboxselecteddata() const;
  inline void clear_backgroundboxselecteddata();
  static const int kBackGroundBoxSelectedDataFieldNumber = 9;
  inline const ::protocolbuffers::ResourceData& backgroundboxselecteddata() const;
  inline ::protocolbuffers::ResourceData* mutable_backgroundboxselecteddata();
  inline ::protocolbuffers::ResourceData* release_backgroundboxselecteddata();
  inline void set_allocated_backgroundboxselecteddata(::protocolbuffers::ResourceData* backgroundboxselecteddata);

  // optional .protocolbuffers.ResourceData frontCrossData = 10;
  inline bool has_frontcrossdata() const;
  inline void clear_frontcrossdata();
  static const int kFrontCrossDataFieldNumber = 10;
  inline const ::protocolbuffers::ResourceData& frontcrossdata() const;
  inline ::protocolbuffers::ResourceData* mutable_frontcrossdata();
  inline ::protocolbuffers::ResourceData* release_frontcrossdata();
  inline void set_allocated_frontcrossdata(::protocolbuffers::ResourceData* frontcrossdata);

  // optional .protocolbuffers.ResourceData backGroundBoxDisabledData = 11;
  inline bool has_backgroundboxdisableddata() const;
  inline void clear_backgroundboxdisableddata();
  static const int kBackGroundBoxDisabledDataFieldNumber = 11;
  inline const ::protocolbuffers::ResourceData& backgroundboxdisableddata() const;
  inline ::protocolbuffers::ResourceData* mutable_backgroundboxdisableddata();
  inline ::protocolbuffers::ResourceData* release_backgroundboxdisableddata();
  inline void set_allocated_backgroundboxdisableddata(::protocolbuffers::ResourceData* backgroundboxdisableddata);

  // optional .protocolbuffers.ResourceData frontCrossDisabledData = 12;
  inline bool has_frontcrossdisableddata() const;
  inline void clear_frontcrossdisableddata();
  static const int kFrontCrossDisabledDataFieldNumber = 12;
  inline const ::protocolbuffers::ResourceData& frontcrossdisableddata() const;
  inline ::protocolbuffers::ResourceData* mutable_frontcrossdisableddata();
  inline ::protocolbuffers::ResourceData* release_frontcrossdisableddata();
  inline void set_allocated_frontcrossdisableddata(::protocolbuffers::ResourceData* frontcrossdisableddata);

  // optional bool selectedState = 13;
  inline bool has_selectedstate() const;
  inline void clear_selectedstate();
  static const int kSelectedStateFieldNumber = 13;
  inline bool selectedstate() const;
  inline void set_selectedstate(bool value);

  // optional bool displaystate = 14;
  inline bool has_displaystate() const;
  inline void clear_displaystate();
  static const int kDisplaystateFieldNumber = 14;
  inline bool displaystate() const;
  inline void set_displaystate(bool value);

  // @@protoc_insertion_point(class_scope:protocolbuffers.CheckBoxOptions)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_backgroundbox();
  inline void clear_has_backgroundbox();
  inline void set_has_backgroundboxselected();
  inline void clear_has_backgroundboxselected();
  inline void set_has_backgroundboxdisabled();
  inline void clear_has_backgroundboxdisabled();
  inline void set_has_frontcross();
  inline void clear_has_frontcross();
  inline void set_has_frontcrossdisabled();
  inline void clear_has_frontcrossdisabled();
  inline void set_has_backgroundboxdata();
  inline void clear_has_backgroundboxdata();
  inline void set_has_backgroundboxselecteddata();
  inline void clear_has_backgroundboxselecteddata();
  inline void set_has_frontcrossdata();
  inline void clear_has_frontcrossdata();
  inline void set_has_backgroundboxdisableddata();
  inline void clear_has_backgroundboxdisableddata();
  inline void set_has_frontcrossdisableddata();
  inline void clear_has_frontcrossdisableddata();
  inline void set_has_selectedstate();
  inline void clear_has_selectedstate();
  inline void set_has_displaystate();
  inline void clear_has_displaystate();

  ::std::string* name_;
  ::std::string* classname_;
  ::std::string* backgroundbox_;
  ::std::string* backgroundboxselected_;
  ::std::string* backgroundboxdisabled_;
  ::std::string* frontcross_;
  ::std::string* frontcrossdisabled_;
  ::protocolbuffers::ResourceData* backgroundboxdata_;
  ::protocolbuffers::ResourceData* backgroundboxselecteddata_;
  ::protocolbuffers::ResourceData* frontcrossdata_;
  ::protocolbuffers::ResourceData* backgroundboxdisableddata_;
  ::protocolbuffers::ResourceData* frontcrossdisableddata_;
  bool selectedstate_;
  bool displaystate_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(14 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static CheckBoxOptions* default_instance_;
};
// -------------------------------------------------------------------

class ImageViewOptions : public ::google::protobuf::MessageLite {
 public:
  ImageViewOptions();
  virtual ~ImageViewOptions();

  ImageViewOptions(const ImageViewOptions& from);

  inline ImageViewOptions& operator=(const ImageViewOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const ImageViewOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ImageViewOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ImageViewOptions* other);

  // implements Message ----------------------------------------------

  ImageViewOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ImageViewOptions& from);
  void MergeFrom(const ImageViewOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string classname = 2;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 2;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  inline void set_allocated_classname(::std::string* classname);

  // optional string fileName = 3;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 3;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional .protocolbuffers.ResourceData fileNameData = 4;
  inline bool has_filenamedata() const;
  inline void clear_filenamedata();
  static const int kFileNameDataFieldNumber = 4;
  inline const ::protocolbuffers::ResourceData& filenamedata() const;
  inline ::protocolbuffers::ResourceData* mutable_filenamedata();
  inline ::protocolbuffers::ResourceData* release_filenamedata();
  inline void set_allocated_filenamedata(::protocolbuffers::ResourceData* filenamedata);

  // optional float capInsetsX = 5;
  inline bool has_capinsetsx() const;
  inline void clear_capinsetsx();
  static const int kCapInsetsXFieldNumber = 5;
  inline float capinsetsx() const;
  inline void set_capinsetsx(float value);

  // optional float capInsetsY = 6;
  inline bool has_capinsetsy() const;
  inline void clear_capinsetsy();
  static const int kCapInsetsYFieldNumber = 6;
  inline float capinsetsy() const;
  inline void set_capinsetsy(float value);

  // optional float capInsetsHeight = 7;
  inline bool has_capinsetsheight() const;
  inline void clear_capinsetsheight();
  static const int kCapInsetsHeightFieldNumber = 7;
  inline float capinsetsheight() const;
  inline void set_capinsetsheight(float value);

  // optional float capInsetsWidth = 8;
  inline bool has_capinsetswidth() const;
  inline void clear_capinsetswidth();
  static const int kCapInsetsWidthFieldNumber = 8;
  inline float capinsetswidth() const;
  inline void set_capinsetswidth(float value);

  // optional float scale9Width = 9;
  inline bool has_scale9width() const;
  inline void clear_scale9width();
  static const int kScale9WidthFieldNumber = 9;
  inline float scale9width() const;
  inline void set_scale9width(float value);

  // optional float scale9Height = 10;
  inline bool has_scale9height() const;
  inline void clear_scale9height();
  static const int kScale9HeightFieldNumber = 10;
  inline float scale9height() const;
  inline void set_scale9height(float value);

  // optional bool scale9Enable = 11;
  inline bool has_scale9enable() const;
  inline void clear_scale9enable();
  static const int kScale9EnableFieldNumber = 11;
  inline bool scale9enable() const;
  inline void set_scale9enable(bool value);

  // optional bool flippedX = 12;
  inline bool has_flippedx() const;
  inline void clear_flippedx();
  static const int kFlippedXFieldNumber = 12;
  inline bool flippedx() const;
  inline void set_flippedx(bool value);

  // optional bool flippedY = 13;
  inline bool has_flippedy() const;
  inline void clear_flippedy();
  static const int kFlippedYFieldNumber = 13;
  inline bool flippedy() const;
  inline void set_flippedy(bool value);

  // @@protoc_insertion_point(class_scope:protocolbuffers.ImageViewOptions)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_filenamedata();
  inline void clear_has_filenamedata();
  inline void set_has_capinsetsx();
  inline void clear_has_capinsetsx();
  inline void set_has_capinsetsy();
  inline void clear_has_capinsetsy();
  inline void set_has_capinsetsheight();
  inline void clear_has_capinsetsheight();
  inline void set_has_capinsetswidth();
  inline void clear_has_capinsetswidth();
  inline void set_has_scale9width();
  inline void clear_has_scale9width();
  inline void set_has_scale9height();
  inline void clear_has_scale9height();
  inline void set_has_scale9enable();
  inline void clear_has_scale9enable();
  inline void set_has_flippedx();
  inline void clear_has_flippedx();
  inline void set_has_flippedy();
  inline void clear_has_flippedy();

  ::std::string* name_;
  ::std::string* classname_;
  ::std::string* filename_;
  ::protocolbuffers::ResourceData* filenamedata_;
  float capinsetsx_;
  float capinsetsy_;
  float capinsetsheight_;
  float capinsetswidth_;
  float scale9width_;
  float scale9height_;
  bool scale9enable_;
  bool flippedx_;
  bool flippedy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static ImageViewOptions* default_instance_;
};
// -------------------------------------------------------------------

class TextAtlasOptions : public ::google::protobuf::MessageLite {
 public:
  TextAtlasOptions();
  virtual ~TextAtlasOptions();

  TextAtlasOptions(const TextAtlasOptions& from);

  inline TextAtlasOptions& operator=(const TextAtlasOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const TextAtlasOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TextAtlasOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TextAtlasOptions* other);

  // implements Message ----------------------------------------------

  TextAtlasOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TextAtlasOptions& from);
  void MergeFrom(const TextAtlasOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string classname = 2;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 2;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  inline void set_allocated_classname(::std::string* classname);

  // optional string stringValue = 3;
  inline bool has_stringvalue() const;
  inline void clear_stringvalue();
  static const int kStringValueFieldNumber = 3;
  inline const ::std::string& stringvalue() const;
  inline void set_stringvalue(const ::std::string& value);
  inline void set_stringvalue(const char* value);
  inline void set_stringvalue(const char* value, size_t size);
  inline ::std::string* mutable_stringvalue();
  inline ::std::string* release_stringvalue();
  inline void set_allocated_stringvalue(::std::string* stringvalue);

  // optional string charMapFile = 4;
  inline bool has_charmapfile() const;
  inline void clear_charmapfile();
  static const int kCharMapFileFieldNumber = 4;
  inline const ::std::string& charmapfile() const;
  inline void set_charmapfile(const ::std::string& value);
  inline void set_charmapfile(const char* value);
  inline void set_charmapfile(const char* value, size_t size);
  inline ::std::string* mutable_charmapfile();
  inline ::std::string* release_charmapfile();
  inline void set_allocated_charmapfile(::std::string* charmapfile);

  // optional .protocolbuffers.ResourceData charMapFileData = 5;
  inline bool has_charmapfiledata() const;
  inline void clear_charmapfiledata();
  static const int kCharMapFileDataFieldNumber = 5;
  inline const ::protocolbuffers::ResourceData& charmapfiledata() const;
  inline ::protocolbuffers::ResourceData* mutable_charmapfiledata();
  inline ::protocolbuffers::ResourceData* release_charmapfiledata();
  inline void set_allocated_charmapfiledata(::protocolbuffers::ResourceData* charmapfiledata);

  // optional string startCharMap = 6;
  inline bool has_startcharmap() const;
  inline void clear_startcharmap();
  static const int kStartCharMapFieldNumber = 6;
  inline const ::std::string& startcharmap() const;
  inline void set_startcharmap(const ::std::string& value);
  inline void set_startcharmap(const char* value);
  inline void set_startcharmap(const char* value, size_t size);
  inline ::std::string* mutable_startcharmap();
  inline ::std::string* release_startcharmap();
  inline void set_allocated_startcharmap(::std::string* startcharmap);

  // optional int32 itemWidth = 7;
  inline bool has_itemwidth() const;
  inline void clear_itemwidth();
  static const int kItemWidthFieldNumber = 7;
  inline ::google::protobuf::int32 itemwidth() const;
  inline void set_itemwidth(::google::protobuf::int32 value);

  // optional int32 itemHeight = 8;
  inline bool has_itemheight() const;
  inline void clear_itemheight();
  static const int kItemHeightFieldNumber = 8;
  inline ::google::protobuf::int32 itemheight() const;
  inline void set_itemheight(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocolbuffers.TextAtlasOptions)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_stringvalue();
  inline void clear_has_stringvalue();
  inline void set_has_charmapfile();
  inline void clear_has_charmapfile();
  inline void set_has_charmapfiledata();
  inline void clear_has_charmapfiledata();
  inline void set_has_startcharmap();
  inline void clear_has_startcharmap();
  inline void set_has_itemwidth();
  inline void clear_has_itemwidth();
  inline void set_has_itemheight();
  inline void clear_has_itemheight();

  ::std::string* name_;
  ::std::string* classname_;
  ::std::string* stringvalue_;
  ::std::string* charmapfile_;
  ::protocolbuffers::ResourceData* charmapfiledata_;
  ::std::string* startcharmap_;
  ::google::protobuf::int32 itemwidth_;
  ::google::protobuf::int32 itemheight_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static TextAtlasOptions* default_instance_;
};
// -------------------------------------------------------------------

class TextBMFontOptions : public ::google::protobuf::MessageLite {
 public:
  TextBMFontOptions();
  virtual ~TextBMFontOptions();

  TextBMFontOptions(const TextBMFontOptions& from);

  inline TextBMFontOptions& operator=(const TextBMFontOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const TextBMFontOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TextBMFontOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TextBMFontOptions* other);

  // implements Message ----------------------------------------------

  TextBMFontOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TextBMFontOptions& from);
  void MergeFrom(const TextBMFontOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string classname = 2;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 2;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  inline void set_allocated_classname(::std::string* classname);

  // optional string text = 3;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 3;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional .protocolbuffers.ResourceData fileNameData = 4;
  inline bool has_filenamedata() const;
  inline void clear_filenamedata();
  static const int kFileNameDataFieldNumber = 4;
  inline const ::protocolbuffers::ResourceData& filenamedata() const;
  inline ::protocolbuffers::ResourceData* mutable_filenamedata();
  inline ::protocolbuffers::ResourceData* release_filenamedata();
  inline void set_allocated_filenamedata(::protocolbuffers::ResourceData* filenamedata);

  // @@protoc_insertion_point(class_scope:protocolbuffers.TextBMFontOptions)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_filenamedata();
  inline void clear_has_filenamedata();

  ::std::string* name_;
  ::std::string* classname_;
  ::std::string* text_;
  ::protocolbuffers::ResourceData* filenamedata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static TextBMFontOptions* default_instance_;
};
// -------------------------------------------------------------------

class TextOptions : public ::google::protobuf::MessageLite {
 public:
  TextOptions();
  virtual ~TextOptions();

  TextOptions(const TextOptions& from);

  inline TextOptions& operator=(const TextOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const TextOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TextOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TextOptions* other);

  // implements Message ----------------------------------------------

  TextOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TextOptions& from);
  void MergeFrom(const TextOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string classname = 2;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 2;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  inline void set_allocated_classname(::std::string* classname);

  // optional string fontName = 3;
  inline bool has_fontname() const;
  inline void clear_fontname();
  static const int kFontNameFieldNumber = 3;
  inline const ::std::string& fontname() const;
  inline void set_fontname(const ::std::string& value);
  inline void set_fontname(const char* value);
  inline void set_fontname(const char* value, size_t size);
  inline ::std::string* mutable_fontname();
  inline ::std::string* release_fontname();
  inline void set_allocated_fontname(::std::string* fontname);

  // optional .protocolbuffers.ResourceData fontFile = 4;
  inline bool has_fontfile() const;
  inline void clear_fontfile();
  static const int kFontFileFieldNumber = 4;
  inline const ::protocolbuffers::ResourceData& fontfile() const;
  inline ::protocolbuffers::ResourceData* mutable_fontfile();
  inline ::protocolbuffers::ResourceData* release_fontfile();
  inline void set_allocated_fontfile(::protocolbuffers::ResourceData* fontfile);

  // optional int32 fontSize = 5;
  inline bool has_fontsize() const;
  inline void clear_fontsize();
  static const int kFontSizeFieldNumber = 5;
  inline ::google::protobuf::int32 fontsize() const;
  inline void set_fontsize(::google::protobuf::int32 value);

  // optional string text = 6;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 6;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional float areaWidth = 7;
  inline bool has_areawidth() const;
  inline void clear_areawidth();
  static const int kAreaWidthFieldNumber = 7;
  inline float areawidth() const;
  inline void set_areawidth(float value);

  // optional float areaHeight = 8;
  inline bool has_areaheight() const;
  inline void clear_areaheight();
  static const int kAreaHeightFieldNumber = 8;
  inline float areaheight() const;
  inline void set_areaheight(float value);

  // optional int32 hAlignment = 9;
  inline bool has_halignment() const;
  inline void clear_halignment();
  static const int kHAlignmentFieldNumber = 9;
  inline ::google::protobuf::int32 halignment() const;
  inline void set_halignment(::google::protobuf::int32 value);

  // optional int32 vAlignment = 10;
  inline bool has_valignment() const;
  inline void clear_valignment();
  static const int kVAlignmentFieldNumber = 10;
  inline ::google::protobuf::int32 valignment() const;
  inline void set_valignment(::google::protobuf::int32 value);

  // optional bool touchScaleEnable = 11;
  inline bool has_touchscaleenable() const;
  inline void clear_touchscaleenable();
  static const int kTouchScaleEnableFieldNumber = 11;
  inline bool touchscaleenable() const;
  inline void set_touchscaleenable(bool value);

  // optional .protocolbuffers.ResourceData fontResource = 12;
  inline bool has_fontresource() const;
  inline void clear_fontresource();
  static const int kFontResourceFieldNumber = 12;
  inline const ::protocolbuffers::ResourceData& fontresource() const;
  inline ::protocolbuffers::ResourceData* mutable_fontresource();
  inline ::protocolbuffers::ResourceData* release_fontresource();
  inline void set_allocated_fontresource(::protocolbuffers::ResourceData* fontresource);

  // optional bool IsCustomSize = 13;
  inline bool has_iscustomsize() const;
  inline void clear_iscustomsize();
  static const int kIsCustomSizeFieldNumber = 13;
  inline bool iscustomsize() const;
  inline void set_iscustomsize(bool value);

  // @@protoc_insertion_point(class_scope:protocolbuffers.TextOptions)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_fontname();
  inline void clear_has_fontname();
  inline void set_has_fontfile();
  inline void clear_has_fontfile();
  inline void set_has_fontsize();
  inline void clear_has_fontsize();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_areawidth();
  inline void clear_has_areawidth();
  inline void set_has_areaheight();
  inline void clear_has_areaheight();
  inline void set_has_halignment();
  inline void clear_has_halignment();
  inline void set_has_valignment();
  inline void clear_has_valignment();
  inline void set_has_touchscaleenable();
  inline void clear_has_touchscaleenable();
  inline void set_has_fontresource();
  inline void clear_has_fontresource();
  inline void set_has_iscustomsize();
  inline void clear_has_iscustomsize();

  ::std::string* name_;
  ::std::string* classname_;
  ::std::string* fontname_;
  ::protocolbuffers::ResourceData* fontfile_;
  ::std::string* text_;
  ::google::protobuf::int32 fontsize_;
  float areawidth_;
  float areaheight_;
  ::google::protobuf::int32 halignment_;
  ::google::protobuf::int32 valignment_;
  bool touchscaleenable_;
  bool iscustomsize_;
  ::protocolbuffers::ResourceData* fontresource_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static TextOptions* default_instance_;
};
// -------------------------------------------------------------------

class LoadingBarOptions : public ::google::protobuf::MessageLite {
 public:
  LoadingBarOptions();
  virtual ~LoadingBarOptions();

  LoadingBarOptions(const LoadingBarOptions& from);

  inline LoadingBarOptions& operator=(const LoadingBarOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const LoadingBarOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const LoadingBarOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(LoadingBarOptions* other);

  // implements Message ----------------------------------------------

  LoadingBarOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const LoadingBarOptions& from);
  void MergeFrom(const LoadingBarOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string classname = 2;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 2;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  inline void set_allocated_classname(::std::string* classname);

  // optional string texture = 3;
  inline bool has_texture() const;
  inline void clear_texture();
  static const int kTextureFieldNumber = 3;
  inline const ::std::string& texture() const;
  inline void set_texture(const ::std::string& value);
  inline void set_texture(const char* value);
  inline void set_texture(const char* value, size_t size);
  inline ::std::string* mutable_texture();
  inline ::std::string* release_texture();
  inline void set_allocated_texture(::std::string* texture);

  // optional .protocolbuffers.ResourceData textureData = 4;
  inline bool has_texturedata() const;
  inline void clear_texturedata();
  static const int kTextureDataFieldNumber = 4;
  inline const ::protocolbuffers::ResourceData& texturedata() const;
  inline ::protocolbuffers::ResourceData* mutable_texturedata();
  inline ::protocolbuffers::ResourceData* release_texturedata();
  inline void set_allocated_texturedata(::protocolbuffers::ResourceData* texturedata);

  // optional int32 percent = 5;
  inline bool has_percent() const;
  inline void clear_percent();
  static const int kPercentFieldNumber = 5;
  inline ::google::protobuf::int32 percent() const;
  inline void set_percent(::google::protobuf::int32 value);

  // optional int32 direction = 6;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 6;
  inline ::google::protobuf::int32 direction() const;
  inline void set_direction(::google::protobuf::int32 value);

  // optional float capInsetsX = 7;
  inline bool has_capinsetsx() const;
  inline void clear_capinsetsx();
  static const int kCapInsetsXFieldNumber = 7;
  inline float capinsetsx() const;
  inline void set_capinsetsx(float value);

  // optional float capInsetsY = 8;
  inline bool has_capinsetsy() const;
  inline void clear_capinsetsy();
  static const int kCapInsetsYFieldNumber = 8;
  inline float capinsetsy() const;
  inline void set_capinsetsy(float value);

  // optional float capInsetsWidth = 9;
  inline bool has_capinsetswidth() const;
  inline void clear_capinsetswidth();
  static const int kCapInsetsWidthFieldNumber = 9;
  inline float capinsetswidth() const;
  inline void set_capinsetswidth(float value);

  // optional float capInsetsHeight = 10;
  inline bool has_capinsetsheight() const;
  inline void clear_capinsetsheight();
  static const int kCapInsetsHeightFieldNumber = 10;
  inline float capinsetsheight() const;
  inline void set_capinsetsheight(float value);

  // optional bool scale9Enable = 11;
  inline bool has_scale9enable() const;
  inline void clear_scale9enable();
  static const int kScale9EnableFieldNumber = 11;
  inline bool scale9enable() const;
  inline void set_scale9enable(bool value);

  // optional float scale9Width = 12;
  inline bool has_scale9width() const;
  inline void clear_scale9width();
  static const int kScale9WidthFieldNumber = 12;
  inline float scale9width() const;
  inline void set_scale9width(float value);

  // optional float scale9Height = 13;
  inline bool has_scale9height() const;
  inline void clear_scale9height();
  static const int kScale9HeightFieldNumber = 13;
  inline float scale9height() const;
  inline void set_scale9height(float value);

  // @@protoc_insertion_point(class_scope:protocolbuffers.LoadingBarOptions)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_texture();
  inline void clear_has_texture();
  inline void set_has_texturedata();
  inline void clear_has_texturedata();
  inline void set_has_percent();
  inline void clear_has_percent();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_capinsetsx();
  inline void clear_has_capinsetsx();
  inline void set_has_capinsetsy();
  inline void clear_has_capinsetsy();
  inline void set_has_capinsetswidth();
  inline void clear_has_capinsetswidth();
  inline void set_has_capinsetsheight();
  inline void clear_has_capinsetsheight();
  inline void set_has_scale9enable();
  inline void clear_has_scale9enable();
  inline void set_has_scale9width();
  inline void clear_has_scale9width();
  inline void set_has_scale9height();
  inline void clear_has_scale9height();

  ::std::string* name_;
  ::std::string* classname_;
  ::std::string* texture_;
  ::protocolbuffers::ResourceData* texturedata_;
  ::google::protobuf::int32 percent_;
  ::google::protobuf::int32 direction_;
  float capinsetsx_;
  float capinsetsy_;
  float capinsetswidth_;
  float capinsetsheight_;
  bool scale9enable_;
  float scale9width_;
  float scale9height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(13 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static LoadingBarOptions* default_instance_;
};
// -------------------------------------------------------------------

class ListViewOptions : public ::google::protobuf::MessageLite {
 public:
  ListViewOptions();
  virtual ~ListViewOptions();

  ListViewOptions(const ListViewOptions& from);

  inline ListViewOptions& operator=(const ListViewOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const ListViewOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ListViewOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ListViewOptions* other);

  // implements Message ----------------------------------------------

  ListViewOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ListViewOptions& from);
  void MergeFrom(const ListViewOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string classname = 2;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 2;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  inline void set_allocated_classname(::std::string* classname);

  // optional string backGroundImage = 3;
  inline bool has_backgroundimage() const;
  inline void clear_backgroundimage();
  static const int kBackGroundImageFieldNumber = 3;
  inline const ::std::string& backgroundimage() const;
  inline void set_backgroundimage(const ::std::string& value);
  inline void set_backgroundimage(const char* value);
  inline void set_backgroundimage(const char* value, size_t size);
  inline ::std::string* mutable_backgroundimage();
  inline ::std::string* release_backgroundimage();
  inline void set_allocated_backgroundimage(::std::string* backgroundimage);

  // optional .protocolbuffers.ResourceData backGroundImageData = 4;
  inline bool has_backgroundimagedata() const;
  inline void clear_backgroundimagedata();
  static const int kBackGroundImageDataFieldNumber = 4;
  inline const ::protocolbuffers::ResourceData& backgroundimagedata() const;
  inline ::protocolbuffers::ResourceData* mutable_backgroundimagedata();
  inline ::protocolbuffers::ResourceData* release_backgroundimagedata();
  inline void set_allocated_backgroundimagedata(::protocolbuffers::ResourceData* backgroundimagedata);

  // optional int32 bgColorR = 5;
  inline bool has_bgcolorr() const;
  inline void clear_bgcolorr();
  static const int kBgColorRFieldNumber = 5;
  inline ::google::protobuf::int32 bgcolorr() const;
  inline void set_bgcolorr(::google::protobuf::int32 value);

  // optional int32 bgColorG = 6;
  inline bool has_bgcolorg() const;
  inline void clear_bgcolorg();
  static const int kBgColorGFieldNumber = 6;
  inline ::google::protobuf::int32 bgcolorg() const;
  inline void set_bgcolorg(::google::protobuf::int32 value);

  // optional int32 bgColorB = 7;
  inline bool has_bgcolorb() const;
  inline void clear_bgcolorb();
  static const int kBgColorBFieldNumber = 7;
  inline ::google::protobuf::int32 bgcolorb() const;
  inline void set_bgcolorb(::google::protobuf::int32 value);

  // optional int32 bgStartColorR = 8;
  inline bool has_bgstartcolorr() const;
  inline void clear_bgstartcolorr();
  static const int kBgStartColorRFieldNumber = 8;
  inline ::google::protobuf::int32 bgstartcolorr() const;
  inline void set_bgstartcolorr(::google::protobuf::int32 value);

  // optional int32 bgStartColorG = 9;
  inline bool has_bgstartcolorg() const;
  inline void clear_bgstartcolorg();
  static const int kBgStartColorGFieldNumber = 9;
  inline ::google::protobuf::int32 bgstartcolorg() const;
  inline void set_bgstartcolorg(::google::protobuf::int32 value);

  // optional int32 bgStartColorB = 10;
  inline bool has_bgstartcolorb() const;
  inline void clear_bgstartcolorb();
  static const int kBgStartColorBFieldNumber = 10;
  inline ::google::protobuf::int32 bgstartcolorb() const;
  inline void set_bgstartcolorb(::google::protobuf::int32 value);

  // optional int32 bgEndColorR = 11;
  inline bool has_bgendcolorr() const;
  inline void clear_bgendcolorr();
  static const int kBgEndColorRFieldNumber = 11;
  inline ::google::protobuf::int32 bgendcolorr() const;
  inline void set_bgendcolorr(::google::protobuf::int32 value);

  // optional int32 bgEndColorG = 12;
  inline bool has_bgendcolorg() const;
  inline void clear_bgendcolorg();
  static const int kBgEndColorGFieldNumber = 12;
  inline ::google::protobuf::int32 bgendcolorg() const;
  inline void set_bgendcolorg(::google::protobuf::int32 value);

  // optional int32 bgEndColorB = 13;
  inline bool has_bgendcolorb() const;
  inline void clear_bgendcolorb();
  static const int kBgEndColorBFieldNumber = 13;
  inline ::google::protobuf::int32 bgendcolorb() const;
  inline void set_bgendcolorb(::google::protobuf::int32 value);

  // optional int32 colorType = 14;
  inline bool has_colortype() const;
  inline void clear_colortype();
  static const int kColorTypeFieldNumber = 14;
  inline ::google::protobuf::int32 colortype() const;
  inline void set_colortype(::google::protobuf::int32 value);

  // optional int32 bgColorOpacity = 15;
  inline bool has_bgcoloropacity() const;
  inline void clear_bgcoloropacity();
  static const int kBgColorOpacityFieldNumber = 15;
  inline ::google::protobuf::int32 bgcoloropacity() const;
  inline void set_bgcoloropacity(::google::protobuf::int32 value);

  // optional float vectorX = 16;
  inline bool has_vectorx() const;
  inline void clear_vectorx();
  static const int kVectorXFieldNumber = 16;
  inline float vectorx() const;
  inline void set_vectorx(float value);

  // optional float vectorY = 17;
  inline bool has_vectory() const;
  inline void clear_vectory();
  static const int kVectorYFieldNumber = 17;
  inline float vectory() const;
  inline void set_vectory(float value);

  // optional float capInsetsX = 18;
  inline bool has_capinsetsx() const;
  inline void clear_capinsetsx();
  static const int kCapInsetsXFieldNumber = 18;
  inline float capinsetsx() const;
  inline void set_capinsetsx(float value);

  // optional float capInsetsY = 19;
  inline bool has_capinsetsy() const;
  inline void clear_capinsetsy();
  static const int kCapInsetsYFieldNumber = 19;
  inline float capinsetsy() const;
  inline void set_capinsetsy(float value);

  // optional float capInsetsWidth = 20;
  inline bool has_capinsetswidth() const;
  inline void clear_capinsetswidth();
  static const int kCapInsetsWidthFieldNumber = 20;
  inline float capinsetswidth() const;
  inline void set_capinsetswidth(float value);

  // optional float capInsetsHeight = 21;
  inline bool has_capinsetsheight() const;
  inline void clear_capinsetsheight();
  static const int kCapInsetsHeightFieldNumber = 21;
  inline float capinsetsheight() const;
  inline void set_capinsetsheight(float value);

  // optional bool backGroundScale9Enable = 22;
  inline bool has_backgroundscale9enable() const;
  inline void clear_backgroundscale9enable();
  static const int kBackGroundScale9EnableFieldNumber = 22;
  inline bool backgroundscale9enable() const;
  inline void set_backgroundscale9enable(bool value);

  // optional float innerWidth = 23;
  inline bool has_innerwidth() const;
  inline void clear_innerwidth();
  static const int kInnerWidthFieldNumber = 23;
  inline float innerwidth() const;
  inline void set_innerwidth(float value);

  // optional float innerHeight = 24;
  inline bool has_innerheight() const;
  inline void clear_innerheight();
  static const int kInnerHeightFieldNumber = 24;
  inline float innerheight() const;
  inline void set_innerheight(float value);

  // optional bool clipAble = 25;
  inline bool has_clipable() const;
  inline void clear_clipable();
  static const int kClipAbleFieldNumber = 25;
  inline bool clipable() const;
  inline void set_clipable(bool value);

  // optional bool bounceEnable = 26;
  inline bool has_bounceenable() const;
  inline void clear_bounceenable();
  static const int kBounceEnableFieldNumber = 26;
  inline bool bounceenable() const;
  inline void set_bounceenable(bool value);

  // optional int32 direction = 27;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 27;
  inline ::google::protobuf::int32 direction() const;
  inline void set_direction(::google::protobuf::int32 value);

  // optional int32 gravity = 28;
  inline bool has_gravity() const;
  inline void clear_gravity();
  static const int kGravityFieldNumber = 28;
  inline ::google::protobuf::int32 gravity() const;
  inline void set_gravity(::google::protobuf::int32 value);

  // optional int32 itemMargin = 29;
  inline bool has_itemmargin() const;
  inline void clear_itemmargin();
  static const int kItemMarginFieldNumber = 29;
  inline ::google::protobuf::int32 itemmargin() const;
  inline void set_itemmargin(::google::protobuf::int32 value);

  // optional float scale9Width = 30;
  inline bool has_scale9width() const;
  inline void clear_scale9width();
  static const int kScale9WidthFieldNumber = 30;
  inline float scale9width() const;
  inline void set_scale9width(float value);

  // optional float scale9Height = 31;
  inline bool has_scale9height() const;
  inline void clear_scale9height();
  static const int kScale9HeightFieldNumber = 31;
  inline float scale9height() const;
  inline void set_scale9height(float value);

  // @@protoc_insertion_point(class_scope:protocolbuffers.ListViewOptions)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_backgroundimage();
  inline void clear_has_backgroundimage();
  inline void set_has_backgroundimagedata();
  inline void clear_has_backgroundimagedata();
  inline void set_has_bgcolorr();
  inline void clear_has_bgcolorr();
  inline void set_has_bgcolorg();
  inline void clear_has_bgcolorg();
  inline void set_has_bgcolorb();
  inline void clear_has_bgcolorb();
  inline void set_has_bgstartcolorr();
  inline void clear_has_bgstartcolorr();
  inline void set_has_bgstartcolorg();
  inline void clear_has_bgstartcolorg();
  inline void set_has_bgstartcolorb();
  inline void clear_has_bgstartcolorb();
  inline void set_has_bgendcolorr();
  inline void clear_has_bgendcolorr();
  inline void set_has_bgendcolorg();
  inline void clear_has_bgendcolorg();
  inline void set_has_bgendcolorb();
  inline void clear_has_bgendcolorb();
  inline void set_has_colortype();
  inline void clear_has_colortype();
  inline void set_has_bgcoloropacity();
  inline void clear_has_bgcoloropacity();
  inline void set_has_vectorx();
  inline void clear_has_vectorx();
  inline void set_has_vectory();
  inline void clear_has_vectory();
  inline void set_has_capinsetsx();
  inline void clear_has_capinsetsx();
  inline void set_has_capinsetsy();
  inline void clear_has_capinsetsy();
  inline void set_has_capinsetswidth();
  inline void clear_has_capinsetswidth();
  inline void set_has_capinsetsheight();
  inline void clear_has_capinsetsheight();
  inline void set_has_backgroundscale9enable();
  inline void clear_has_backgroundscale9enable();
  inline void set_has_innerwidth();
  inline void clear_has_innerwidth();
  inline void set_has_innerheight();
  inline void clear_has_innerheight();
  inline void set_has_clipable();
  inline void clear_has_clipable();
  inline void set_has_bounceenable();
  inline void clear_has_bounceenable();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_gravity();
  inline void clear_has_gravity();
  inline void set_has_itemmargin();
  inline void clear_has_itemmargin();
  inline void set_has_scale9width();
  inline void clear_has_scale9width();
  inline void set_has_scale9height();
  inline void clear_has_scale9height();

  ::std::string* name_;
  ::std::string* classname_;
  ::std::string* backgroundimage_;
  ::protocolbuffers::ResourceData* backgroundimagedata_;
  ::google::protobuf::int32 bgcolorr_;
  ::google::protobuf::int32 bgcolorg_;
  ::google::protobuf::int32 bgcolorb_;
  ::google::protobuf::int32 bgstartcolorr_;
  ::google::protobuf::int32 bgstartcolorg_;
  ::google::protobuf::int32 bgstartcolorb_;
  ::google::protobuf::int32 bgendcolorr_;
  ::google::protobuf::int32 bgendcolorg_;
  ::google::protobuf::int32 bgendcolorb_;
  ::google::protobuf::int32 colortype_;
  ::google::protobuf::int32 bgcoloropacity_;
  float vectorx_;
  float vectory_;
  float capinsetsx_;
  float capinsetsy_;
  float capinsetswidth_;
  float capinsetsheight_;
  float innerwidth_;
  float innerheight_;
  bool backgroundscale9enable_;
  bool clipable_;
  bool bounceenable_;
  ::google::protobuf::int32 direction_;
  ::google::protobuf::int32 gravity_;
  ::google::protobuf::int32 itemmargin_;
  float scale9width_;
  float scale9height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(31 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static ListViewOptions* default_instance_;
};
// -------------------------------------------------------------------

class PageViewOptions : public ::google::protobuf::MessageLite {
 public:
  PageViewOptions();
  virtual ~PageViewOptions();

  PageViewOptions(const PageViewOptions& from);

  inline PageViewOptions& operator=(const PageViewOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const PageViewOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PageViewOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PageViewOptions* other);

  // implements Message ----------------------------------------------

  PageViewOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PageViewOptions& from);
  void MergeFrom(const PageViewOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string classname = 2;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 2;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  inline void set_allocated_classname(::std::string* classname);

  // optional string backGroundImage = 3;
  inline bool has_backgroundimage() const;
  inline void clear_backgroundimage();
  static const int kBackGroundImageFieldNumber = 3;
  inline const ::std::string& backgroundimage() const;
  inline void set_backgroundimage(const ::std::string& value);
  inline void set_backgroundimage(const char* value);
  inline void set_backgroundimage(const char* value, size_t size);
  inline ::std::string* mutable_backgroundimage();
  inline ::std::string* release_backgroundimage();
  inline void set_allocated_backgroundimage(::std::string* backgroundimage);

  // optional .protocolbuffers.ResourceData backGroundImageData = 4;
  inline bool has_backgroundimagedata() const;
  inline void clear_backgroundimagedata();
  static const int kBackGroundImageDataFieldNumber = 4;
  inline const ::protocolbuffers::ResourceData& backgroundimagedata() const;
  inline ::protocolbuffers::ResourceData* mutable_backgroundimagedata();
  inline ::protocolbuffers::ResourceData* release_backgroundimagedata();
  inline void set_allocated_backgroundimagedata(::protocolbuffers::ResourceData* backgroundimagedata);

  // optional bool clipAble = 5;
  inline bool has_clipable() const;
  inline void clear_clipable();
  static const int kClipAbleFieldNumber = 5;
  inline bool clipable() const;
  inline void set_clipable(bool value);

  // optional int32 bgColorR = 6;
  inline bool has_bgcolorr() const;
  inline void clear_bgcolorr();
  static const int kBgColorRFieldNumber = 6;
  inline ::google::protobuf::int32 bgcolorr() const;
  inline void set_bgcolorr(::google::protobuf::int32 value);

  // optional int32 bgColorG = 7;
  inline bool has_bgcolorg() const;
  inline void clear_bgcolorg();
  static const int kBgColorGFieldNumber = 7;
  inline ::google::protobuf::int32 bgcolorg() const;
  inline void set_bgcolorg(::google::protobuf::int32 value);

  // optional int32 bgColorB = 8;
  inline bool has_bgcolorb() const;
  inline void clear_bgcolorb();
  static const int kBgColorBFieldNumber = 8;
  inline ::google::protobuf::int32 bgcolorb() const;
  inline void set_bgcolorb(::google::protobuf::int32 value);

  // optional int32 bgStartColorR = 9;
  inline bool has_bgstartcolorr() const;
  inline void clear_bgstartcolorr();
  static const int kBgStartColorRFieldNumber = 9;
  inline ::google::protobuf::int32 bgstartcolorr() const;
  inline void set_bgstartcolorr(::google::protobuf::int32 value);

  // optional int32 bgStartColorG = 10;
  inline bool has_bgstartcolorg() const;
  inline void clear_bgstartcolorg();
  static const int kBgStartColorGFieldNumber = 10;
  inline ::google::protobuf::int32 bgstartcolorg() const;
  inline void set_bgstartcolorg(::google::protobuf::int32 value);

  // optional int32 bgStartColorB = 11;
  inline bool has_bgstartcolorb() const;
  inline void clear_bgstartcolorb();
  static const int kBgStartColorBFieldNumber = 11;
  inline ::google::protobuf::int32 bgstartcolorb() const;
  inline void set_bgstartcolorb(::google::protobuf::int32 value);

  // optional int32 bgEndColorR = 12;
  inline bool has_bgendcolorr() const;
  inline void clear_bgendcolorr();
  static const int kBgEndColorRFieldNumber = 12;
  inline ::google::protobuf::int32 bgendcolorr() const;
  inline void set_bgendcolorr(::google::protobuf::int32 value);

  // optional int32 bgEndColorG = 13;
  inline bool has_bgendcolorg() const;
  inline void clear_bgendcolorg();
  static const int kBgEndColorGFieldNumber = 13;
  inline ::google::protobuf::int32 bgendcolorg() const;
  inline void set_bgendcolorg(::google::protobuf::int32 value);

  // optional int32 bgEndColorB = 14;
  inline bool has_bgendcolorb() const;
  inline void clear_bgendcolorb();
  static const int kBgEndColorBFieldNumber = 14;
  inline ::google::protobuf::int32 bgendcolorb() const;
  inline void set_bgendcolorb(::google::protobuf::int32 value);

  // optional int32 colorType = 15;
  inline bool has_colortype() const;
  inline void clear_colortype();
  static const int kColorTypeFieldNumber = 15;
  inline ::google::protobuf::int32 colortype() const;
  inline void set_colortype(::google::protobuf::int32 value);

  // optional int32 bgColorOpacity = 16;
  inline bool has_bgcoloropacity() const;
  inline void clear_bgcoloropacity();
  static const int kBgColorOpacityFieldNumber = 16;
  inline ::google::protobuf::int32 bgcoloropacity() const;
  inline void set_bgcoloropacity(::google::protobuf::int32 value);

  // optional float vectorX = 17;
  inline bool has_vectorx() const;
  inline void clear_vectorx();
  static const int kVectorXFieldNumber = 17;
  inline float vectorx() const;
  inline void set_vectorx(float value);

  // optional float vectorY = 18;
  inline bool has_vectory() const;
  inline void clear_vectory();
  static const int kVectorYFieldNumber = 18;
  inline float vectory() const;
  inline void set_vectory(float value);

  // optional float capInsetsX = 19;
  inline bool has_capinsetsx() const;
  inline void clear_capinsetsx();
  static const int kCapInsetsXFieldNumber = 19;
  inline float capinsetsx() const;
  inline void set_capinsetsx(float value);

  // optional float capInsetsY = 20;
  inline bool has_capinsetsy() const;
  inline void clear_capinsetsy();
  static const int kCapInsetsYFieldNumber = 20;
  inline float capinsetsy() const;
  inline void set_capinsetsy(float value);

  // optional float capInsetsWidth = 21;
  inline bool has_capinsetswidth() const;
  inline void clear_capinsetswidth();
  static const int kCapInsetsWidthFieldNumber = 21;
  inline float capinsetswidth() const;
  inline void set_capinsetswidth(float value);

  // optional float capInsetsHeight = 22;
  inline bool has_capinsetsheight() const;
  inline void clear_capinsetsheight();
  static const int kCapInsetsHeightFieldNumber = 22;
  inline float capinsetsheight() const;
  inline void set_capinsetsheight(float value);

  // optional bool backGroundScale9Enable = 23;
  inline bool has_backgroundscale9enable() const;
  inline void clear_backgroundscale9enable();
  static const int kBackGroundScale9EnableFieldNumber = 23;
  inline bool backgroundscale9enable() const;
  inline void set_backgroundscale9enable(bool value);

  // optional float scale9Width = 24;
  inline bool has_scale9width() const;
  inline void clear_scale9width();
  static const int kScale9WidthFieldNumber = 24;
  inline float scale9width() const;
  inline void set_scale9width(float value);

  // optional float scale9Height = 25;
  inline bool has_scale9height() const;
  inline void clear_scale9height();
  static const int kScale9HeightFieldNumber = 25;
  inline float scale9height() const;
  inline void set_scale9height(float value);

  // @@protoc_insertion_point(class_scope:protocolbuffers.PageViewOptions)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_backgroundimage();
  inline void clear_has_backgroundimage();
  inline void set_has_backgroundimagedata();
  inline void clear_has_backgroundimagedata();
  inline void set_has_clipable();
  inline void clear_has_clipable();
  inline void set_has_bgcolorr();
  inline void clear_has_bgcolorr();
  inline void set_has_bgcolorg();
  inline void clear_has_bgcolorg();
  inline void set_has_bgcolorb();
  inline void clear_has_bgcolorb();
  inline void set_has_bgstartcolorr();
  inline void clear_has_bgstartcolorr();
  inline void set_has_bgstartcolorg();
  inline void clear_has_bgstartcolorg();
  inline void set_has_bgstartcolorb();
  inline void clear_has_bgstartcolorb();
  inline void set_has_bgendcolorr();
  inline void clear_has_bgendcolorr();
  inline void set_has_bgendcolorg();
  inline void clear_has_bgendcolorg();
  inline void set_has_bgendcolorb();
  inline void clear_has_bgendcolorb();
  inline void set_has_colortype();
  inline void clear_has_colortype();
  inline void set_has_bgcoloropacity();
  inline void clear_has_bgcoloropacity();
  inline void set_has_vectorx();
  inline void clear_has_vectorx();
  inline void set_has_vectory();
  inline void clear_has_vectory();
  inline void set_has_capinsetsx();
  inline void clear_has_capinsetsx();
  inline void set_has_capinsetsy();
  inline void clear_has_capinsetsy();
  inline void set_has_capinsetswidth();
  inline void clear_has_capinsetswidth();
  inline void set_has_capinsetsheight();
  inline void clear_has_capinsetsheight();
  inline void set_has_backgroundscale9enable();
  inline void clear_has_backgroundscale9enable();
  inline void set_has_scale9width();
  inline void clear_has_scale9width();
  inline void set_has_scale9height();
  inline void clear_has_scale9height();

  ::std::string* name_;
  ::std::string* classname_;
  ::std::string* backgroundimage_;
  ::protocolbuffers::ResourceData* backgroundimagedata_;
  ::google::protobuf::int32 bgcolorr_;
  ::google::protobuf::int32 bgcolorg_;
  ::google::protobuf::int32 bgcolorb_;
  ::google::protobuf::int32 bgstartcolorr_;
  ::google::protobuf::int32 bgstartcolorg_;
  ::google::protobuf::int32 bgstartcolorb_;
  ::google::protobuf::int32 bgendcolorr_;
  ::google::protobuf::int32 bgendcolorg_;
  ::google::protobuf::int32 bgendcolorb_;
  bool clipable_;
  bool backgroundscale9enable_;
  ::google::protobuf::int32 colortype_;
  ::google::protobuf::int32 bgcoloropacity_;
  float vectorx_;
  float vectory_;
  float capinsetsx_;
  float capinsetsy_;
  float capinsetswidth_;
  float capinsetsheight_;
  float scale9width_;
  float scale9height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(25 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static PageViewOptions* default_instance_;
};
// -------------------------------------------------------------------

class PanelOptions : public ::google::protobuf::MessageLite {
 public:
  PanelOptions();
  virtual ~PanelOptions();

  PanelOptions(const PanelOptions& from);

  inline PanelOptions& operator=(const PanelOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const PanelOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const PanelOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(PanelOptions* other);

  // implements Message ----------------------------------------------

  PanelOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const PanelOptions& from);
  void MergeFrom(const PanelOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string classname = 2;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 2;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  inline void set_allocated_classname(::std::string* classname);

  // optional string backGroundImage = 3;
  inline bool has_backgroundimage() const;
  inline void clear_backgroundimage();
  static const int kBackGroundImageFieldNumber = 3;
  inline const ::std::string& backgroundimage() const;
  inline void set_backgroundimage(const ::std::string& value);
  inline void set_backgroundimage(const char* value);
  inline void set_backgroundimage(const char* value, size_t size);
  inline ::std::string* mutable_backgroundimage();
  inline ::std::string* release_backgroundimage();
  inline void set_allocated_backgroundimage(::std::string* backgroundimage);

  // optional .protocolbuffers.ResourceData backGroundImageData = 4;
  inline bool has_backgroundimagedata() const;
  inline void clear_backgroundimagedata();
  static const int kBackGroundImageDataFieldNumber = 4;
  inline const ::protocolbuffers::ResourceData& backgroundimagedata() const;
  inline ::protocolbuffers::ResourceData* mutable_backgroundimagedata();
  inline ::protocolbuffers::ResourceData* release_backgroundimagedata();
  inline void set_allocated_backgroundimagedata(::protocolbuffers::ResourceData* backgroundimagedata);

  // optional bool clipAble = 5;
  inline bool has_clipable() const;
  inline void clear_clipable();
  static const int kClipAbleFieldNumber = 5;
  inline bool clipable() const;
  inline void set_clipable(bool value);

  // optional int32 bgColorR = 6;
  inline bool has_bgcolorr() const;
  inline void clear_bgcolorr();
  static const int kBgColorRFieldNumber = 6;
  inline ::google::protobuf::int32 bgcolorr() const;
  inline void set_bgcolorr(::google::protobuf::int32 value);

  // optional int32 bgColorG = 7;
  inline bool has_bgcolorg() const;
  inline void clear_bgcolorg();
  static const int kBgColorGFieldNumber = 7;
  inline ::google::protobuf::int32 bgcolorg() const;
  inline void set_bgcolorg(::google::protobuf::int32 value);

  // optional int32 bgColorB = 8;
  inline bool has_bgcolorb() const;
  inline void clear_bgcolorb();
  static const int kBgColorBFieldNumber = 8;
  inline ::google::protobuf::int32 bgcolorb() const;
  inline void set_bgcolorb(::google::protobuf::int32 value);

  // optional int32 bgStartColorR = 9;
  inline bool has_bgstartcolorr() const;
  inline void clear_bgstartcolorr();
  static const int kBgStartColorRFieldNumber = 9;
  inline ::google::protobuf::int32 bgstartcolorr() const;
  inline void set_bgstartcolorr(::google::protobuf::int32 value);

  // optional int32 bgStartColorG = 10;
  inline bool has_bgstartcolorg() const;
  inline void clear_bgstartcolorg();
  static const int kBgStartColorGFieldNumber = 10;
  inline ::google::protobuf::int32 bgstartcolorg() const;
  inline void set_bgstartcolorg(::google::protobuf::int32 value);

  // optional int32 bgStartColorB = 11;
  inline bool has_bgstartcolorb() const;
  inline void clear_bgstartcolorb();
  static const int kBgStartColorBFieldNumber = 11;
  inline ::google::protobuf::int32 bgstartcolorb() const;
  inline void set_bgstartcolorb(::google::protobuf::int32 value);

  // optional int32 bgEndColorR = 12;
  inline bool has_bgendcolorr() const;
  inline void clear_bgendcolorr();
  static const int kBgEndColorRFieldNumber = 12;
  inline ::google::protobuf::int32 bgendcolorr() const;
  inline void set_bgendcolorr(::google::protobuf::int32 value);

  // optional int32 bgEndColorG = 13;
  inline bool has_bgendcolorg() const;
  inline void clear_bgendcolorg();
  static const int kBgEndColorGFieldNumber = 13;
  inline ::google::protobuf::int32 bgendcolorg() const;
  inline void set_bgendcolorg(::google::protobuf::int32 value);

  // optional int32 bgEndColorB = 14;
  inline bool has_bgendcolorb() const;
  inline void clear_bgendcolorb();
  static const int kBgEndColorBFieldNumber = 14;
  inline ::google::protobuf::int32 bgendcolorb() const;
  inline void set_bgendcolorb(::google::protobuf::int32 value);

  // optional int32 colorType = 15;
  inline bool has_colortype() const;
  inline void clear_colortype();
  static const int kColorTypeFieldNumber = 15;
  inline ::google::protobuf::int32 colortype() const;
  inline void set_colortype(::google::protobuf::int32 value);

  // optional int32 bgColorOpacity = 16;
  inline bool has_bgcoloropacity() const;
  inline void clear_bgcoloropacity();
  static const int kBgColorOpacityFieldNumber = 16;
  inline ::google::protobuf::int32 bgcoloropacity() const;
  inline void set_bgcoloropacity(::google::protobuf::int32 value);

  // optional float vectorX = 17;
  inline bool has_vectorx() const;
  inline void clear_vectorx();
  static const int kVectorXFieldNumber = 17;
  inline float vectorx() const;
  inline void set_vectorx(float value);

  // optional float vectorY = 18;
  inline bool has_vectory() const;
  inline void clear_vectory();
  static const int kVectorYFieldNumber = 18;
  inline float vectory() const;
  inline void set_vectory(float value);

  // optional float capInsetsX = 19;
  inline bool has_capinsetsx() const;
  inline void clear_capinsetsx();
  static const int kCapInsetsXFieldNumber = 19;
  inline float capinsetsx() const;
  inline void set_capinsetsx(float value);

  // optional float capInsetsY = 20;
  inline bool has_capinsetsy() const;
  inline void clear_capinsetsy();
  static const int kCapInsetsYFieldNumber = 20;
  inline float capinsetsy() const;
  inline void set_capinsetsy(float value);

  // optional float capInsetsWidth = 21;
  inline bool has_capinsetswidth() const;
  inline void clear_capinsetswidth();
  static const int kCapInsetsWidthFieldNumber = 21;
  inline float capinsetswidth() const;
  inline void set_capinsetswidth(float value);

  // optional float capInsetsHeight = 22;
  inline bool has_capinsetsheight() const;
  inline void clear_capinsetsheight();
  static const int kCapInsetsHeightFieldNumber = 22;
  inline float capinsetsheight() const;
  inline void set_capinsetsheight(float value);

  // optional bool backGroundScale9Enable = 23;
  inline bool has_backgroundscale9enable() const;
  inline void clear_backgroundscale9enable();
  static const int kBackGroundScale9EnableFieldNumber = 23;
  inline bool backgroundscale9enable() const;
  inline void set_backgroundscale9enable(bool value);

  // optional int32 layoutType = 24;
  inline bool has_layouttype() const;
  inline void clear_layouttype();
  static const int kLayoutTypeFieldNumber = 24;
  inline ::google::protobuf::int32 layouttype() const;
  inline void set_layouttype(::google::protobuf::int32 value);

  // optional bool adaptScreen = 25;
  inline bool has_adaptscreen() const;
  inline void clear_adaptscreen();
  static const int kAdaptScreenFieldNumber = 25;
  inline bool adaptscreen() const;
  inline void set_adaptscreen(bool value);

  // optional float scale9Width = 26;
  inline bool has_scale9width() const;
  inline void clear_scale9width();
  static const int kScale9WidthFieldNumber = 26;
  inline float scale9width() const;
  inline void set_scale9width(float value);

  // optional float scale9Height = 27;
  inline bool has_scale9height() const;
  inline void clear_scale9height();
  static const int kScale9HeightFieldNumber = 27;
  inline float scale9height() const;
  inline void set_scale9height(float value);

  // @@protoc_insertion_point(class_scope:protocolbuffers.PanelOptions)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_backgroundimage();
  inline void clear_has_backgroundimage();
  inline void set_has_backgroundimagedata();
  inline void clear_has_backgroundimagedata();
  inline void set_has_clipable();
  inline void clear_has_clipable();
  inline void set_has_bgcolorr();
  inline void clear_has_bgcolorr();
  inline void set_has_bgcolorg();
  inline void clear_has_bgcolorg();
  inline void set_has_bgcolorb();
  inline void clear_has_bgcolorb();
  inline void set_has_bgstartcolorr();
  inline void clear_has_bgstartcolorr();
  inline void set_has_bgstartcolorg();
  inline void clear_has_bgstartcolorg();
  inline void set_has_bgstartcolorb();
  inline void clear_has_bgstartcolorb();
  inline void set_has_bgendcolorr();
  inline void clear_has_bgendcolorr();
  inline void set_has_bgendcolorg();
  inline void clear_has_bgendcolorg();
  inline void set_has_bgendcolorb();
  inline void clear_has_bgendcolorb();
  inline void set_has_colortype();
  inline void clear_has_colortype();
  inline void set_has_bgcoloropacity();
  inline void clear_has_bgcoloropacity();
  inline void set_has_vectorx();
  inline void clear_has_vectorx();
  inline void set_has_vectory();
  inline void clear_has_vectory();
  inline void set_has_capinsetsx();
  inline void clear_has_capinsetsx();
  inline void set_has_capinsetsy();
  inline void clear_has_capinsetsy();
  inline void set_has_capinsetswidth();
  inline void clear_has_capinsetswidth();
  inline void set_has_capinsetsheight();
  inline void clear_has_capinsetsheight();
  inline void set_has_backgroundscale9enable();
  inline void clear_has_backgroundscale9enable();
  inline void set_has_layouttype();
  inline void clear_has_layouttype();
  inline void set_has_adaptscreen();
  inline void clear_has_adaptscreen();
  inline void set_has_scale9width();
  inline void clear_has_scale9width();
  inline void set_has_scale9height();
  inline void clear_has_scale9height();

  ::std::string* name_;
  ::std::string* classname_;
  ::std::string* backgroundimage_;
  ::protocolbuffers::ResourceData* backgroundimagedata_;
  ::google::protobuf::int32 bgcolorr_;
  ::google::protobuf::int32 bgcolorg_;
  ::google::protobuf::int32 bgcolorb_;
  ::google::protobuf::int32 bgstartcolorr_;
  ::google::protobuf::int32 bgstartcolorg_;
  ::google::protobuf::int32 bgstartcolorb_;
  ::google::protobuf::int32 bgendcolorr_;
  ::google::protobuf::int32 bgendcolorg_;
  ::google::protobuf::int32 bgendcolorb_;
  ::google::protobuf::int32 colortype_;
  ::google::protobuf::int32 bgcoloropacity_;
  float vectorx_;
  bool clipable_;
  bool backgroundscale9enable_;
  bool adaptscreen_;
  float vectory_;
  float capinsetsx_;
  float capinsetsy_;
  float capinsetswidth_;
  float capinsetsheight_;
  ::google::protobuf::int32 layouttype_;
  float scale9width_;
  float scale9height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(27 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static PanelOptions* default_instance_;
};
// -------------------------------------------------------------------

class ScrollViewOptions : public ::google::protobuf::MessageLite {
 public:
  ScrollViewOptions();
  virtual ~ScrollViewOptions();

  ScrollViewOptions(const ScrollViewOptions& from);

  inline ScrollViewOptions& operator=(const ScrollViewOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const ScrollViewOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ScrollViewOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ScrollViewOptions* other);

  // implements Message ----------------------------------------------

  ScrollViewOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ScrollViewOptions& from);
  void MergeFrom(const ScrollViewOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string classname = 2;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 2;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  inline void set_allocated_classname(::std::string* classname);

  // optional string backGroundImage = 3;
  inline bool has_backgroundimage() const;
  inline void clear_backgroundimage();
  static const int kBackGroundImageFieldNumber = 3;
  inline const ::std::string& backgroundimage() const;
  inline void set_backgroundimage(const ::std::string& value);
  inline void set_backgroundimage(const char* value);
  inline void set_backgroundimage(const char* value, size_t size);
  inline ::std::string* mutable_backgroundimage();
  inline ::std::string* release_backgroundimage();
  inline void set_allocated_backgroundimage(::std::string* backgroundimage);

  // optional .protocolbuffers.ResourceData backGroundImageData = 4;
  inline bool has_backgroundimagedata() const;
  inline void clear_backgroundimagedata();
  static const int kBackGroundImageDataFieldNumber = 4;
  inline const ::protocolbuffers::ResourceData& backgroundimagedata() const;
  inline ::protocolbuffers::ResourceData* mutable_backgroundimagedata();
  inline ::protocolbuffers::ResourceData* release_backgroundimagedata();
  inline void set_allocated_backgroundimagedata(::protocolbuffers::ResourceData* backgroundimagedata);

  // optional int32 bgColorR = 5;
  inline bool has_bgcolorr() const;
  inline void clear_bgcolorr();
  static const int kBgColorRFieldNumber = 5;
  inline ::google::protobuf::int32 bgcolorr() const;
  inline void set_bgcolorr(::google::protobuf::int32 value);

  // optional int32 bgColorG = 6;
  inline bool has_bgcolorg() const;
  inline void clear_bgcolorg();
  static const int kBgColorGFieldNumber = 6;
  inline ::google::protobuf::int32 bgcolorg() const;
  inline void set_bgcolorg(::google::protobuf::int32 value);

  // optional int32 bgColorB = 7;
  inline bool has_bgcolorb() const;
  inline void clear_bgcolorb();
  static const int kBgColorBFieldNumber = 7;
  inline ::google::protobuf::int32 bgcolorb() const;
  inline void set_bgcolorb(::google::protobuf::int32 value);

  // optional int32 bgStartColorR = 8;
  inline bool has_bgstartcolorr() const;
  inline void clear_bgstartcolorr();
  static const int kBgStartColorRFieldNumber = 8;
  inline ::google::protobuf::int32 bgstartcolorr() const;
  inline void set_bgstartcolorr(::google::protobuf::int32 value);

  // optional int32 bgStartColorG = 9;
  inline bool has_bgstartcolorg() const;
  inline void clear_bgstartcolorg();
  static const int kBgStartColorGFieldNumber = 9;
  inline ::google::protobuf::int32 bgstartcolorg() const;
  inline void set_bgstartcolorg(::google::protobuf::int32 value);

  // optional int32 bgStartColorB = 10;
  inline bool has_bgstartcolorb() const;
  inline void clear_bgstartcolorb();
  static const int kBgStartColorBFieldNumber = 10;
  inline ::google::protobuf::int32 bgstartcolorb() const;
  inline void set_bgstartcolorb(::google::protobuf::int32 value);

  // optional int32 bgEndColorR = 11;
  inline bool has_bgendcolorr() const;
  inline void clear_bgendcolorr();
  static const int kBgEndColorRFieldNumber = 11;
  inline ::google::protobuf::int32 bgendcolorr() const;
  inline void set_bgendcolorr(::google::protobuf::int32 value);

  // optional int32 bgEndColorG = 12;
  inline bool has_bgendcolorg() const;
  inline void clear_bgendcolorg();
  static const int kBgEndColorGFieldNumber = 12;
  inline ::google::protobuf::int32 bgendcolorg() const;
  inline void set_bgendcolorg(::google::protobuf::int32 value);

  // optional int32 bgEndColorB = 13;
  inline bool has_bgendcolorb() const;
  inline void clear_bgendcolorb();
  static const int kBgEndColorBFieldNumber = 13;
  inline ::google::protobuf::int32 bgendcolorb() const;
  inline void set_bgendcolorb(::google::protobuf::int32 value);

  // optional int32 colorType = 14;
  inline bool has_colortype() const;
  inline void clear_colortype();
  static const int kColorTypeFieldNumber = 14;
  inline ::google::protobuf::int32 colortype() const;
  inline void set_colortype(::google::protobuf::int32 value);

  // optional int32 bgColorOpacity = 15;
  inline bool has_bgcoloropacity() const;
  inline void clear_bgcoloropacity();
  static const int kBgColorOpacityFieldNumber = 15;
  inline ::google::protobuf::int32 bgcoloropacity() const;
  inline void set_bgcoloropacity(::google::protobuf::int32 value);

  // optional float vectorX = 16;
  inline bool has_vectorx() const;
  inline void clear_vectorx();
  static const int kVectorXFieldNumber = 16;
  inline float vectorx() const;
  inline void set_vectorx(float value);

  // optional float vectorY = 17;
  inline bool has_vectory() const;
  inline void clear_vectory();
  static const int kVectorYFieldNumber = 17;
  inline float vectory() const;
  inline void set_vectory(float value);

  // optional float capInsetsX = 18;
  inline bool has_capinsetsx() const;
  inline void clear_capinsetsx();
  static const int kCapInsetsXFieldNumber = 18;
  inline float capinsetsx() const;
  inline void set_capinsetsx(float value);

  // optional float capInsetsY = 19;
  inline bool has_capinsetsy() const;
  inline void clear_capinsetsy();
  static const int kCapInsetsYFieldNumber = 19;
  inline float capinsetsy() const;
  inline void set_capinsetsy(float value);

  // optional float capInsetsWidth = 20;
  inline bool has_capinsetswidth() const;
  inline void clear_capinsetswidth();
  static const int kCapInsetsWidthFieldNumber = 20;
  inline float capinsetswidth() const;
  inline void set_capinsetswidth(float value);

  // optional float capInsetsHeight = 21;
  inline bool has_capinsetsheight() const;
  inline void clear_capinsetsheight();
  static const int kCapInsetsHeightFieldNumber = 21;
  inline float capinsetsheight() const;
  inline void set_capinsetsheight(float value);

  // optional bool backGroundScale9Enable = 22;
  inline bool has_backgroundscale9enable() const;
  inline void clear_backgroundscale9enable();
  static const int kBackGroundScale9EnableFieldNumber = 22;
  inline bool backgroundscale9enable() const;
  inline void set_backgroundscale9enable(bool value);

  // optional float innerWidth = 23;
  inline bool has_innerwidth() const;
  inline void clear_innerwidth();
  static const int kInnerWidthFieldNumber = 23;
  inline float innerwidth() const;
  inline void set_innerwidth(float value);

  // optional float innerHeight = 24;
  inline bool has_innerheight() const;
  inline void clear_innerheight();
  static const int kInnerHeightFieldNumber = 24;
  inline float innerheight() const;
  inline void set_innerheight(float value);

  // optional int32 direction = 25;
  inline bool has_direction() const;
  inline void clear_direction();
  static const int kDirectionFieldNumber = 25;
  inline ::google::protobuf::int32 direction() const;
  inline void set_direction(::google::protobuf::int32 value);

  // optional bool clipAble = 26;
  inline bool has_clipable() const;
  inline void clear_clipable();
  static const int kClipAbleFieldNumber = 26;
  inline bool clipable() const;
  inline void set_clipable(bool value);

  // optional bool bounceEnable = 27;
  inline bool has_bounceenable() const;
  inline void clear_bounceenable();
  static const int kBounceEnableFieldNumber = 27;
  inline bool bounceenable() const;
  inline void set_bounceenable(bool value);

  // optional int32 layoutType = 28;
  inline bool has_layouttype() const;
  inline void clear_layouttype();
  static const int kLayoutTypeFieldNumber = 28;
  inline ::google::protobuf::int32 layouttype() const;
  inline void set_layouttype(::google::protobuf::int32 value);

  // optional float scale9Width = 29;
  inline bool has_scale9width() const;
  inline void clear_scale9width();
  static const int kScale9WidthFieldNumber = 29;
  inline float scale9width() const;
  inline void set_scale9width(float value);

  // optional float scale9Height = 30;
  inline bool has_scale9height() const;
  inline void clear_scale9height();
  static const int kScale9HeightFieldNumber = 30;
  inline float scale9height() const;
  inline void set_scale9height(float value);

  // @@protoc_insertion_point(class_scope:protocolbuffers.ScrollViewOptions)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_backgroundimage();
  inline void clear_has_backgroundimage();
  inline void set_has_backgroundimagedata();
  inline void clear_has_backgroundimagedata();
  inline void set_has_bgcolorr();
  inline void clear_has_bgcolorr();
  inline void set_has_bgcolorg();
  inline void clear_has_bgcolorg();
  inline void set_has_bgcolorb();
  inline void clear_has_bgcolorb();
  inline void set_has_bgstartcolorr();
  inline void clear_has_bgstartcolorr();
  inline void set_has_bgstartcolorg();
  inline void clear_has_bgstartcolorg();
  inline void set_has_bgstartcolorb();
  inline void clear_has_bgstartcolorb();
  inline void set_has_bgendcolorr();
  inline void clear_has_bgendcolorr();
  inline void set_has_bgendcolorg();
  inline void clear_has_bgendcolorg();
  inline void set_has_bgendcolorb();
  inline void clear_has_bgendcolorb();
  inline void set_has_colortype();
  inline void clear_has_colortype();
  inline void set_has_bgcoloropacity();
  inline void clear_has_bgcoloropacity();
  inline void set_has_vectorx();
  inline void clear_has_vectorx();
  inline void set_has_vectory();
  inline void clear_has_vectory();
  inline void set_has_capinsetsx();
  inline void clear_has_capinsetsx();
  inline void set_has_capinsetsy();
  inline void clear_has_capinsetsy();
  inline void set_has_capinsetswidth();
  inline void clear_has_capinsetswidth();
  inline void set_has_capinsetsheight();
  inline void clear_has_capinsetsheight();
  inline void set_has_backgroundscale9enable();
  inline void clear_has_backgroundscale9enable();
  inline void set_has_innerwidth();
  inline void clear_has_innerwidth();
  inline void set_has_innerheight();
  inline void clear_has_innerheight();
  inline void set_has_direction();
  inline void clear_has_direction();
  inline void set_has_clipable();
  inline void clear_has_clipable();
  inline void set_has_bounceenable();
  inline void clear_has_bounceenable();
  inline void set_has_layouttype();
  inline void clear_has_layouttype();
  inline void set_has_scale9width();
  inline void clear_has_scale9width();
  inline void set_has_scale9height();
  inline void clear_has_scale9height();

  ::std::string* name_;
  ::std::string* classname_;
  ::std::string* backgroundimage_;
  ::protocolbuffers::ResourceData* backgroundimagedata_;
  ::google::protobuf::int32 bgcolorr_;
  ::google::protobuf::int32 bgcolorg_;
  ::google::protobuf::int32 bgcolorb_;
  ::google::protobuf::int32 bgstartcolorr_;
  ::google::protobuf::int32 bgstartcolorg_;
  ::google::protobuf::int32 bgstartcolorb_;
  ::google::protobuf::int32 bgendcolorr_;
  ::google::protobuf::int32 bgendcolorg_;
  ::google::protobuf::int32 bgendcolorb_;
  ::google::protobuf::int32 colortype_;
  ::google::protobuf::int32 bgcoloropacity_;
  float vectorx_;
  float vectory_;
  float capinsetsx_;
  float capinsetsy_;
  float capinsetswidth_;
  float capinsetsheight_;
  float innerwidth_;
  float innerheight_;
  ::google::protobuf::int32 direction_;
  bool backgroundscale9enable_;
  bool clipable_;
  bool bounceenable_;
  ::google::protobuf::int32 layouttype_;
  float scale9width_;
  float scale9height_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(30 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static ScrollViewOptions* default_instance_;
};
// -------------------------------------------------------------------

class SliderOptions : public ::google::protobuf::MessageLite {
 public:
  SliderOptions();
  virtual ~SliderOptions();

  SliderOptions(const SliderOptions& from);

  inline SliderOptions& operator=(const SliderOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const SliderOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SliderOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SliderOptions* other);

  // implements Message ----------------------------------------------

  SliderOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SliderOptions& from);
  void MergeFrom(const SliderOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string classname = 2;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 2;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  inline void set_allocated_classname(::std::string* classname);

  // optional string barFileName = 3;
  inline bool has_barfilename() const;
  inline void clear_barfilename();
  static const int kBarFileNameFieldNumber = 3;
  inline const ::std::string& barfilename() const;
  inline void set_barfilename(const ::std::string& value);
  inline void set_barfilename(const char* value);
  inline void set_barfilename(const char* value, size_t size);
  inline ::std::string* mutable_barfilename();
  inline ::std::string* release_barfilename();
  inline void set_allocated_barfilename(::std::string* barfilename);

  // optional string ballNormal = 4;
  inline bool has_ballnormal() const;
  inline void clear_ballnormal();
  static const int kBallNormalFieldNumber = 4;
  inline const ::std::string& ballnormal() const;
  inline void set_ballnormal(const ::std::string& value);
  inline void set_ballnormal(const char* value);
  inline void set_ballnormal(const char* value, size_t size);
  inline ::std::string* mutable_ballnormal();
  inline ::std::string* release_ballnormal();
  inline void set_allocated_ballnormal(::std::string* ballnormal);

  // optional string ballPressed = 5;
  inline bool has_ballpressed() const;
  inline void clear_ballpressed();
  static const int kBallPressedFieldNumber = 5;
  inline const ::std::string& ballpressed() const;
  inline void set_ballpressed(const ::std::string& value);
  inline void set_ballpressed(const char* value);
  inline void set_ballpressed(const char* value, size_t size);
  inline ::std::string* mutable_ballpressed();
  inline ::std::string* release_ballpressed();
  inline void set_allocated_ballpressed(::std::string* ballpressed);

  // optional string ballDisabled = 6;
  inline bool has_balldisabled() const;
  inline void clear_balldisabled();
  static const int kBallDisabledFieldNumber = 6;
  inline const ::std::string& balldisabled() const;
  inline void set_balldisabled(const ::std::string& value);
  inline void set_balldisabled(const char* value);
  inline void set_balldisabled(const char* value, size_t size);
  inline ::std::string* mutable_balldisabled();
  inline ::std::string* release_balldisabled();
  inline void set_allocated_balldisabled(::std::string* balldisabled);

  // optional .protocolbuffers.ResourceData barFileNameData = 7;
  inline bool has_barfilenamedata() const;
  inline void clear_barfilenamedata();
  static const int kBarFileNameDataFieldNumber = 7;
  inline const ::protocolbuffers::ResourceData& barfilenamedata() const;
  inline ::protocolbuffers::ResourceData* mutable_barfilenamedata();
  inline ::protocolbuffers::ResourceData* release_barfilenamedata();
  inline void set_allocated_barfilenamedata(::protocolbuffers::ResourceData* barfilenamedata);

  // optional .protocolbuffers.ResourceData ballNormalData = 8;
  inline bool has_ballnormaldata() const;
  inline void clear_ballnormaldata();
  static const int kBallNormalDataFieldNumber = 8;
  inline const ::protocolbuffers::ResourceData& ballnormaldata() const;
  inline ::protocolbuffers::ResourceData* mutable_ballnormaldata();
  inline ::protocolbuffers::ResourceData* release_ballnormaldata();
  inline void set_allocated_ballnormaldata(::protocolbuffers::ResourceData* ballnormaldata);

  // optional .protocolbuffers.ResourceData ballPressedData = 9;
  inline bool has_ballpresseddata() const;
  inline void clear_ballpresseddata();
  static const int kBallPressedDataFieldNumber = 9;
  inline const ::protocolbuffers::ResourceData& ballpresseddata() const;
  inline ::protocolbuffers::ResourceData* mutable_ballpresseddata();
  inline ::protocolbuffers::ResourceData* release_ballpresseddata();
  inline void set_allocated_ballpresseddata(::protocolbuffers::ResourceData* ballpresseddata);

  // optional .protocolbuffers.ResourceData ballDisabledData = 10;
  inline bool has_balldisableddata() const;
  inline void clear_balldisableddata();
  static const int kBallDisabledDataFieldNumber = 10;
  inline const ::protocolbuffers::ResourceData& balldisableddata() const;
  inline ::protocolbuffers::ResourceData* mutable_balldisableddata();
  inline ::protocolbuffers::ResourceData* release_balldisableddata();
  inline void set_allocated_balldisableddata(::protocolbuffers::ResourceData* balldisableddata);

  // optional .protocolbuffers.ResourceData progressBarData = 11;
  inline bool has_progressbardata() const;
  inline void clear_progressbardata();
  static const int kProgressBarDataFieldNumber = 11;
  inline const ::protocolbuffers::ResourceData& progressbardata() const;
  inline ::protocolbuffers::ResourceData* mutable_progressbardata();
  inline ::protocolbuffers::ResourceData* release_progressbardata();
  inline void set_allocated_progressbardata(::protocolbuffers::ResourceData* progressbardata);

  // optional int32 percent = 12;
  inline bool has_percent() const;
  inline void clear_percent();
  static const int kPercentFieldNumber = 12;
  inline ::google::protobuf::int32 percent() const;
  inline void set_percent(::google::protobuf::int32 value);

  // optional float capInsetsX = 13;
  inline bool has_capinsetsx() const;
  inline void clear_capinsetsx();
  static const int kCapInsetsXFieldNumber = 13;
  inline float capinsetsx() const;
  inline void set_capinsetsx(float value);

  // optional float capInsetsY = 14;
  inline bool has_capinsetsy() const;
  inline void clear_capinsetsy();
  static const int kCapInsetsYFieldNumber = 14;
  inline float capinsetsy() const;
  inline void set_capinsetsy(float value);

  // optional float capInsetsWidth = 15;
  inline bool has_capinsetswidth() const;
  inline void clear_capinsetswidth();
  static const int kCapInsetsWidthFieldNumber = 15;
  inline float capinsetswidth() const;
  inline void set_capinsetswidth(float value);

  // optional float capInsetsHeight = 16;
  inline bool has_capinsetsheight() const;
  inline void clear_capinsetsheight();
  static const int kCapInsetsHeightFieldNumber = 16;
  inline float capinsetsheight() const;
  inline void set_capinsetsheight(float value);

  // optional float barCapInsetsX = 17;
  inline bool has_barcapinsetsx() const;
  inline void clear_barcapinsetsx();
  static const int kBarCapInsetsXFieldNumber = 17;
  inline float barcapinsetsx() const;
  inline void set_barcapinsetsx(float value);

  // optional float barCapInsetsY = 18;
  inline bool has_barcapinsetsy() const;
  inline void clear_barcapinsetsy();
  static const int kBarCapInsetsYFieldNumber = 18;
  inline float barcapinsetsy() const;
  inline void set_barcapinsetsy(float value);

  // optional float barCapInsetsWidth = 19;
  inline bool has_barcapinsetswidth() const;
  inline void clear_barcapinsetswidth();
  static const int kBarCapInsetsWidthFieldNumber = 19;
  inline float barcapinsetswidth() const;
  inline void set_barcapinsetswidth(float value);

  // optional float barCapInsetsHeight = 20;
  inline bool has_barcapinsetsheight() const;
  inline void clear_barcapinsetsheight();
  static const int kBarCapInsetsHeightFieldNumber = 20;
  inline float barcapinsetsheight() const;
  inline void set_barcapinsetsheight(float value);

  // optional float progressBarCapInsetsX = 21;
  inline bool has_progressbarcapinsetsx() const;
  inline void clear_progressbarcapinsetsx();
  static const int kProgressBarCapInsetsXFieldNumber = 21;
  inline float progressbarcapinsetsx() const;
  inline void set_progressbarcapinsetsx(float value);

  // optional float progressBarCapInsetsY = 22;
  inline bool has_progressbarcapinsetsy() const;
  inline void clear_progressbarcapinsetsy();
  static const int kProgressBarCapInsetsYFieldNumber = 22;
  inline float progressbarcapinsetsy() const;
  inline void set_progressbarcapinsetsy(float value);

  // optional float progressBarCapInsetsWidth = 23;
  inline bool has_progressbarcapinsetswidth() const;
  inline void clear_progressbarcapinsetswidth();
  static const int kProgressBarCapInsetsWidthFieldNumber = 23;
  inline float progressbarcapinsetswidth() const;
  inline void set_progressbarcapinsetswidth(float value);

  // optional float progressBarCapInsetsHeight = 24;
  inline bool has_progressbarcapinsetsheight() const;
  inline void clear_progressbarcapinsetsheight();
  static const int kProgressBarCapInsetsHeightFieldNumber = 24;
  inline float progressbarcapinsetsheight() const;
  inline void set_progressbarcapinsetsheight(float value);

  // optional float scale9Width = 25;
  inline bool has_scale9width() const;
  inline void clear_scale9width();
  static const int kScale9WidthFieldNumber = 25;
  inline float scale9width() const;
  inline void set_scale9width(float value);

  // optional float scale9Height = 26;
  inline bool has_scale9height() const;
  inline void clear_scale9height();
  static const int kScale9HeightFieldNumber = 26;
  inline float scale9height() const;
  inline void set_scale9height(float value);

  // optional bool scale9Enable = 27;
  inline bool has_scale9enable() const;
  inline void clear_scale9enable();
  static const int kScale9EnableFieldNumber = 27;
  inline bool scale9enable() const;
  inline void set_scale9enable(bool value);

  // optional float slidBallAnchorPointX = 28;
  inline bool has_slidballanchorpointx() const;
  inline void clear_slidballanchorpointx();
  static const int kSlidBallAnchorPointXFieldNumber = 28;
  inline float slidballanchorpointx() const;
  inline void set_slidballanchorpointx(float value);

  // optional float slidBallAnchorPointY = 29;
  inline bool has_slidballanchorpointy() const;
  inline void clear_slidballanchorpointy();
  static const int kSlidBallAnchorPointYFieldNumber = 29;
  inline float slidballanchorpointy() const;
  inline void set_slidballanchorpointy(float value);

  // optional float length = 30;
  inline bool has_length() const;
  inline void clear_length();
  static const int kLengthFieldNumber = 30;
  inline float length() const;
  inline void set_length(float value);

  // optional bool displaystate = 31;
  inline bool has_displaystate() const;
  inline void clear_displaystate();
  static const int kDisplaystateFieldNumber = 31;
  inline bool displaystate() const;
  inline void set_displaystate(bool value);

  // @@protoc_insertion_point(class_scope:protocolbuffers.SliderOptions)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_barfilename();
  inline void clear_has_barfilename();
  inline void set_has_ballnormal();
  inline void clear_has_ballnormal();
  inline void set_has_ballpressed();
  inline void clear_has_ballpressed();
  inline void set_has_balldisabled();
  inline void clear_has_balldisabled();
  inline void set_has_barfilenamedata();
  inline void clear_has_barfilenamedata();
  inline void set_has_ballnormaldata();
  inline void clear_has_ballnormaldata();
  inline void set_has_ballpresseddata();
  inline void clear_has_ballpresseddata();
  inline void set_has_balldisableddata();
  inline void clear_has_balldisableddata();
  inline void set_has_progressbardata();
  inline void clear_has_progressbardata();
  inline void set_has_percent();
  inline void clear_has_percent();
  inline void set_has_capinsetsx();
  inline void clear_has_capinsetsx();
  inline void set_has_capinsetsy();
  inline void clear_has_capinsetsy();
  inline void set_has_capinsetswidth();
  inline void clear_has_capinsetswidth();
  inline void set_has_capinsetsheight();
  inline void clear_has_capinsetsheight();
  inline void set_has_barcapinsetsx();
  inline void clear_has_barcapinsetsx();
  inline void set_has_barcapinsetsy();
  inline void clear_has_barcapinsetsy();
  inline void set_has_barcapinsetswidth();
  inline void clear_has_barcapinsetswidth();
  inline void set_has_barcapinsetsheight();
  inline void clear_has_barcapinsetsheight();
  inline void set_has_progressbarcapinsetsx();
  inline void clear_has_progressbarcapinsetsx();
  inline void set_has_progressbarcapinsetsy();
  inline void clear_has_progressbarcapinsetsy();
  inline void set_has_progressbarcapinsetswidth();
  inline void clear_has_progressbarcapinsetswidth();
  inline void set_has_progressbarcapinsetsheight();
  inline void clear_has_progressbarcapinsetsheight();
  inline void set_has_scale9width();
  inline void clear_has_scale9width();
  inline void set_has_scale9height();
  inline void clear_has_scale9height();
  inline void set_has_scale9enable();
  inline void clear_has_scale9enable();
  inline void set_has_slidballanchorpointx();
  inline void clear_has_slidballanchorpointx();
  inline void set_has_slidballanchorpointy();
  inline void clear_has_slidballanchorpointy();
  inline void set_has_length();
  inline void clear_has_length();
  inline void set_has_displaystate();
  inline void clear_has_displaystate();

  ::std::string* name_;
  ::std::string* classname_;
  ::std::string* barfilename_;
  ::std::string* ballnormal_;
  ::std::string* ballpressed_;
  ::std::string* balldisabled_;
  ::protocolbuffers::ResourceData* barfilenamedata_;
  ::protocolbuffers::ResourceData* ballnormaldata_;
  ::protocolbuffers::ResourceData* ballpresseddata_;
  ::protocolbuffers::ResourceData* balldisableddata_;
  ::protocolbuffers::ResourceData* progressbardata_;
  ::google::protobuf::int32 percent_;
  float capinsetsx_;
  float capinsetsy_;
  float capinsetswidth_;
  float capinsetsheight_;
  float barcapinsetsx_;
  float barcapinsetsy_;
  float barcapinsetswidth_;
  float barcapinsetsheight_;
  float progressbarcapinsetsx_;
  float progressbarcapinsetsy_;
  float progressbarcapinsetswidth_;
  float progressbarcapinsetsheight_;
  float scale9width_;
  float scale9height_;
  float slidballanchorpointx_;
  float slidballanchorpointy_;
  bool scale9enable_;
  bool displaystate_;
  float length_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(31 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static SliderOptions* default_instance_;
};
// -------------------------------------------------------------------

class SpriteOptions : public ::google::protobuf::MessageLite {
 public:
  SpriteOptions();
  virtual ~SpriteOptions();

  SpriteOptions(const SpriteOptions& from);

  inline SpriteOptions& operator=(const SpriteOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const SpriteOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const SpriteOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(SpriteOptions* other);

  // implements Message ----------------------------------------------

  SpriteOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const SpriteOptions& from);
  void MergeFrom(const SpriteOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string classname = 2;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 2;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  inline void set_allocated_classname(::std::string* classname);

  // optional bool touchAble = 3;
  inline bool has_touchable() const;
  inline void clear_touchable();
  static const int kTouchAbleFieldNumber = 3;
  inline bool touchable() const;
  inline void set_touchable(bool value);

  // optional int32 positionType = 4;
  inline bool has_positiontype() const;
  inline void clear_positiontype();
  static const int kPositionTypeFieldNumber = 4;
  inline ::google::protobuf::int32 positiontype() const;
  inline void set_positiontype(::google::protobuf::int32 value);

  // optional float positionPercentX = 5;
  inline bool has_positionpercentx() const;
  inline void clear_positionpercentx();
  static const int kPositionPercentXFieldNumber = 5;
  inline float positionpercentx() const;
  inline void set_positionpercentx(float value);

  // optional float positionPercentY = 6;
  inline bool has_positionpercenty() const;
  inline void clear_positionpercenty();
  static const int kPositionPercentYFieldNumber = 6;
  inline float positionpercenty() const;
  inline void set_positionpercenty(float value);

  // optional int32 sizeType = 7;
  inline bool has_sizetype() const;
  inline void clear_sizetype();
  static const int kSizeTypeFieldNumber = 7;
  inline ::google::protobuf::int32 sizetype() const;
  inline void set_sizetype(::google::protobuf::int32 value);

  // optional float sizePercentX = 8;
  inline bool has_sizepercentx() const;
  inline void clear_sizepercentx();
  static const int kSizePercentXFieldNumber = 8;
  inline float sizepercentx() const;
  inline void set_sizepercentx(float value);

  // optional float sizePercentY = 9;
  inline bool has_sizepercenty() const;
  inline void clear_sizepercenty();
  static const int kSizePercentYFieldNumber = 9;
  inline float sizepercenty() const;
  inline void set_sizepercenty(float value);

  // optional bool useMergedTexture = 10;
  inline bool has_usemergedtexture() const;
  inline void clear_usemergedtexture();
  static const int kUseMergedTextureFieldNumber = 10;
  inline bool usemergedtexture() const;
  inline void set_usemergedtexture(bool value);

  // optional bool ignoreSize = 11;
  inline bool has_ignoresize() const;
  inline void clear_ignoresize();
  static const int kIgnoreSizeFieldNumber = 11;
  inline bool ignoresize() const;
  inline void set_ignoresize(bool value);

  // optional .protocolbuffers.LayoutParameter layoutParameter = 12;
  inline bool has_layoutparameter() const;
  inline void clear_layoutparameter();
  static const int kLayoutParameterFieldNumber = 12;
  inline const ::protocolbuffers::LayoutParameter& layoutparameter() const;
  inline ::protocolbuffers::LayoutParameter* mutable_layoutparameter();
  inline ::protocolbuffers::LayoutParameter* release_layoutparameter();
  inline void set_allocated_layoutparameter(::protocolbuffers::LayoutParameter* layoutparameter);

  // optional string customProperty = 13;
  inline bool has_customproperty() const;
  inline void clear_customproperty();
  static const int kCustomPropertyFieldNumber = 13;
  inline const ::std::string& customproperty() const;
  inline void set_customproperty(const ::std::string& value);
  inline void set_customproperty(const char* value);
  inline void set_customproperty(const char* value, size_t size);
  inline ::std::string* mutable_customproperty();
  inline ::std::string* release_customproperty();
  inline void set_allocated_customproperty(::std::string* customproperty);

  // optional string fileName = 14;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 14;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // optional bool flippedX = 15;
  inline bool has_flippedx() const;
  inline void clear_flippedx();
  static const int kFlippedXFieldNumber = 15;
  inline bool flippedx() const;
  inline void set_flippedx(bool value);

  // optional bool flippedY = 16;
  inline bool has_flippedy() const;
  inline void clear_flippedy();
  static const int kFlippedYFieldNumber = 16;
  inline bool flippedy() const;
  inline void set_flippedy(bool value);

  // optional .protocolbuffers.ResourceData fileNameData = 17;
  inline bool has_filenamedata() const;
  inline void clear_filenamedata();
  static const int kFileNameDataFieldNumber = 17;
  inline const ::protocolbuffers::ResourceData& filenamedata() const;
  inline ::protocolbuffers::ResourceData* mutable_filenamedata();
  inline ::protocolbuffers::ResourceData* release_filenamedata();
  inline void set_allocated_filenamedata(::protocolbuffers::ResourceData* filenamedata);

  // @@protoc_insertion_point(class_scope:protocolbuffers.SpriteOptions)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_touchable();
  inline void clear_has_touchable();
  inline void set_has_positiontype();
  inline void clear_has_positiontype();
  inline void set_has_positionpercentx();
  inline void clear_has_positionpercentx();
  inline void set_has_positionpercenty();
  inline void clear_has_positionpercenty();
  inline void set_has_sizetype();
  inline void clear_has_sizetype();
  inline void set_has_sizepercentx();
  inline void clear_has_sizepercentx();
  inline void set_has_sizepercenty();
  inline void clear_has_sizepercenty();
  inline void set_has_usemergedtexture();
  inline void clear_has_usemergedtexture();
  inline void set_has_ignoresize();
  inline void clear_has_ignoresize();
  inline void set_has_layoutparameter();
  inline void clear_has_layoutparameter();
  inline void set_has_customproperty();
  inline void clear_has_customproperty();
  inline void set_has_filename();
  inline void clear_has_filename();
  inline void set_has_flippedx();
  inline void clear_has_flippedx();
  inline void set_has_flippedy();
  inline void clear_has_flippedy();
  inline void set_has_filenamedata();
  inline void clear_has_filenamedata();

  ::std::string* name_;
  ::std::string* classname_;
  ::google::protobuf::int32 positiontype_;
  float positionpercentx_;
  float positionpercenty_;
  ::google::protobuf::int32 sizetype_;
  float sizepercentx_;
  float sizepercenty_;
  bool touchable_;
  bool usemergedtexture_;
  bool ignoresize_;
  bool flippedx_;
  bool flippedy_;
  ::protocolbuffers::LayoutParameter* layoutparameter_;
  ::std::string* customproperty_;
  ::std::string* filename_;
  ::protocolbuffers::ResourceData* filenamedata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static SpriteOptions* default_instance_;
};
// -------------------------------------------------------------------

class TextFieldOptions : public ::google::protobuf::MessageLite {
 public:
  TextFieldOptions();
  virtual ~TextFieldOptions();

  TextFieldOptions(const TextFieldOptions& from);

  inline TextFieldOptions& operator=(const TextFieldOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const TextFieldOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TextFieldOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TextFieldOptions* other);

  // implements Message ----------------------------------------------

  TextFieldOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TextFieldOptions& from);
  void MergeFrom(const TextFieldOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string classname = 2;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 2;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  inline void set_allocated_classname(::std::string* classname);

  // optional string fontName = 3;
  inline bool has_fontname() const;
  inline void clear_fontname();
  static const int kFontNameFieldNumber = 3;
  inline const ::std::string& fontname() const;
  inline void set_fontname(const ::std::string& value);
  inline void set_fontname(const char* value);
  inline void set_fontname(const char* value, size_t size);
  inline ::std::string* mutable_fontname();
  inline ::std::string* release_fontname();
  inline void set_allocated_fontname(::std::string* fontname);

  // optional .protocolbuffers.ResourceData fontFile = 4;
  inline bool has_fontfile() const;
  inline void clear_fontfile();
  static const int kFontFileFieldNumber = 4;
  inline const ::protocolbuffers::ResourceData& fontfile() const;
  inline ::protocolbuffers::ResourceData* mutable_fontfile();
  inline ::protocolbuffers::ResourceData* release_fontfile();
  inline void set_allocated_fontfile(::protocolbuffers::ResourceData* fontfile);

  // optional int32 fontSize = 5;
  inline bool has_fontsize() const;
  inline void clear_fontsize();
  static const int kFontSizeFieldNumber = 5;
  inline ::google::protobuf::int32 fontsize() const;
  inline void set_fontsize(::google::protobuf::int32 value);

  // optional string text = 6;
  inline bool has_text() const;
  inline void clear_text();
  static const int kTextFieldNumber = 6;
  inline const ::std::string& text() const;
  inline void set_text(const ::std::string& value);
  inline void set_text(const char* value);
  inline void set_text(const char* value, size_t size);
  inline ::std::string* mutable_text();
  inline ::std::string* release_text();
  inline void set_allocated_text(::std::string* text);

  // optional string placeHolder = 7;
  inline bool has_placeholder() const;
  inline void clear_placeholder();
  static const int kPlaceHolderFieldNumber = 7;
  inline const ::std::string& placeholder() const;
  inline void set_placeholder(const ::std::string& value);
  inline void set_placeholder(const char* value);
  inline void set_placeholder(const char* value, size_t size);
  inline ::std::string* mutable_placeholder();
  inline ::std::string* release_placeholder();
  inline void set_allocated_placeholder(::std::string* placeholder);

  // optional bool passwordEnable = 8;
  inline bool has_passwordenable() const;
  inline void clear_passwordenable();
  static const int kPasswordEnableFieldNumber = 8;
  inline bool passwordenable() const;
  inline void set_passwordenable(bool value);

  // optional string passwordStyleText = 9;
  inline bool has_passwordstyletext() const;
  inline void clear_passwordstyletext();
  static const int kPasswordStyleTextFieldNumber = 9;
  inline const ::std::string& passwordstyletext() const;
  inline void set_passwordstyletext(const ::std::string& value);
  inline void set_passwordstyletext(const char* value);
  inline void set_passwordstyletext(const char* value, size_t size);
  inline ::std::string* mutable_passwordstyletext();
  inline ::std::string* release_passwordstyletext();
  inline void set_allocated_passwordstyletext(::std::string* passwordstyletext);

  // optional bool maxLengthEnable = 10;
  inline bool has_maxlengthenable() const;
  inline void clear_maxlengthenable();
  static const int kMaxLengthEnableFieldNumber = 10;
  inline bool maxlengthenable() const;
  inline void set_maxlengthenable(bool value);

  // optional int32 maxLength = 11;
  inline bool has_maxlength() const;
  inline void clear_maxlength();
  static const int kMaxLengthFieldNumber = 11;
  inline ::google::protobuf::int32 maxlength() const;
  inline void set_maxlength(::google::protobuf::int32 value);

  // optional float areaWidth = 12;
  inline bool has_areawidth() const;
  inline void clear_areawidth();
  static const int kAreaWidthFieldNumber = 12;
  inline float areawidth() const;
  inline void set_areawidth(float value);

  // optional float areaHeight = 13;
  inline bool has_areaheight() const;
  inline void clear_areaheight();
  static const int kAreaHeightFieldNumber = 13;
  inline float areaheight() const;
  inline void set_areaheight(float value);

  // optional float anchorPointX = 15;
  inline bool has_anchorpointx() const;
  inline void clear_anchorpointx();
  static const int kAnchorPointXFieldNumber = 15;
  inline float anchorpointx() const;
  inline void set_anchorpointx(float value);

  // optional float anchorPointY = 16;
  inline bool has_anchorpointy() const;
  inline void clear_anchorpointy();
  static const int kAnchorPointYFieldNumber = 16;
  inline float anchorpointy() const;
  inline void set_anchorpointy(float value);

  // optional .protocolbuffers.ResourceData fontResource = 14;
  inline bool has_fontresource() const;
  inline void clear_fontresource();
  static const int kFontResourceFieldNumber = 14;
  inline const ::protocolbuffers::ResourceData& fontresource() const;
  inline ::protocolbuffers::ResourceData* mutable_fontresource();
  inline ::protocolbuffers::ResourceData* release_fontresource();
  inline void set_allocated_fontresource(::protocolbuffers::ResourceData* fontresource);

  // optional bool IsCustomSize = 17;
  inline bool has_iscustomsize() const;
  inline void clear_iscustomsize();
  static const int kIsCustomSizeFieldNumber = 17;
  inline bool iscustomsize() const;
  inline void set_iscustomsize(bool value);

  // @@protoc_insertion_point(class_scope:protocolbuffers.TextFieldOptions)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_fontname();
  inline void clear_has_fontname();
  inline void set_has_fontfile();
  inline void clear_has_fontfile();
  inline void set_has_fontsize();
  inline void clear_has_fontsize();
  inline void set_has_text();
  inline void clear_has_text();
  inline void set_has_placeholder();
  inline void clear_has_placeholder();
  inline void set_has_passwordenable();
  inline void clear_has_passwordenable();
  inline void set_has_passwordstyletext();
  inline void clear_has_passwordstyletext();
  inline void set_has_maxlengthenable();
  inline void clear_has_maxlengthenable();
  inline void set_has_maxlength();
  inline void clear_has_maxlength();
  inline void set_has_areawidth();
  inline void clear_has_areawidth();
  inline void set_has_areaheight();
  inline void clear_has_areaheight();
  inline void set_has_anchorpointx();
  inline void clear_has_anchorpointx();
  inline void set_has_anchorpointy();
  inline void clear_has_anchorpointy();
  inline void set_has_fontresource();
  inline void clear_has_fontresource();
  inline void set_has_iscustomsize();
  inline void clear_has_iscustomsize();

  ::std::string* name_;
  ::std::string* classname_;
  ::std::string* fontname_;
  ::protocolbuffers::ResourceData* fontfile_;
  ::std::string* text_;
  ::std::string* placeholder_;
  ::google::protobuf::int32 fontsize_;
  ::google::protobuf::int32 maxlength_;
  ::std::string* passwordstyletext_;
  bool passwordenable_;
  bool maxlengthenable_;
  bool iscustomsize_;
  float areawidth_;
  float areaheight_;
  float anchorpointx_;
  ::protocolbuffers::ResourceData* fontresource_;
  float anchorpointy_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(17 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static TextFieldOptions* default_instance_;
};
// -------------------------------------------------------------------

class TMXTiledMapOptions : public ::google::protobuf::MessageLite {
 public:
  TMXTiledMapOptions();
  virtual ~TMXTiledMapOptions();

  TMXTiledMapOptions(const TMXTiledMapOptions& from);

  inline TMXTiledMapOptions& operator=(const TMXTiledMapOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const TMXTiledMapOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TMXTiledMapOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TMXTiledMapOptions* other);

  // implements Message ----------------------------------------------

  TMXTiledMapOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TMXTiledMapOptions& from);
  void MergeFrom(const TMXTiledMapOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string tmxFile = 1;
  inline bool has_tmxfile() const;
  inline void clear_tmxfile();
  static const int kTmxFileFieldNumber = 1;
  inline const ::std::string& tmxfile() const;
  inline void set_tmxfile(const ::std::string& value);
  inline void set_tmxfile(const char* value);
  inline void set_tmxfile(const char* value, size_t size);
  inline ::std::string* mutable_tmxfile();
  inline ::std::string* release_tmxfile();
  inline void set_allocated_tmxfile(::std::string* tmxfile);

  // optional string tmxString = 2;
  inline bool has_tmxstring() const;
  inline void clear_tmxstring();
  static const int kTmxStringFieldNumber = 2;
  inline const ::std::string& tmxstring() const;
  inline void set_tmxstring(const ::std::string& value);
  inline void set_tmxstring(const char* value);
  inline void set_tmxstring(const char* value, size_t size);
  inline ::std::string* mutable_tmxstring();
  inline ::std::string* release_tmxstring();
  inline void set_allocated_tmxstring(::std::string* tmxstring);

  // optional string resourcePath = 3;
  inline bool has_resourcepath() const;
  inline void clear_resourcepath();
  static const int kResourcePathFieldNumber = 3;
  inline const ::std::string& resourcepath() const;
  inline void set_resourcepath(const ::std::string& value);
  inline void set_resourcepath(const char* value);
  inline void set_resourcepath(const char* value, size_t size);
  inline ::std::string* mutable_resourcepath();
  inline ::std::string* release_resourcepath();
  inline void set_allocated_resourcepath(::std::string* resourcepath);

  // optional .protocolbuffers.ResourceData fileNameData = 4;
  inline bool has_filenamedata() const;
  inline void clear_filenamedata();
  static const int kFileNameDataFieldNumber = 4;
  inline const ::protocolbuffers::ResourceData& filenamedata() const;
  inline ::protocolbuffers::ResourceData* mutable_filenamedata();
  inline ::protocolbuffers::ResourceData* release_filenamedata();
  inline void set_allocated_filenamedata(::protocolbuffers::ResourceData* filenamedata);

  // @@protoc_insertion_point(class_scope:protocolbuffers.TMXTiledMapOptions)
 private:
  inline void set_has_tmxfile();
  inline void clear_has_tmxfile();
  inline void set_has_tmxstring();
  inline void clear_has_tmxstring();
  inline void set_has_resourcepath();
  inline void clear_has_resourcepath();
  inline void set_has_filenamedata();
  inline void clear_has_filenamedata();

  ::std::string* tmxfile_;
  ::std::string* tmxstring_;
  ::std::string* resourcepath_;
  ::protocolbuffers::ResourceData* filenamedata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(4 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static TMXTiledMapOptions* default_instance_;
};
// -------------------------------------------------------------------

class ParticleSystemOptions : public ::google::protobuf::MessageLite {
 public:
  ParticleSystemOptions();
  virtual ~ParticleSystemOptions();

  ParticleSystemOptions(const ParticleSystemOptions& from);

  inline ParticleSystemOptions& operator=(const ParticleSystemOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const ParticleSystemOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ParticleSystemOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ParticleSystemOptions* other);

  // implements Message ----------------------------------------------

  ParticleSystemOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ParticleSystemOptions& from);
  void MergeFrom(const ParticleSystemOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string plistFile = 1;
  inline bool has_plistfile() const;
  inline void clear_plistfile();
  static const int kPlistFileFieldNumber = 1;
  inline const ::std::string& plistfile() const;
  inline void set_plistfile(const ::std::string& value);
  inline void set_plistfile(const char* value);
  inline void set_plistfile(const char* value, size_t size);
  inline ::std::string* mutable_plistfile();
  inline ::std::string* release_plistfile();
  inline void set_allocated_plistfile(::std::string* plistfile);

  // optional int32 totalParticles = 2;
  inline bool has_totalparticles() const;
  inline void clear_totalparticles();
  static const int kTotalParticlesFieldNumber = 2;
  inline ::google::protobuf::int32 totalparticles() const;
  inline void set_totalparticles(::google::protobuf::int32 value);

  // optional .protocolbuffers.ResourceData fileNameData = 3;
  inline bool has_filenamedata() const;
  inline void clear_filenamedata();
  static const int kFileNameDataFieldNumber = 3;
  inline const ::protocolbuffers::ResourceData& filenamedata() const;
  inline ::protocolbuffers::ResourceData* mutable_filenamedata();
  inline ::protocolbuffers::ResourceData* release_filenamedata();
  inline void set_allocated_filenamedata(::protocolbuffers::ResourceData* filenamedata);

  // @@protoc_insertion_point(class_scope:protocolbuffers.ParticleSystemOptions)
 private:
  inline void set_has_plistfile();
  inline void clear_has_plistfile();
  inline void set_has_totalparticles();
  inline void clear_has_totalparticles();
  inline void set_has_filenamedata();
  inline void clear_has_filenamedata();

  ::std::string* plistfile_;
  ::protocolbuffers::ResourceData* filenamedata_;
  ::google::protobuf::int32 totalparticles_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(3 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static ParticleSystemOptions* default_instance_;
};
// -------------------------------------------------------------------

class ProjectNodeOptions : public ::google::protobuf::MessageLite {
 public:
  ProjectNodeOptions();
  virtual ~ProjectNodeOptions();

  ProjectNodeOptions(const ProjectNodeOptions& from);

  inline ProjectNodeOptions& operator=(const ProjectNodeOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const ProjectNodeOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ProjectNodeOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ProjectNodeOptions* other);

  // implements Message ----------------------------------------------

  ProjectNodeOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ProjectNodeOptions& from);
  void MergeFrom(const ProjectNodeOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string fileName = 1;
  inline bool has_filename() const;
  inline void clear_filename();
  static const int kFileNameFieldNumber = 1;
  inline const ::std::string& filename() const;
  inline void set_filename(const ::std::string& value);
  inline void set_filename(const char* value);
  inline void set_filename(const char* value, size_t size);
  inline ::std::string* mutable_filename();
  inline ::std::string* release_filename();
  inline void set_allocated_filename(::std::string* filename);

  // @@protoc_insertion_point(class_scope:protocolbuffers.ProjectNodeOptions)
 private:
  inline void set_has_filename();
  inline void clear_has_filename();

  ::std::string* filename_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(1 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static ProjectNodeOptions* default_instance_;
};
// -------------------------------------------------------------------

class ComponentOptions : public ::google::protobuf::MessageLite {
 public:
  ComponentOptions();
  virtual ~ComponentOptions();

  ComponentOptions(const ComponentOptions& from);

  inline ComponentOptions& operator=(const ComponentOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const ComponentOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ComponentOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ComponentOptions* other);

  // implements Message ----------------------------------------------

  ComponentOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ComponentOptions& from);
  void MergeFrom(const ComponentOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string type = 1;
  inline bool has_type() const;
  inline void clear_type();
  static const int kTypeFieldNumber = 1;
  inline const ::std::string& type() const;
  inline void set_type(const ::std::string& value);
  inline void set_type(const char* value);
  inline void set_type(const char* value, size_t size);
  inline ::std::string* mutable_type();
  inline ::std::string* release_type();
  inline void set_allocated_type(::std::string* type);

  // optional .protocolbuffers.ComAudioOptions comAudioOptions = 2;
  inline bool has_comaudiooptions() const;
  inline void clear_comaudiooptions();
  static const int kComAudioOptionsFieldNumber = 2;
  inline const ::protocolbuffers::ComAudioOptions& comaudiooptions() const;
  inline ::protocolbuffers::ComAudioOptions* mutable_comaudiooptions();
  inline ::protocolbuffers::ComAudioOptions* release_comaudiooptions();
  inline void set_allocated_comaudiooptions(::protocolbuffers::ComAudioOptions* comaudiooptions);

  // @@protoc_insertion_point(class_scope:protocolbuffers.ComponentOptions)
 private:
  inline void set_has_type();
  inline void clear_has_type();
  inline void set_has_comaudiooptions();
  inline void clear_has_comaudiooptions();

  ::std::string* type_;
  ::protocolbuffers::ComAudioOptions* comaudiooptions_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(2 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static ComponentOptions* default_instance_;
};
// -------------------------------------------------------------------

class ComAudioOptions : public ::google::protobuf::MessageLite {
 public:
  ComAudioOptions();
  virtual ~ComAudioOptions();

  ComAudioOptions(const ComAudioOptions& from);

  inline ComAudioOptions& operator=(const ComAudioOptions& from) {
    CopyFrom(from);
    return *this;
  }

  static const ComAudioOptions& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const ComAudioOptions* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(ComAudioOptions* other);

  // implements Message ----------------------------------------------

  ComAudioOptions* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const ComAudioOptions& from);
  void MergeFrom(const ComAudioOptions& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional bool enabled = 2;
  inline bool has_enabled() const;
  inline void clear_enabled();
  static const int kEnabledFieldNumber = 2;
  inline bool enabled() const;
  inline void set_enabled(bool value);

  // optional bool loop = 3;
  inline bool has_loop() const;
  inline void clear_loop();
  static const int kLoopFieldNumber = 3;
  inline bool loop() const;
  inline void set_loop(bool value);

  // optional int32 volume = 4;
  inline bool has_volume() const;
  inline void clear_volume();
  static const int kVolumeFieldNumber = 4;
  inline ::google::protobuf::int32 volume() const;
  inline void set_volume(::google::protobuf::int32 value);

  // optional .protocolbuffers.ResourceData fileNameData = 5;
  inline bool has_filenamedata() const;
  inline void clear_filenamedata();
  static const int kFileNameDataFieldNumber = 5;
  inline const ::protocolbuffers::ResourceData& filenamedata() const;
  inline ::protocolbuffers::ResourceData* mutable_filenamedata();
  inline ::protocolbuffers::ResourceData* release_filenamedata();
  inline void set_allocated_filenamedata(::protocolbuffers::ResourceData* filenamedata);

  // @@protoc_insertion_point(class_scope:protocolbuffers.ComAudioOptions)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_enabled();
  inline void clear_has_enabled();
  inline void set_has_loop();
  inline void clear_has_loop();
  inline void set_has_volume();
  inline void clear_has_volume();
  inline void set_has_filenamedata();
  inline void clear_has_filenamedata();

  ::std::string* name_;
  bool enabled_;
  bool loop_;
  ::google::protobuf::int32 volume_;
  ::protocolbuffers::ResourceData* filenamedata_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static ComAudioOptions* default_instance_;
};
// -------------------------------------------------------------------

class NodeAction : public ::google::protobuf::MessageLite {
 public:
  NodeAction();
  virtual ~NodeAction();

  NodeAction(const NodeAction& from);

  inline NodeAction& operator=(const NodeAction& from) {
    CopyFrom(from);
    return *this;
  }

  static const NodeAction& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const NodeAction* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(NodeAction* other);

  // implements Message ----------------------------------------------

  NodeAction* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const NodeAction& from);
  void MergeFrom(const NodeAction& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string classname = 2;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 2;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  inline void set_allocated_classname(::std::string* classname);

  // optional int32 duration = 3;
  inline bool has_duration() const;
  inline void clear_duration();
  static const int kDurationFieldNumber = 3;
  inline ::google::protobuf::int32 duration() const;
  inline void set_duration(::google::protobuf::int32 value);

  // optional float speed = 4;
  inline bool has_speed() const;
  inline void clear_speed();
  static const int kSpeedFieldNumber = 4;
  inline float speed() const;
  inline void set_speed(float value);

  // repeated .protocolbuffers.TimeLine timelines = 5;
  inline int timelines_size() const;
  inline void clear_timelines();
  static const int kTimelinesFieldNumber = 5;
  inline const ::protocolbuffers::TimeLine& timelines(int index) const;
  inline ::protocolbuffers::TimeLine* mutable_timelines(int index);
  inline ::protocolbuffers::TimeLine* add_timelines();
  inline const ::google::protobuf::RepeatedPtrField< ::protocolbuffers::TimeLine >&
      timelines() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocolbuffers::TimeLine >*
      mutable_timelines();

  // @@protoc_insertion_point(class_scope:protocolbuffers.NodeAction)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_duration();
  inline void clear_has_duration();
  inline void set_has_speed();
  inline void clear_has_speed();

  ::std::string* name_;
  ::std::string* classname_;
  ::google::protobuf::int32 duration_;
  float speed_;
  ::google::protobuf::RepeatedPtrField< ::protocolbuffers::TimeLine > timelines_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static NodeAction* default_instance_;
};
// -------------------------------------------------------------------

class TimeLine : public ::google::protobuf::MessageLite {
 public:
  TimeLine();
  virtual ~TimeLine();

  TimeLine(const TimeLine& from);

  inline TimeLine& operator=(const TimeLine& from) {
    CopyFrom(from);
    return *this;
  }

  static const TimeLine& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TimeLine* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TimeLine* other);

  // implements Message ----------------------------------------------

  TimeLine* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TimeLine& from);
  void MergeFrom(const TimeLine& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string classname = 2;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 2;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  inline void set_allocated_classname(::std::string* classname);

  // optional string frameType = 3;
  inline bool has_frametype() const;
  inline void clear_frametype();
  static const int kFrameTypeFieldNumber = 3;
  inline const ::std::string& frametype() const;
  inline void set_frametype(const ::std::string& value);
  inline void set_frametype(const char* value);
  inline void set_frametype(const char* value, size_t size);
  inline ::std::string* mutable_frametype();
  inline ::std::string* release_frametype();
  inline void set_allocated_frametype(::std::string* frametype);

  // optional int32 actionTag = 4;
  inline bool has_actiontag() const;
  inline void clear_actiontag();
  static const int kActionTagFieldNumber = 4;
  inline ::google::protobuf::int32 actiontag() const;
  inline void set_actiontag(::google::protobuf::int32 value);

  // repeated .protocolbuffers.Frame frames = 5;
  inline int frames_size() const;
  inline void clear_frames();
  static const int kFramesFieldNumber = 5;
  inline const ::protocolbuffers::Frame& frames(int index) const;
  inline ::protocolbuffers::Frame* mutable_frames(int index);
  inline ::protocolbuffers::Frame* add_frames();
  inline const ::google::protobuf::RepeatedPtrField< ::protocolbuffers::Frame >&
      frames() const;
  inline ::google::protobuf::RepeatedPtrField< ::protocolbuffers::Frame >*
      mutable_frames();

  // @@protoc_insertion_point(class_scope:protocolbuffers.TimeLine)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_frametype();
  inline void clear_has_frametype();
  inline void set_has_actiontag();
  inline void clear_has_actiontag();

  ::std::string* name_;
  ::std::string* classname_;
  ::std::string* frametype_;
  ::google::protobuf::RepeatedPtrField< ::protocolbuffers::Frame > frames_;
  ::google::protobuf::int32 actiontag_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static TimeLine* default_instance_;
};
// -------------------------------------------------------------------

class Frame : public ::google::protobuf::MessageLite {
 public:
  Frame();
  virtual ~Frame();

  Frame(const Frame& from);

  inline Frame& operator=(const Frame& from) {
    CopyFrom(from);
    return *this;
  }

  static const Frame& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const Frame* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(Frame* other);

  // implements Message ----------------------------------------------

  Frame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const Frame& from);
  void MergeFrom(const Frame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .protocolbuffers.TimeLineBoolFrame visibleFrame = 5;
  inline bool has_visibleframe() const;
  inline void clear_visibleframe();
  static const int kVisibleFrameFieldNumber = 5;
  inline const ::protocolbuffers::TimeLineBoolFrame& visibleframe() const;
  inline ::protocolbuffers::TimeLineBoolFrame* mutable_visibleframe();
  inline ::protocolbuffers::TimeLineBoolFrame* release_visibleframe();
  inline void set_allocated_visibleframe(::protocolbuffers::TimeLineBoolFrame* visibleframe);

  // optional .protocolbuffers.TimeLineIntFrame zOrderFrame = 6;
  inline bool has_zorderframe() const;
  inline void clear_zorderframe();
  static const int kZOrderFrameFieldNumber = 6;
  inline const ::protocolbuffers::TimeLineIntFrame& zorderframe() const;
  inline ::protocolbuffers::TimeLineIntFrame* mutable_zorderframe();
  inline ::protocolbuffers::TimeLineIntFrame* release_zorderframe();
  inline void set_allocated_zorderframe(::protocolbuffers::TimeLineIntFrame* zorderframe);

  // optional .protocolbuffers.TimeLinePointFrame rotationSkewFrame = 7;
  inline bool has_rotationskewframe() const;
  inline void clear_rotationskewframe();
  static const int kRotationSkewFrameFieldNumber = 7;
  inline const ::protocolbuffers::TimeLinePointFrame& rotationskewframe() const;
  inline ::protocolbuffers::TimeLinePointFrame* mutable_rotationskewframe();
  inline ::protocolbuffers::TimeLinePointFrame* release_rotationskewframe();
  inline void set_allocated_rotationskewframe(::protocolbuffers::TimeLinePointFrame* rotationskewframe);

  // optional .protocolbuffers.TimeLineStringFrame eventFrame = 8;
  inline bool has_eventframe() const;
  inline void clear_eventframe();
  static const int kEventFrameFieldNumber = 8;
  inline const ::protocolbuffers::TimeLineStringFrame& eventframe() const;
  inline ::protocolbuffers::TimeLineStringFrame* mutable_eventframe();
  inline ::protocolbuffers::TimeLineStringFrame* release_eventframe();
  inline void set_allocated_eventframe(::protocolbuffers::TimeLineStringFrame* eventframe);

  // optional .protocolbuffers.TimeLinePointFrame anchorPointFrame = 9;
  inline bool has_anchorpointframe() const;
  inline void clear_anchorpointframe();
  static const int kAnchorPointFrameFieldNumber = 9;
  inline const ::protocolbuffers::TimeLinePointFrame& anchorpointframe() const;
  inline ::protocolbuffers::TimeLinePointFrame* mutable_anchorpointframe();
  inline ::protocolbuffers::TimeLinePointFrame* release_anchorpointframe();
  inline void set_allocated_anchorpointframe(::protocolbuffers::TimeLinePointFrame* anchorpointframe);

  // optional .protocolbuffers.TimeLinePointFrame positionFrame = 10;
  inline bool has_positionframe() const;
  inline void clear_positionframe();
  static const int kPositionFrameFieldNumber = 10;
  inline const ::protocolbuffers::TimeLinePointFrame& positionframe() const;
  inline ::protocolbuffers::TimeLinePointFrame* mutable_positionframe();
  inline ::protocolbuffers::TimeLinePointFrame* release_positionframe();
  inline void set_allocated_positionframe(::protocolbuffers::TimeLinePointFrame* positionframe);

  // optional .protocolbuffers.TimeLinePointFrame scaleFrame = 11;
  inline bool has_scaleframe() const;
  inline void clear_scaleframe();
  static const int kScaleFrameFieldNumber = 11;
  inline const ::protocolbuffers::TimeLinePointFrame& scaleframe() const;
  inline ::protocolbuffers::TimeLinePointFrame* mutable_scaleframe();
  inline ::protocolbuffers::TimeLinePointFrame* release_scaleframe();
  inline void set_allocated_scaleframe(::protocolbuffers::TimeLinePointFrame* scaleframe);

  // optional .protocolbuffers.TimeLineColorFrame colorFrame = 12;
  inline bool has_colorframe() const;
  inline void clear_colorframe();
  static const int kColorFrameFieldNumber = 12;
  inline const ::protocolbuffers::TimeLineColorFrame& colorframe() const;
  inline ::protocolbuffers::TimeLineColorFrame* mutable_colorframe();
  inline ::protocolbuffers::TimeLineColorFrame* release_colorframe();
  inline void set_allocated_colorframe(::protocolbuffers::TimeLineColorFrame* colorframe);

  // optional .protocolbuffers.TimeLineTextureFrame textureFrame = 13;
  inline bool has_textureframe() const;
  inline void clear_textureframe();
  static const int kTextureFrameFieldNumber = 13;
  inline const ::protocolbuffers::TimeLineTextureFrame& textureframe() const;
  inline ::protocolbuffers::TimeLineTextureFrame* mutable_textureframe();
  inline ::protocolbuffers::TimeLineTextureFrame* release_textureframe();
  inline void set_allocated_textureframe(::protocolbuffers::TimeLineTextureFrame* textureframe);

  // @@protoc_insertion_point(class_scope:protocolbuffers.Frame)
 private:
  inline void set_has_visibleframe();
  inline void clear_has_visibleframe();
  inline void set_has_zorderframe();
  inline void clear_has_zorderframe();
  inline void set_has_rotationskewframe();
  inline void clear_has_rotationskewframe();
  inline void set_has_eventframe();
  inline void clear_has_eventframe();
  inline void set_has_anchorpointframe();
  inline void clear_has_anchorpointframe();
  inline void set_has_positionframe();
  inline void clear_has_positionframe();
  inline void set_has_scaleframe();
  inline void clear_has_scaleframe();
  inline void set_has_colorframe();
  inline void clear_has_colorframe();
  inline void set_has_textureframe();
  inline void clear_has_textureframe();

  ::protocolbuffers::TimeLineBoolFrame* visibleframe_;
  ::protocolbuffers::TimeLineIntFrame* zorderframe_;
  ::protocolbuffers::TimeLinePointFrame* rotationskewframe_;
  ::protocolbuffers::TimeLineStringFrame* eventframe_;
  ::protocolbuffers::TimeLinePointFrame* anchorpointframe_;
  ::protocolbuffers::TimeLinePointFrame* positionframe_;
  ::protocolbuffers::TimeLinePointFrame* scaleframe_;
  ::protocolbuffers::TimeLineColorFrame* colorframe_;
  ::protocolbuffers::TimeLineTextureFrame* textureframe_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(9 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static Frame* default_instance_;
};
// -------------------------------------------------------------------

class TimeLineBoolFrame : public ::google::protobuf::MessageLite {
 public:
  TimeLineBoolFrame();
  virtual ~TimeLineBoolFrame();

  TimeLineBoolFrame(const TimeLineBoolFrame& from);

  inline TimeLineBoolFrame& operator=(const TimeLineBoolFrame& from) {
    CopyFrom(from);
    return *this;
  }

  static const TimeLineBoolFrame& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TimeLineBoolFrame* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TimeLineBoolFrame* other);

  // implements Message ----------------------------------------------

  TimeLineBoolFrame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TimeLineBoolFrame& from);
  void MergeFrom(const TimeLineBoolFrame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string classname = 2;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 2;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  inline void set_allocated_classname(::std::string* classname);

  // optional int32 frameIndex = 3;
  inline bool has_frameindex() const;
  inline void clear_frameindex();
  static const int kFrameIndexFieldNumber = 3;
  inline ::google::protobuf::int32 frameindex() const;
  inline void set_frameindex(::google::protobuf::int32 value);

  // optional bool tween = 4;
  inline bool has_tween() const;
  inline void clear_tween();
  static const int kTweenFieldNumber = 4;
  inline bool tween() const;
  inline void set_tween(bool value);

  // optional bool value = 5;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 5;
  inline bool value() const;
  inline void set_value(bool value);

  // @@protoc_insertion_point(class_scope:protocolbuffers.TimeLineBoolFrame)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_frameindex();
  inline void clear_has_frameindex();
  inline void set_has_tween();
  inline void clear_has_tween();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string* name_;
  ::std::string* classname_;
  ::google::protobuf::int32 frameindex_;
  bool tween_;
  bool value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static TimeLineBoolFrame* default_instance_;
};
// -------------------------------------------------------------------

class TimeLineIntFrame : public ::google::protobuf::MessageLite {
 public:
  TimeLineIntFrame();
  virtual ~TimeLineIntFrame();

  TimeLineIntFrame(const TimeLineIntFrame& from);

  inline TimeLineIntFrame& operator=(const TimeLineIntFrame& from) {
    CopyFrom(from);
    return *this;
  }

  static const TimeLineIntFrame& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TimeLineIntFrame* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TimeLineIntFrame* other);

  // implements Message ----------------------------------------------

  TimeLineIntFrame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TimeLineIntFrame& from);
  void MergeFrom(const TimeLineIntFrame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string classname = 2;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 2;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  inline void set_allocated_classname(::std::string* classname);

  // optional int32 frameIndex = 3;
  inline bool has_frameindex() const;
  inline void clear_frameindex();
  static const int kFrameIndexFieldNumber = 3;
  inline ::google::protobuf::int32 frameindex() const;
  inline void set_frameindex(::google::protobuf::int32 value);

  // optional bool tween = 4;
  inline bool has_tween() const;
  inline void clear_tween();
  static const int kTweenFieldNumber = 4;
  inline bool tween() const;
  inline void set_tween(bool value);

  // optional int32 value = 5;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 5;
  inline ::google::protobuf::int32 value() const;
  inline void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocolbuffers.TimeLineIntFrame)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_frameindex();
  inline void clear_has_frameindex();
  inline void set_has_tween();
  inline void clear_has_tween();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string* name_;
  ::std::string* classname_;
  ::google::protobuf::int32 frameindex_;
  bool tween_;
  ::google::protobuf::int32 value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static TimeLineIntFrame* default_instance_;
};
// -------------------------------------------------------------------

class TimeLineStringFrame : public ::google::protobuf::MessageLite {
 public:
  TimeLineStringFrame();
  virtual ~TimeLineStringFrame();

  TimeLineStringFrame(const TimeLineStringFrame& from);

  inline TimeLineStringFrame& operator=(const TimeLineStringFrame& from) {
    CopyFrom(from);
    return *this;
  }

  static const TimeLineStringFrame& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TimeLineStringFrame* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TimeLineStringFrame* other);

  // implements Message ----------------------------------------------

  TimeLineStringFrame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TimeLineStringFrame& from);
  void MergeFrom(const TimeLineStringFrame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string classname = 2;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 2;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  inline void set_allocated_classname(::std::string* classname);

  // optional int32 frameIndex = 3;
  inline bool has_frameindex() const;
  inline void clear_frameindex();
  static const int kFrameIndexFieldNumber = 3;
  inline ::google::protobuf::int32 frameindex() const;
  inline void set_frameindex(::google::protobuf::int32 value);

  // optional bool tween = 4;
  inline bool has_tween() const;
  inline void clear_tween();
  static const int kTweenFieldNumber = 4;
  inline bool tween() const;
  inline void set_tween(bool value);

  // optional string value = 5;
  inline bool has_value() const;
  inline void clear_value();
  static const int kValueFieldNumber = 5;
  inline const ::std::string& value() const;
  inline void set_value(const ::std::string& value);
  inline void set_value(const char* value);
  inline void set_value(const char* value, size_t size);
  inline ::std::string* mutable_value();
  inline ::std::string* release_value();
  inline void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:protocolbuffers.TimeLineStringFrame)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_frameindex();
  inline void clear_has_frameindex();
  inline void set_has_tween();
  inline void clear_has_tween();
  inline void set_has_value();
  inline void clear_has_value();

  ::std::string* name_;
  ::std::string* classname_;
  ::google::protobuf::int32 frameindex_;
  bool tween_;
  ::std::string* value_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(5 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static TimeLineStringFrame* default_instance_;
};
// -------------------------------------------------------------------

class TimeLinePointFrame : public ::google::protobuf::MessageLite {
 public:
  TimeLinePointFrame();
  virtual ~TimeLinePointFrame();

  TimeLinePointFrame(const TimeLinePointFrame& from);

  inline TimeLinePointFrame& operator=(const TimeLinePointFrame& from) {
    CopyFrom(from);
    return *this;
  }

  static const TimeLinePointFrame& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TimeLinePointFrame* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TimeLinePointFrame* other);

  // implements Message ----------------------------------------------

  TimeLinePointFrame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TimeLinePointFrame& from);
  void MergeFrom(const TimeLinePointFrame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string classname = 2;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 2;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  inline void set_allocated_classname(::std::string* classname);

  // optional int32 frameIndex = 3;
  inline bool has_frameindex() const;
  inline void clear_frameindex();
  static const int kFrameIndexFieldNumber = 3;
  inline ::google::protobuf::int32 frameindex() const;
  inline void set_frameindex(::google::protobuf::int32 value);

  // optional bool tween = 4;
  inline bool has_tween() const;
  inline void clear_tween();
  static const int kTweenFieldNumber = 4;
  inline bool tween() const;
  inline void set_tween(bool value);

  // optional float x = 5;
  inline bool has_x() const;
  inline void clear_x();
  static const int kXFieldNumber = 5;
  inline float x() const;
  inline void set_x(float value);

  // optional float y = 6;
  inline bool has_y() const;
  inline void clear_y();
  static const int kYFieldNumber = 6;
  inline float y() const;
  inline void set_y(float value);

  // @@protoc_insertion_point(class_scope:protocolbuffers.TimeLinePointFrame)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_frameindex();
  inline void clear_has_frameindex();
  inline void set_has_tween();
  inline void clear_has_tween();
  inline void set_has_x();
  inline void clear_has_x();
  inline void set_has_y();
  inline void clear_has_y();

  ::std::string* name_;
  ::std::string* classname_;
  ::google::protobuf::int32 frameindex_;
  bool tween_;
  float x_;
  float y_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static TimeLinePointFrame* default_instance_;
};
// -------------------------------------------------------------------

class TimeLineColorFrame : public ::google::protobuf::MessageLite {
 public:
  TimeLineColorFrame();
  virtual ~TimeLineColorFrame();

  TimeLineColorFrame(const TimeLineColorFrame& from);

  inline TimeLineColorFrame& operator=(const TimeLineColorFrame& from) {
    CopyFrom(from);
    return *this;
  }

  static const TimeLineColorFrame& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TimeLineColorFrame* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TimeLineColorFrame* other);

  // implements Message ----------------------------------------------

  TimeLineColorFrame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TimeLineColorFrame& from);
  void MergeFrom(const TimeLineColorFrame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string classname = 2;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 2;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  inline void set_allocated_classname(::std::string* classname);

  // optional int32 frameIndex = 3;
  inline bool has_frameindex() const;
  inline void clear_frameindex();
  static const int kFrameIndexFieldNumber = 3;
  inline ::google::protobuf::int32 frameindex() const;
  inline void set_frameindex(::google::protobuf::int32 value);

  // optional bool tween = 4;
  inline bool has_tween() const;
  inline void clear_tween();
  static const int kTweenFieldNumber = 4;
  inline bool tween() const;
  inline void set_tween(bool value);

  // optional int32 alpha = 5;
  inline bool has_alpha() const;
  inline void clear_alpha();
  static const int kAlphaFieldNumber = 5;
  inline ::google::protobuf::int32 alpha() const;
  inline void set_alpha(::google::protobuf::int32 value);

  // optional int32 red = 6;
  inline bool has_red() const;
  inline void clear_red();
  static const int kRedFieldNumber = 6;
  inline ::google::protobuf::int32 red() const;
  inline void set_red(::google::protobuf::int32 value);

  // optional int32 green = 7;
  inline bool has_green() const;
  inline void clear_green();
  static const int kGreenFieldNumber = 7;
  inline ::google::protobuf::int32 green() const;
  inline void set_green(::google::protobuf::int32 value);

  // optional int32 blue = 8;
  inline bool has_blue() const;
  inline void clear_blue();
  static const int kBlueFieldNumber = 8;
  inline ::google::protobuf::int32 blue() const;
  inline void set_blue(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:protocolbuffers.TimeLineColorFrame)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_frameindex();
  inline void clear_has_frameindex();
  inline void set_has_tween();
  inline void clear_has_tween();
  inline void set_has_alpha();
  inline void clear_has_alpha();
  inline void set_has_red();
  inline void clear_has_red();
  inline void set_has_green();
  inline void clear_has_green();
  inline void set_has_blue();
  inline void clear_has_blue();

  ::std::string* name_;
  ::std::string* classname_;
  ::google::protobuf::int32 frameindex_;
  bool tween_;
  ::google::protobuf::int32 alpha_;
  ::google::protobuf::int32 red_;
  ::google::protobuf::int32 green_;
  ::google::protobuf::int32 blue_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(8 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static TimeLineColorFrame* default_instance_;
};
// -------------------------------------------------------------------

class TimeLineTextureFrame : public ::google::protobuf::MessageLite {
 public:
  TimeLineTextureFrame();
  virtual ~TimeLineTextureFrame();

  TimeLineTextureFrame(const TimeLineTextureFrame& from);

  inline TimeLineTextureFrame& operator=(const TimeLineTextureFrame& from) {
    CopyFrom(from);
    return *this;
  }

  static const TimeLineTextureFrame& default_instance();

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  // Returns the internal default instance pointer. This function can
  // return NULL thus should not be used by the user. This is intended
  // for Protobuf internal code. Please use default_instance() declared
  // above instead.
  static inline const TimeLineTextureFrame* internal_default_instance() {
    return default_instance_;
  }
  #endif

  void Swap(TimeLineTextureFrame* other);

  // implements Message ----------------------------------------------

  TimeLineTextureFrame* New() const;
  void CheckTypeAndMergeFrom(const ::google::protobuf::MessageLite& from);
  void CopyFrom(const TimeLineTextureFrame& from);
  void MergeFrom(const TimeLineTextureFrame& from);
  void Clear();
  bool IsInitialized() const;

  int ByteSize() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  public:

  ::std::string GetTypeName() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string name = 1;
  inline bool has_name() const;
  inline void clear_name();
  static const int kNameFieldNumber = 1;
  inline const ::std::string& name() const;
  inline void set_name(const ::std::string& value);
  inline void set_name(const char* value);
  inline void set_name(const char* value, size_t size);
  inline ::std::string* mutable_name();
  inline ::std::string* release_name();
  inline void set_allocated_name(::std::string* name);

  // optional string classname = 2;
  inline bool has_classname() const;
  inline void clear_classname();
  static const int kClassnameFieldNumber = 2;
  inline const ::std::string& classname() const;
  inline void set_classname(const ::std::string& value);
  inline void set_classname(const char* value);
  inline void set_classname(const char* value, size_t size);
  inline ::std::string* mutable_classname();
  inline ::std::string* release_classname();
  inline void set_allocated_classname(::std::string* classname);

  // optional int32 frameIndex = 3;
  inline bool has_frameindex() const;
  inline void clear_frameindex();
  static const int kFrameIndexFieldNumber = 3;
  inline ::google::protobuf::int32 frameindex() const;
  inline void set_frameindex(::google::protobuf::int32 value);

  // optional bool tween = 4;
  inline bool has_tween() const;
  inline void clear_tween();
  static const int kTweenFieldNumber = 4;
  inline bool tween() const;
  inline void set_tween(bool value);

  // optional string filePath = 5;
  inline bool has_filepath() const;
  inline void clear_filepath();
  static const int kFilePathFieldNumber = 5;
  inline const ::std::string& filepath() const;
  inline void set_filepath(const ::std::string& value);
  inline void set_filepath(const char* value);
  inline void set_filepath(const char* value, size_t size);
  inline ::std::string* mutable_filepath();
  inline ::std::string* release_filepath();
  inline void set_allocated_filepath(::std::string* filepath);

  // optional string plistFile = 6;
  inline bool has_plistfile() const;
  inline void clear_plistfile();
  static const int kPlistFileFieldNumber = 6;
  inline const ::std::string& plistfile() const;
  inline void set_plistfile(const ::std::string& value);
  inline void set_plistfile(const char* value);
  inline void set_plistfile(const char* value, size_t size);
  inline ::std::string* mutable_plistfile();
  inline ::std::string* release_plistfile();
  inline void set_allocated_plistfile(::std::string* plistfile);

  // @@protoc_insertion_point(class_scope:protocolbuffers.TimeLineTextureFrame)
 private:
  inline void set_has_name();
  inline void clear_has_name();
  inline void set_has_classname();
  inline void clear_has_classname();
  inline void set_has_frameindex();
  inline void clear_has_frameindex();
  inline void set_has_tween();
  inline void clear_has_tween();
  inline void set_has_filepath();
  inline void clear_has_filepath();
  inline void set_has_plistfile();
  inline void clear_has_plistfile();

  ::std::string* name_;
  ::std::string* classname_;
  ::google::protobuf::int32 frameindex_;
  bool tween_;
  ::std::string* filepath_;
  ::std::string* plistfile_;

  mutable int _cached_size_;
  ::google::protobuf::uint32 _has_bits_[(6 + 31) / 32];

  #ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  friend void  protobuf_AddDesc_CSParseBinary_2eproto_impl();
  #else
  friend void  protobuf_AddDesc_CSParseBinary_2eproto();
  #endif
  friend void protobuf_AssignDesc_CSParseBinary_2eproto();
  friend void protobuf_ShutdownFile_CSParseBinary_2eproto();

  void InitAsDefaultInstance();
  static TimeLineTextureFrame* default_instance_;
};
// ===================================================================


// ===================================================================

// CSParseBinary

// optional string version = 1;
inline bool CSParseBinary::has_version() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CSParseBinary::set_has_version() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CSParseBinary::clear_has_version() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CSParseBinary::clear_version() {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    version_->clear();
  }
  clear_has_version();
}
inline const ::std::string& CSParseBinary::version() const {
  return *version_;
}
inline void CSParseBinary::set_version(const ::std::string& value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void CSParseBinary::set_version(const char* value) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(value);
}
inline void CSParseBinary::set_version(const char* value, size_t size) {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  version_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSParseBinary::mutable_version() {
  set_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    version_ = new ::std::string;
  }
  return version_;
}
inline ::std::string* CSParseBinary::release_version() {
  clear_has_version();
  if (version_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = version_;
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSParseBinary::set_allocated_version(::std::string* version) {
  if (version_ != &::google::protobuf::internal::kEmptyString) {
    delete version_;
  }
  if (version) {
    set_has_version();
    version_ = version;
  } else {
    clear_has_version();
    version_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string cocos2dVersion = 2;
inline bool CSParseBinary::has_cocos2dversion() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CSParseBinary::set_has_cocos2dversion() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CSParseBinary::clear_has_cocos2dversion() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CSParseBinary::clear_cocos2dversion() {
  if (cocos2dversion_ != &::google::protobuf::internal::kEmptyString) {
    cocos2dversion_->clear();
  }
  clear_has_cocos2dversion();
}
inline const ::std::string& CSParseBinary::cocos2dversion() const {
  return *cocos2dversion_;
}
inline void CSParseBinary::set_cocos2dversion(const ::std::string& value) {
  set_has_cocos2dversion();
  if (cocos2dversion_ == &::google::protobuf::internal::kEmptyString) {
    cocos2dversion_ = new ::std::string;
  }
  cocos2dversion_->assign(value);
}
inline void CSParseBinary::set_cocos2dversion(const char* value) {
  set_has_cocos2dversion();
  if (cocos2dversion_ == &::google::protobuf::internal::kEmptyString) {
    cocos2dversion_ = new ::std::string;
  }
  cocos2dversion_->assign(value);
}
inline void CSParseBinary::set_cocos2dversion(const char* value, size_t size) {
  set_has_cocos2dversion();
  if (cocos2dversion_ == &::google::protobuf::internal::kEmptyString) {
    cocos2dversion_ = new ::std::string;
  }
  cocos2dversion_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSParseBinary::mutable_cocos2dversion() {
  set_has_cocos2dversion();
  if (cocos2dversion_ == &::google::protobuf::internal::kEmptyString) {
    cocos2dversion_ = new ::std::string;
  }
  return cocos2dversion_;
}
inline ::std::string* CSParseBinary::release_cocos2dversion() {
  clear_has_cocos2dversion();
  if (cocos2dversion_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = cocos2dversion_;
    cocos2dversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSParseBinary::set_allocated_cocos2dversion(::std::string* cocos2dversion) {
  if (cocos2dversion_ != &::google::protobuf::internal::kEmptyString) {
    delete cocos2dversion_;
  }
  if (cocos2dversion) {
    set_has_cocos2dversion();
    cocos2dversion_ = cocos2dversion;
  } else {
    clear_has_cocos2dversion();
    cocos2dversion_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string editorType = 3;
inline bool CSParseBinary::has_editortype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CSParseBinary::set_has_editortype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CSParseBinary::clear_has_editortype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CSParseBinary::clear_editortype() {
  if (editortype_ != &::google::protobuf::internal::kEmptyString) {
    editortype_->clear();
  }
  clear_has_editortype();
}
inline const ::std::string& CSParseBinary::editortype() const {
  return *editortype_;
}
inline void CSParseBinary::set_editortype(const ::std::string& value) {
  set_has_editortype();
  if (editortype_ == &::google::protobuf::internal::kEmptyString) {
    editortype_ = new ::std::string;
  }
  editortype_->assign(value);
}
inline void CSParseBinary::set_editortype(const char* value) {
  set_has_editortype();
  if (editortype_ == &::google::protobuf::internal::kEmptyString) {
    editortype_ = new ::std::string;
  }
  editortype_->assign(value);
}
inline void CSParseBinary::set_editortype(const char* value, size_t size) {
  set_has_editortype();
  if (editortype_ == &::google::protobuf::internal::kEmptyString) {
    editortype_ = new ::std::string;
  }
  editortype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSParseBinary::mutable_editortype() {
  set_has_editortype();
  if (editortype_ == &::google::protobuf::internal::kEmptyString) {
    editortype_ = new ::std::string;
  }
  return editortype_;
}
inline ::std::string* CSParseBinary::release_editortype() {
  clear_has_editortype();
  if (editortype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = editortype_;
    editortype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CSParseBinary::set_allocated_editortype(::std::string* editortype) {
  if (editortype_ != &::google::protobuf::internal::kEmptyString) {
    delete editortype_;
  }
  if (editortype) {
    set_has_editortype();
    editortype_ = editortype;
  } else {
    clear_has_editortype();
    editortype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float dataScale = 4;
inline bool CSParseBinary::has_datascale() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CSParseBinary::set_has_datascale() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CSParseBinary::clear_has_datascale() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CSParseBinary::clear_datascale() {
  datascale_ = 0;
  clear_has_datascale();
}
inline float CSParseBinary::datascale() const {
  return datascale_;
}
inline void CSParseBinary::set_datascale(float value) {
  set_has_datascale();
  datascale_ = value;
}

// optional int32 designHeight = 5;
inline bool CSParseBinary::has_designheight() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CSParseBinary::set_has_designheight() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CSParseBinary::clear_has_designheight() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CSParseBinary::clear_designheight() {
  designheight_ = 0;
  clear_has_designheight();
}
inline ::google::protobuf::int32 CSParseBinary::designheight() const {
  return designheight_;
}
inline void CSParseBinary::set_designheight(::google::protobuf::int32 value) {
  set_has_designheight();
  designheight_ = value;
}

// optional int32 designWidth = 6;
inline bool CSParseBinary::has_designwidth() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CSParseBinary::set_has_designwidth() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CSParseBinary::clear_has_designwidth() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CSParseBinary::clear_designwidth() {
  designwidth_ = 0;
  clear_has_designwidth();
}
inline ::google::protobuf::int32 CSParseBinary::designwidth() const {
  return designwidth_;
}
inline void CSParseBinary::set_designwidth(::google::protobuf::int32 value) {
  set_has_designwidth();
  designwidth_ = value;
}

// repeated string textures = 7;
inline int CSParseBinary::textures_size() const {
  return textures_.size();
}
inline void CSParseBinary::clear_textures() {
  textures_.Clear();
}
inline const ::std::string& CSParseBinary::textures(int index) const {
  return textures_.Get(index);
}
inline ::std::string* CSParseBinary::mutable_textures(int index) {
  return textures_.Mutable(index);
}
inline void CSParseBinary::set_textures(int index, const ::std::string& value) {
  textures_.Mutable(index)->assign(value);
}
inline void CSParseBinary::set_textures(int index, const char* value) {
  textures_.Mutable(index)->assign(value);
}
inline void CSParseBinary::set_textures(int index, const char* value, size_t size) {
  textures_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSParseBinary::add_textures() {
  return textures_.Add();
}
inline void CSParseBinary::add_textures(const ::std::string& value) {
  textures_.Add()->assign(value);
}
inline void CSParseBinary::add_textures(const char* value) {
  textures_.Add()->assign(value);
}
inline void CSParseBinary::add_textures(const char* value, size_t size) {
  textures_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CSParseBinary::textures() const {
  return textures_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CSParseBinary::mutable_textures() {
  return &textures_;
}

// repeated string texturesPng = 8;
inline int CSParseBinary::texturespng_size() const {
  return texturespng_.size();
}
inline void CSParseBinary::clear_texturespng() {
  texturespng_.Clear();
}
inline const ::std::string& CSParseBinary::texturespng(int index) const {
  return texturespng_.Get(index);
}
inline ::std::string* CSParseBinary::mutable_texturespng(int index) {
  return texturespng_.Mutable(index);
}
inline void CSParseBinary::set_texturespng(int index, const ::std::string& value) {
  texturespng_.Mutable(index)->assign(value);
}
inline void CSParseBinary::set_texturespng(int index, const char* value) {
  texturespng_.Mutable(index)->assign(value);
}
inline void CSParseBinary::set_texturespng(int index, const char* value, size_t size) {
  texturespng_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CSParseBinary::add_texturespng() {
  return texturespng_.Add();
}
inline void CSParseBinary::add_texturespng(const ::std::string& value) {
  texturespng_.Add()->assign(value);
}
inline void CSParseBinary::add_texturespng(const char* value) {
  texturespng_.Add()->assign(value);
}
inline void CSParseBinary::add_texturespng(const char* value, size_t size) {
  texturespng_.Add()->assign(reinterpret_cast<const char*>(value), size);
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CSParseBinary::texturespng() const {
  return texturespng_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CSParseBinary::mutable_texturespng() {
  return &texturespng_;
}

// optional .protocolbuffers.NodeTree nodeTree = 9;
inline bool CSParseBinary::has_nodetree() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CSParseBinary::set_has_nodetree() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CSParseBinary::clear_has_nodetree() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CSParseBinary::clear_nodetree() {
  if (nodetree_ != NULL) nodetree_->::protocolbuffers::NodeTree::Clear();
  clear_has_nodetree();
}
inline const ::protocolbuffers::NodeTree& CSParseBinary::nodetree() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return nodetree_ != NULL ? *nodetree_ : *default_instance().nodetree_;
#else
  return nodetree_ != NULL ? *nodetree_ : *default_instance_->nodetree_;
#endif
}
inline ::protocolbuffers::NodeTree* CSParseBinary::mutable_nodetree() {
  set_has_nodetree();
  if (nodetree_ == NULL) nodetree_ = new ::protocolbuffers::NodeTree;
  return nodetree_;
}
inline ::protocolbuffers::NodeTree* CSParseBinary::release_nodetree() {
  clear_has_nodetree();
  ::protocolbuffers::NodeTree* temp = nodetree_;
  nodetree_ = NULL;
  return temp;
}
inline void CSParseBinary::set_allocated_nodetree(::protocolbuffers::NodeTree* nodetree) {
  delete nodetree_;
  nodetree_ = nodetree;
  if (nodetree) {
    set_has_nodetree();
  } else {
    clear_has_nodetree();
  }
}

// optional .protocolbuffers.NodeAction action = 10;
inline bool CSParseBinary::has_action() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CSParseBinary::set_has_action() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CSParseBinary::clear_has_action() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CSParseBinary::clear_action() {
  if (action_ != NULL) action_->::protocolbuffers::NodeAction::Clear();
  clear_has_action();
}
inline const ::protocolbuffers::NodeAction& CSParseBinary::action() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return action_ != NULL ? *action_ : *default_instance().action_;
#else
  return action_ != NULL ? *action_ : *default_instance_->action_;
#endif
}
inline ::protocolbuffers::NodeAction* CSParseBinary::mutable_action() {
  set_has_action();
  if (action_ == NULL) action_ = new ::protocolbuffers::NodeAction;
  return action_;
}
inline ::protocolbuffers::NodeAction* CSParseBinary::release_action() {
  clear_has_action();
  ::protocolbuffers::NodeAction* temp = action_;
  action_ = NULL;
  return temp;
}
inline void CSParseBinary::set_allocated_action(::protocolbuffers::NodeAction* action) {
  delete action_;
  action_ = action;
  if (action) {
    set_has_action();
  } else {
    clear_has_action();
  }
}

// -------------------------------------------------------------------

// NodeTree

// optional string classname = 1;
inline bool NodeTree::has_classname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeTree::set_has_classname() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeTree::clear_has_classname() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeTree::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& NodeTree::classname() const {
  return *classname_;
}
inline void NodeTree::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void NodeTree::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void NodeTree::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeTree::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* NodeTree::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeTree::set_allocated_classname(::std::string* classname) {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (classname) {
    set_has_classname();
    classname_ = classname;
  } else {
    clear_has_classname();
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 2;
inline bool NodeTree::has_name() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeTree::set_has_name() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeTree::clear_has_name() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeTree::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NodeTree::name() const {
  return *name_;
}
inline void NodeTree::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NodeTree::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NodeTree::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeTree::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NodeTree::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeTree::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// repeated .protocolbuffers.NodeTree children = 3;
inline int NodeTree::children_size() const {
  return children_.size();
}
inline void NodeTree::clear_children() {
  children_.Clear();
}
inline const ::protocolbuffers::NodeTree& NodeTree::children(int index) const {
  return children_.Get(index);
}
inline ::protocolbuffers::NodeTree* NodeTree::mutable_children(int index) {
  return children_.Mutable(index);
}
inline ::protocolbuffers::NodeTree* NodeTree::add_children() {
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocolbuffers::NodeTree >&
NodeTree::children() const {
  return children_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocolbuffers::NodeTree >*
NodeTree::mutable_children() {
  return &children_;
}

// optional .protocolbuffers.WidgetOptions widgetOptions = 4;
inline bool NodeTree::has_widgetoptions() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NodeTree::set_has_widgetoptions() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NodeTree::clear_has_widgetoptions() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NodeTree::clear_widgetoptions() {
  if (widgetoptions_ != NULL) widgetoptions_->::protocolbuffers::WidgetOptions::Clear();
  clear_has_widgetoptions();
}
inline const ::protocolbuffers::WidgetOptions& NodeTree::widgetoptions() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return widgetoptions_ != NULL ? *widgetoptions_ : *default_instance().widgetoptions_;
#else
  return widgetoptions_ != NULL ? *widgetoptions_ : *default_instance_->widgetoptions_;
#endif
}
inline ::protocolbuffers::WidgetOptions* NodeTree::mutable_widgetoptions() {
  set_has_widgetoptions();
  if (widgetoptions_ == NULL) widgetoptions_ = new ::protocolbuffers::WidgetOptions;
  return widgetoptions_;
}
inline ::protocolbuffers::WidgetOptions* NodeTree::release_widgetoptions() {
  clear_has_widgetoptions();
  ::protocolbuffers::WidgetOptions* temp = widgetoptions_;
  widgetoptions_ = NULL;
  return temp;
}
inline void NodeTree::set_allocated_widgetoptions(::protocolbuffers::WidgetOptions* widgetoptions) {
  delete widgetoptions_;
  widgetoptions_ = widgetoptions;
  if (widgetoptions) {
    set_has_widgetoptions();
  } else {
    clear_has_widgetoptions();
  }
}

// optional .protocolbuffers.ButtonOptions buttonOptions = 5;
inline bool NodeTree::has_buttonoptions() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void NodeTree::set_has_buttonoptions() {
  _has_bits_[0] |= 0x00000010u;
}
inline void NodeTree::clear_has_buttonoptions() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void NodeTree::clear_buttonoptions() {
  if (buttonoptions_ != NULL) buttonoptions_->::protocolbuffers::ButtonOptions::Clear();
  clear_has_buttonoptions();
}
inline const ::protocolbuffers::ButtonOptions& NodeTree::buttonoptions() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return buttonoptions_ != NULL ? *buttonoptions_ : *default_instance().buttonoptions_;
#else
  return buttonoptions_ != NULL ? *buttonoptions_ : *default_instance_->buttonoptions_;
#endif
}
inline ::protocolbuffers::ButtonOptions* NodeTree::mutable_buttonoptions() {
  set_has_buttonoptions();
  if (buttonoptions_ == NULL) buttonoptions_ = new ::protocolbuffers::ButtonOptions;
  return buttonoptions_;
}
inline ::protocolbuffers::ButtonOptions* NodeTree::release_buttonoptions() {
  clear_has_buttonoptions();
  ::protocolbuffers::ButtonOptions* temp = buttonoptions_;
  buttonoptions_ = NULL;
  return temp;
}
inline void NodeTree::set_allocated_buttonoptions(::protocolbuffers::ButtonOptions* buttonoptions) {
  delete buttonoptions_;
  buttonoptions_ = buttonoptions;
  if (buttonoptions) {
    set_has_buttonoptions();
  } else {
    clear_has_buttonoptions();
  }
}

// optional .protocolbuffers.CheckBoxOptions checkBoxOptions = 6;
inline bool NodeTree::has_checkboxoptions() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void NodeTree::set_has_checkboxoptions() {
  _has_bits_[0] |= 0x00000020u;
}
inline void NodeTree::clear_has_checkboxoptions() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void NodeTree::clear_checkboxoptions() {
  if (checkboxoptions_ != NULL) checkboxoptions_->::protocolbuffers::CheckBoxOptions::Clear();
  clear_has_checkboxoptions();
}
inline const ::protocolbuffers::CheckBoxOptions& NodeTree::checkboxoptions() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return checkboxoptions_ != NULL ? *checkboxoptions_ : *default_instance().checkboxoptions_;
#else
  return checkboxoptions_ != NULL ? *checkboxoptions_ : *default_instance_->checkboxoptions_;
#endif
}
inline ::protocolbuffers::CheckBoxOptions* NodeTree::mutable_checkboxoptions() {
  set_has_checkboxoptions();
  if (checkboxoptions_ == NULL) checkboxoptions_ = new ::protocolbuffers::CheckBoxOptions;
  return checkboxoptions_;
}
inline ::protocolbuffers::CheckBoxOptions* NodeTree::release_checkboxoptions() {
  clear_has_checkboxoptions();
  ::protocolbuffers::CheckBoxOptions* temp = checkboxoptions_;
  checkboxoptions_ = NULL;
  return temp;
}
inline void NodeTree::set_allocated_checkboxoptions(::protocolbuffers::CheckBoxOptions* checkboxoptions) {
  delete checkboxoptions_;
  checkboxoptions_ = checkboxoptions;
  if (checkboxoptions) {
    set_has_checkboxoptions();
  } else {
    clear_has_checkboxoptions();
  }
}

// optional .protocolbuffers.ImageViewOptions imageViewOptions = 7;
inline bool NodeTree::has_imageviewoptions() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void NodeTree::set_has_imageviewoptions() {
  _has_bits_[0] |= 0x00000040u;
}
inline void NodeTree::clear_has_imageviewoptions() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void NodeTree::clear_imageviewoptions() {
  if (imageviewoptions_ != NULL) imageviewoptions_->::protocolbuffers::ImageViewOptions::Clear();
  clear_has_imageviewoptions();
}
inline const ::protocolbuffers::ImageViewOptions& NodeTree::imageviewoptions() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return imageviewoptions_ != NULL ? *imageviewoptions_ : *default_instance().imageviewoptions_;
#else
  return imageviewoptions_ != NULL ? *imageviewoptions_ : *default_instance_->imageviewoptions_;
#endif
}
inline ::protocolbuffers::ImageViewOptions* NodeTree::mutable_imageviewoptions() {
  set_has_imageviewoptions();
  if (imageviewoptions_ == NULL) imageviewoptions_ = new ::protocolbuffers::ImageViewOptions;
  return imageviewoptions_;
}
inline ::protocolbuffers::ImageViewOptions* NodeTree::release_imageviewoptions() {
  clear_has_imageviewoptions();
  ::protocolbuffers::ImageViewOptions* temp = imageviewoptions_;
  imageviewoptions_ = NULL;
  return temp;
}
inline void NodeTree::set_allocated_imageviewoptions(::protocolbuffers::ImageViewOptions* imageviewoptions) {
  delete imageviewoptions_;
  imageviewoptions_ = imageviewoptions;
  if (imageviewoptions) {
    set_has_imageviewoptions();
  } else {
    clear_has_imageviewoptions();
  }
}

// optional .protocolbuffers.TextAtlasOptions textAtlasOptions = 8;
inline bool NodeTree::has_textatlasoptions() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void NodeTree::set_has_textatlasoptions() {
  _has_bits_[0] |= 0x00000080u;
}
inline void NodeTree::clear_has_textatlasoptions() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void NodeTree::clear_textatlasoptions() {
  if (textatlasoptions_ != NULL) textatlasoptions_->::protocolbuffers::TextAtlasOptions::Clear();
  clear_has_textatlasoptions();
}
inline const ::protocolbuffers::TextAtlasOptions& NodeTree::textatlasoptions() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return textatlasoptions_ != NULL ? *textatlasoptions_ : *default_instance().textatlasoptions_;
#else
  return textatlasoptions_ != NULL ? *textatlasoptions_ : *default_instance_->textatlasoptions_;
#endif
}
inline ::protocolbuffers::TextAtlasOptions* NodeTree::mutable_textatlasoptions() {
  set_has_textatlasoptions();
  if (textatlasoptions_ == NULL) textatlasoptions_ = new ::protocolbuffers::TextAtlasOptions;
  return textatlasoptions_;
}
inline ::protocolbuffers::TextAtlasOptions* NodeTree::release_textatlasoptions() {
  clear_has_textatlasoptions();
  ::protocolbuffers::TextAtlasOptions* temp = textatlasoptions_;
  textatlasoptions_ = NULL;
  return temp;
}
inline void NodeTree::set_allocated_textatlasoptions(::protocolbuffers::TextAtlasOptions* textatlasoptions) {
  delete textatlasoptions_;
  textatlasoptions_ = textatlasoptions;
  if (textatlasoptions) {
    set_has_textatlasoptions();
  } else {
    clear_has_textatlasoptions();
  }
}

// optional .protocolbuffers.TextBMFontOptions textBMFontOptions = 9;
inline bool NodeTree::has_textbmfontoptions() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void NodeTree::set_has_textbmfontoptions() {
  _has_bits_[0] |= 0x00000100u;
}
inline void NodeTree::clear_has_textbmfontoptions() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void NodeTree::clear_textbmfontoptions() {
  if (textbmfontoptions_ != NULL) textbmfontoptions_->::protocolbuffers::TextBMFontOptions::Clear();
  clear_has_textbmfontoptions();
}
inline const ::protocolbuffers::TextBMFontOptions& NodeTree::textbmfontoptions() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return textbmfontoptions_ != NULL ? *textbmfontoptions_ : *default_instance().textbmfontoptions_;
#else
  return textbmfontoptions_ != NULL ? *textbmfontoptions_ : *default_instance_->textbmfontoptions_;
#endif
}
inline ::protocolbuffers::TextBMFontOptions* NodeTree::mutable_textbmfontoptions() {
  set_has_textbmfontoptions();
  if (textbmfontoptions_ == NULL) textbmfontoptions_ = new ::protocolbuffers::TextBMFontOptions;
  return textbmfontoptions_;
}
inline ::protocolbuffers::TextBMFontOptions* NodeTree::release_textbmfontoptions() {
  clear_has_textbmfontoptions();
  ::protocolbuffers::TextBMFontOptions* temp = textbmfontoptions_;
  textbmfontoptions_ = NULL;
  return temp;
}
inline void NodeTree::set_allocated_textbmfontoptions(::protocolbuffers::TextBMFontOptions* textbmfontoptions) {
  delete textbmfontoptions_;
  textbmfontoptions_ = textbmfontoptions;
  if (textbmfontoptions) {
    set_has_textbmfontoptions();
  } else {
    clear_has_textbmfontoptions();
  }
}

// optional .protocolbuffers.TextOptions textOptions = 10;
inline bool NodeTree::has_textoptions() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void NodeTree::set_has_textoptions() {
  _has_bits_[0] |= 0x00000200u;
}
inline void NodeTree::clear_has_textoptions() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void NodeTree::clear_textoptions() {
  if (textoptions_ != NULL) textoptions_->::protocolbuffers::TextOptions::Clear();
  clear_has_textoptions();
}
inline const ::protocolbuffers::TextOptions& NodeTree::textoptions() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return textoptions_ != NULL ? *textoptions_ : *default_instance().textoptions_;
#else
  return textoptions_ != NULL ? *textoptions_ : *default_instance_->textoptions_;
#endif
}
inline ::protocolbuffers::TextOptions* NodeTree::mutable_textoptions() {
  set_has_textoptions();
  if (textoptions_ == NULL) textoptions_ = new ::protocolbuffers::TextOptions;
  return textoptions_;
}
inline ::protocolbuffers::TextOptions* NodeTree::release_textoptions() {
  clear_has_textoptions();
  ::protocolbuffers::TextOptions* temp = textoptions_;
  textoptions_ = NULL;
  return temp;
}
inline void NodeTree::set_allocated_textoptions(::protocolbuffers::TextOptions* textoptions) {
  delete textoptions_;
  textoptions_ = textoptions;
  if (textoptions) {
    set_has_textoptions();
  } else {
    clear_has_textoptions();
  }
}

// optional .protocolbuffers.LoadingBarOptions loadingBarOptions = 11;
inline bool NodeTree::has_loadingbaroptions() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void NodeTree::set_has_loadingbaroptions() {
  _has_bits_[0] |= 0x00000400u;
}
inline void NodeTree::clear_has_loadingbaroptions() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void NodeTree::clear_loadingbaroptions() {
  if (loadingbaroptions_ != NULL) loadingbaroptions_->::protocolbuffers::LoadingBarOptions::Clear();
  clear_has_loadingbaroptions();
}
inline const ::protocolbuffers::LoadingBarOptions& NodeTree::loadingbaroptions() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return loadingbaroptions_ != NULL ? *loadingbaroptions_ : *default_instance().loadingbaroptions_;
#else
  return loadingbaroptions_ != NULL ? *loadingbaroptions_ : *default_instance_->loadingbaroptions_;
#endif
}
inline ::protocolbuffers::LoadingBarOptions* NodeTree::mutable_loadingbaroptions() {
  set_has_loadingbaroptions();
  if (loadingbaroptions_ == NULL) loadingbaroptions_ = new ::protocolbuffers::LoadingBarOptions;
  return loadingbaroptions_;
}
inline ::protocolbuffers::LoadingBarOptions* NodeTree::release_loadingbaroptions() {
  clear_has_loadingbaroptions();
  ::protocolbuffers::LoadingBarOptions* temp = loadingbaroptions_;
  loadingbaroptions_ = NULL;
  return temp;
}
inline void NodeTree::set_allocated_loadingbaroptions(::protocolbuffers::LoadingBarOptions* loadingbaroptions) {
  delete loadingbaroptions_;
  loadingbaroptions_ = loadingbaroptions;
  if (loadingbaroptions) {
    set_has_loadingbaroptions();
  } else {
    clear_has_loadingbaroptions();
  }
}

// optional .protocolbuffers.SliderOptions sliderOptions = 12;
inline bool NodeTree::has_slideroptions() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void NodeTree::set_has_slideroptions() {
  _has_bits_[0] |= 0x00000800u;
}
inline void NodeTree::clear_has_slideroptions() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void NodeTree::clear_slideroptions() {
  if (slideroptions_ != NULL) slideroptions_->::protocolbuffers::SliderOptions::Clear();
  clear_has_slideroptions();
}
inline const ::protocolbuffers::SliderOptions& NodeTree::slideroptions() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return slideroptions_ != NULL ? *slideroptions_ : *default_instance().slideroptions_;
#else
  return slideroptions_ != NULL ? *slideroptions_ : *default_instance_->slideroptions_;
#endif
}
inline ::protocolbuffers::SliderOptions* NodeTree::mutable_slideroptions() {
  set_has_slideroptions();
  if (slideroptions_ == NULL) slideroptions_ = new ::protocolbuffers::SliderOptions;
  return slideroptions_;
}
inline ::protocolbuffers::SliderOptions* NodeTree::release_slideroptions() {
  clear_has_slideroptions();
  ::protocolbuffers::SliderOptions* temp = slideroptions_;
  slideroptions_ = NULL;
  return temp;
}
inline void NodeTree::set_allocated_slideroptions(::protocolbuffers::SliderOptions* slideroptions) {
  delete slideroptions_;
  slideroptions_ = slideroptions;
  if (slideroptions) {
    set_has_slideroptions();
  } else {
    clear_has_slideroptions();
  }
}

// optional .protocolbuffers.TextFieldOptions textFieldOptions = 13;
inline bool NodeTree::has_textfieldoptions() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void NodeTree::set_has_textfieldoptions() {
  _has_bits_[0] |= 0x00001000u;
}
inline void NodeTree::clear_has_textfieldoptions() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void NodeTree::clear_textfieldoptions() {
  if (textfieldoptions_ != NULL) textfieldoptions_->::protocolbuffers::TextFieldOptions::Clear();
  clear_has_textfieldoptions();
}
inline const ::protocolbuffers::TextFieldOptions& NodeTree::textfieldoptions() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return textfieldoptions_ != NULL ? *textfieldoptions_ : *default_instance().textfieldoptions_;
#else
  return textfieldoptions_ != NULL ? *textfieldoptions_ : *default_instance_->textfieldoptions_;
#endif
}
inline ::protocolbuffers::TextFieldOptions* NodeTree::mutable_textfieldoptions() {
  set_has_textfieldoptions();
  if (textfieldoptions_ == NULL) textfieldoptions_ = new ::protocolbuffers::TextFieldOptions;
  return textfieldoptions_;
}
inline ::protocolbuffers::TextFieldOptions* NodeTree::release_textfieldoptions() {
  clear_has_textfieldoptions();
  ::protocolbuffers::TextFieldOptions* temp = textfieldoptions_;
  textfieldoptions_ = NULL;
  return temp;
}
inline void NodeTree::set_allocated_textfieldoptions(::protocolbuffers::TextFieldOptions* textfieldoptions) {
  delete textfieldoptions_;
  textfieldoptions_ = textfieldoptions;
  if (textfieldoptions) {
    set_has_textfieldoptions();
  } else {
    clear_has_textfieldoptions();
  }
}

// optional .protocolbuffers.ScrollViewOptions scrollViewOptions = 14;
inline bool NodeTree::has_scrollviewoptions() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void NodeTree::set_has_scrollviewoptions() {
  _has_bits_[0] |= 0x00002000u;
}
inline void NodeTree::clear_has_scrollviewoptions() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void NodeTree::clear_scrollviewoptions() {
  if (scrollviewoptions_ != NULL) scrollviewoptions_->::protocolbuffers::ScrollViewOptions::Clear();
  clear_has_scrollviewoptions();
}
inline const ::protocolbuffers::ScrollViewOptions& NodeTree::scrollviewoptions() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return scrollviewoptions_ != NULL ? *scrollviewoptions_ : *default_instance().scrollviewoptions_;
#else
  return scrollviewoptions_ != NULL ? *scrollviewoptions_ : *default_instance_->scrollviewoptions_;
#endif
}
inline ::protocolbuffers::ScrollViewOptions* NodeTree::mutable_scrollviewoptions() {
  set_has_scrollviewoptions();
  if (scrollviewoptions_ == NULL) scrollviewoptions_ = new ::protocolbuffers::ScrollViewOptions;
  return scrollviewoptions_;
}
inline ::protocolbuffers::ScrollViewOptions* NodeTree::release_scrollviewoptions() {
  clear_has_scrollviewoptions();
  ::protocolbuffers::ScrollViewOptions* temp = scrollviewoptions_;
  scrollviewoptions_ = NULL;
  return temp;
}
inline void NodeTree::set_allocated_scrollviewoptions(::protocolbuffers::ScrollViewOptions* scrollviewoptions) {
  delete scrollviewoptions_;
  scrollviewoptions_ = scrollviewoptions;
  if (scrollviewoptions) {
    set_has_scrollviewoptions();
  } else {
    clear_has_scrollviewoptions();
  }
}

// optional .protocolbuffers.PageViewOptions pageViewOptions = 15;
inline bool NodeTree::has_pageviewoptions() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void NodeTree::set_has_pageviewoptions() {
  _has_bits_[0] |= 0x00004000u;
}
inline void NodeTree::clear_has_pageviewoptions() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void NodeTree::clear_pageviewoptions() {
  if (pageviewoptions_ != NULL) pageviewoptions_->::protocolbuffers::PageViewOptions::Clear();
  clear_has_pageviewoptions();
}
inline const ::protocolbuffers::PageViewOptions& NodeTree::pageviewoptions() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return pageviewoptions_ != NULL ? *pageviewoptions_ : *default_instance().pageviewoptions_;
#else
  return pageviewoptions_ != NULL ? *pageviewoptions_ : *default_instance_->pageviewoptions_;
#endif
}
inline ::protocolbuffers::PageViewOptions* NodeTree::mutable_pageviewoptions() {
  set_has_pageviewoptions();
  if (pageviewoptions_ == NULL) pageviewoptions_ = new ::protocolbuffers::PageViewOptions;
  return pageviewoptions_;
}
inline ::protocolbuffers::PageViewOptions* NodeTree::release_pageviewoptions() {
  clear_has_pageviewoptions();
  ::protocolbuffers::PageViewOptions* temp = pageviewoptions_;
  pageviewoptions_ = NULL;
  return temp;
}
inline void NodeTree::set_allocated_pageviewoptions(::protocolbuffers::PageViewOptions* pageviewoptions) {
  delete pageviewoptions_;
  pageviewoptions_ = pageviewoptions;
  if (pageviewoptions) {
    set_has_pageviewoptions();
  } else {
    clear_has_pageviewoptions();
  }
}

// optional .protocolbuffers.ListViewOptions listViewOptions = 16;
inline bool NodeTree::has_listviewoptions() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void NodeTree::set_has_listviewoptions() {
  _has_bits_[0] |= 0x00008000u;
}
inline void NodeTree::clear_has_listviewoptions() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void NodeTree::clear_listviewoptions() {
  if (listviewoptions_ != NULL) listviewoptions_->::protocolbuffers::ListViewOptions::Clear();
  clear_has_listviewoptions();
}
inline const ::protocolbuffers::ListViewOptions& NodeTree::listviewoptions() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return listviewoptions_ != NULL ? *listviewoptions_ : *default_instance().listviewoptions_;
#else
  return listviewoptions_ != NULL ? *listviewoptions_ : *default_instance_->listviewoptions_;
#endif
}
inline ::protocolbuffers::ListViewOptions* NodeTree::mutable_listviewoptions() {
  set_has_listviewoptions();
  if (listviewoptions_ == NULL) listviewoptions_ = new ::protocolbuffers::ListViewOptions;
  return listviewoptions_;
}
inline ::protocolbuffers::ListViewOptions* NodeTree::release_listviewoptions() {
  clear_has_listviewoptions();
  ::protocolbuffers::ListViewOptions* temp = listviewoptions_;
  listviewoptions_ = NULL;
  return temp;
}
inline void NodeTree::set_allocated_listviewoptions(::protocolbuffers::ListViewOptions* listviewoptions) {
  delete listviewoptions_;
  listviewoptions_ = listviewoptions;
  if (listviewoptions) {
    set_has_listviewoptions();
  } else {
    clear_has_listviewoptions();
  }
}

// optional .protocolbuffers.PanelOptions PanelOptions = 17;
inline bool NodeTree::has_paneloptions() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void NodeTree::set_has_paneloptions() {
  _has_bits_[0] |= 0x00010000u;
}
inline void NodeTree::clear_has_paneloptions() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void NodeTree::clear_paneloptions() {
  if (paneloptions_ != NULL) paneloptions_->::protocolbuffers::PanelOptions::Clear();
  clear_has_paneloptions();
}
inline const ::protocolbuffers::PanelOptions& NodeTree::paneloptions() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return paneloptions_ != NULL ? *paneloptions_ : *default_instance().paneloptions_;
#else
  return paneloptions_ != NULL ? *paneloptions_ : *default_instance_->paneloptions_;
#endif
}
inline ::protocolbuffers::PanelOptions* NodeTree::mutable_paneloptions() {
  set_has_paneloptions();
  if (paneloptions_ == NULL) paneloptions_ = new ::protocolbuffers::PanelOptions;
  return paneloptions_;
}
inline ::protocolbuffers::PanelOptions* NodeTree::release_paneloptions() {
  clear_has_paneloptions();
  ::protocolbuffers::PanelOptions* temp = paneloptions_;
  paneloptions_ = NULL;
  return temp;
}
inline void NodeTree::set_allocated_paneloptions(::protocolbuffers::PanelOptions* paneloptions) {
  delete paneloptions_;
  paneloptions_ = paneloptions;
  if (paneloptions) {
    set_has_paneloptions();
  } else {
    clear_has_paneloptions();
  }
}

// optional .protocolbuffers.SpriteOptions spriteOptions = 18;
inline bool NodeTree::has_spriteoptions() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void NodeTree::set_has_spriteoptions() {
  _has_bits_[0] |= 0x00020000u;
}
inline void NodeTree::clear_has_spriteoptions() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void NodeTree::clear_spriteoptions() {
  if (spriteoptions_ != NULL) spriteoptions_->::protocolbuffers::SpriteOptions::Clear();
  clear_has_spriteoptions();
}
inline const ::protocolbuffers::SpriteOptions& NodeTree::spriteoptions() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return spriteoptions_ != NULL ? *spriteoptions_ : *default_instance().spriteoptions_;
#else
  return spriteoptions_ != NULL ? *spriteoptions_ : *default_instance_->spriteoptions_;
#endif
}
inline ::protocolbuffers::SpriteOptions* NodeTree::mutable_spriteoptions() {
  set_has_spriteoptions();
  if (spriteoptions_ == NULL) spriteoptions_ = new ::protocolbuffers::SpriteOptions;
  return spriteoptions_;
}
inline ::protocolbuffers::SpriteOptions* NodeTree::release_spriteoptions() {
  clear_has_spriteoptions();
  ::protocolbuffers::SpriteOptions* temp = spriteoptions_;
  spriteoptions_ = NULL;
  return temp;
}
inline void NodeTree::set_allocated_spriteoptions(::protocolbuffers::SpriteOptions* spriteoptions) {
  delete spriteoptions_;
  spriteoptions_ = spriteoptions;
  if (spriteoptions) {
    set_has_spriteoptions();
  } else {
    clear_has_spriteoptions();
  }
}

// optional .protocolbuffers.TMXTiledMapOptions tmxTiledMapOptions = 19;
inline bool NodeTree::has_tmxtiledmapoptions() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void NodeTree::set_has_tmxtiledmapoptions() {
  _has_bits_[0] |= 0x00040000u;
}
inline void NodeTree::clear_has_tmxtiledmapoptions() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void NodeTree::clear_tmxtiledmapoptions() {
  if (tmxtiledmapoptions_ != NULL) tmxtiledmapoptions_->::protocolbuffers::TMXTiledMapOptions::Clear();
  clear_has_tmxtiledmapoptions();
}
inline const ::protocolbuffers::TMXTiledMapOptions& NodeTree::tmxtiledmapoptions() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return tmxtiledmapoptions_ != NULL ? *tmxtiledmapoptions_ : *default_instance().tmxtiledmapoptions_;
#else
  return tmxtiledmapoptions_ != NULL ? *tmxtiledmapoptions_ : *default_instance_->tmxtiledmapoptions_;
#endif
}
inline ::protocolbuffers::TMXTiledMapOptions* NodeTree::mutable_tmxtiledmapoptions() {
  set_has_tmxtiledmapoptions();
  if (tmxtiledmapoptions_ == NULL) tmxtiledmapoptions_ = new ::protocolbuffers::TMXTiledMapOptions;
  return tmxtiledmapoptions_;
}
inline ::protocolbuffers::TMXTiledMapOptions* NodeTree::release_tmxtiledmapoptions() {
  clear_has_tmxtiledmapoptions();
  ::protocolbuffers::TMXTiledMapOptions* temp = tmxtiledmapoptions_;
  tmxtiledmapoptions_ = NULL;
  return temp;
}
inline void NodeTree::set_allocated_tmxtiledmapoptions(::protocolbuffers::TMXTiledMapOptions* tmxtiledmapoptions) {
  delete tmxtiledmapoptions_;
  tmxtiledmapoptions_ = tmxtiledmapoptions;
  if (tmxtiledmapoptions) {
    set_has_tmxtiledmapoptions();
  } else {
    clear_has_tmxtiledmapoptions();
  }
}

// optional .protocolbuffers.ParticleSystemOptions particleSystemOptions = 20;
inline bool NodeTree::has_particlesystemoptions() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void NodeTree::set_has_particlesystemoptions() {
  _has_bits_[0] |= 0x00080000u;
}
inline void NodeTree::clear_has_particlesystemoptions() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void NodeTree::clear_particlesystemoptions() {
  if (particlesystemoptions_ != NULL) particlesystemoptions_->::protocolbuffers::ParticleSystemOptions::Clear();
  clear_has_particlesystemoptions();
}
inline const ::protocolbuffers::ParticleSystemOptions& NodeTree::particlesystemoptions() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return particlesystemoptions_ != NULL ? *particlesystemoptions_ : *default_instance().particlesystemoptions_;
#else
  return particlesystemoptions_ != NULL ? *particlesystemoptions_ : *default_instance_->particlesystemoptions_;
#endif
}
inline ::protocolbuffers::ParticleSystemOptions* NodeTree::mutable_particlesystemoptions() {
  set_has_particlesystemoptions();
  if (particlesystemoptions_ == NULL) particlesystemoptions_ = new ::protocolbuffers::ParticleSystemOptions;
  return particlesystemoptions_;
}
inline ::protocolbuffers::ParticleSystemOptions* NodeTree::release_particlesystemoptions() {
  clear_has_particlesystemoptions();
  ::protocolbuffers::ParticleSystemOptions* temp = particlesystemoptions_;
  particlesystemoptions_ = NULL;
  return temp;
}
inline void NodeTree::set_allocated_particlesystemoptions(::protocolbuffers::ParticleSystemOptions* particlesystemoptions) {
  delete particlesystemoptions_;
  particlesystemoptions_ = particlesystemoptions;
  if (particlesystemoptions) {
    set_has_particlesystemoptions();
  } else {
    clear_has_particlesystemoptions();
  }
}

// optional .protocolbuffers.ProjectNodeOptions projectNodeOptions = 21;
inline bool NodeTree::has_projectnodeoptions() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void NodeTree::set_has_projectnodeoptions() {
  _has_bits_[0] |= 0x00100000u;
}
inline void NodeTree::clear_has_projectnodeoptions() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void NodeTree::clear_projectnodeoptions() {
  if (projectnodeoptions_ != NULL) projectnodeoptions_->::protocolbuffers::ProjectNodeOptions::Clear();
  clear_has_projectnodeoptions();
}
inline const ::protocolbuffers::ProjectNodeOptions& NodeTree::projectnodeoptions() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return projectnodeoptions_ != NULL ? *projectnodeoptions_ : *default_instance().projectnodeoptions_;
#else
  return projectnodeoptions_ != NULL ? *projectnodeoptions_ : *default_instance_->projectnodeoptions_;
#endif
}
inline ::protocolbuffers::ProjectNodeOptions* NodeTree::mutable_projectnodeoptions() {
  set_has_projectnodeoptions();
  if (projectnodeoptions_ == NULL) projectnodeoptions_ = new ::protocolbuffers::ProjectNodeOptions;
  return projectnodeoptions_;
}
inline ::protocolbuffers::ProjectNodeOptions* NodeTree::release_projectnodeoptions() {
  clear_has_projectnodeoptions();
  ::protocolbuffers::ProjectNodeOptions* temp = projectnodeoptions_;
  projectnodeoptions_ = NULL;
  return temp;
}
inline void NodeTree::set_allocated_projectnodeoptions(::protocolbuffers::ProjectNodeOptions* projectnodeoptions) {
  delete projectnodeoptions_;
  projectnodeoptions_ = projectnodeoptions;
  if (projectnodeoptions) {
    set_has_projectnodeoptions();
  } else {
    clear_has_projectnodeoptions();
  }
}

// -------------------------------------------------------------------

// WidgetOptions

// optional float x = 1;
inline bool WidgetOptions::has_x() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void WidgetOptions::set_has_x() {
  _has_bits_[0] |= 0x00000001u;
}
inline void WidgetOptions::clear_has_x() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void WidgetOptions::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float WidgetOptions::x() const {
  return x_;
}
inline void WidgetOptions::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float y = 2;
inline bool WidgetOptions::has_y() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void WidgetOptions::set_has_y() {
  _has_bits_[0] |= 0x00000002u;
}
inline void WidgetOptions::clear_has_y() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void WidgetOptions::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float WidgetOptions::y() const {
  return y_;
}
inline void WidgetOptions::set_y(float value) {
  set_has_y();
  y_ = value;
}

// optional float scaleX = 3;
inline bool WidgetOptions::has_scalex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void WidgetOptions::set_has_scalex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void WidgetOptions::clear_has_scalex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void WidgetOptions::clear_scalex() {
  scalex_ = 0;
  clear_has_scalex();
}
inline float WidgetOptions::scalex() const {
  return scalex_;
}
inline void WidgetOptions::set_scalex(float value) {
  set_has_scalex();
  scalex_ = value;
}

// optional float scaleY = 4;
inline bool WidgetOptions::has_scaley() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void WidgetOptions::set_has_scaley() {
  _has_bits_[0] |= 0x00000008u;
}
inline void WidgetOptions::clear_has_scaley() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void WidgetOptions::clear_scaley() {
  scaley_ = 0;
  clear_has_scaley();
}
inline float WidgetOptions::scaley() const {
  return scaley_;
}
inline void WidgetOptions::set_scaley(float value) {
  set_has_scaley();
  scaley_ = value;
}

// optional float rotation = 5;
inline bool WidgetOptions::has_rotation() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void WidgetOptions::set_has_rotation() {
  _has_bits_[0] |= 0x00000010u;
}
inline void WidgetOptions::clear_has_rotation() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void WidgetOptions::clear_rotation() {
  rotation_ = 0;
  clear_has_rotation();
}
inline float WidgetOptions::rotation() const {
  return rotation_;
}
inline void WidgetOptions::set_rotation(float value) {
  set_has_rotation();
  rotation_ = value;
}

// optional bool flipX = 6;
inline bool WidgetOptions::has_flipx() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void WidgetOptions::set_has_flipx() {
  _has_bits_[0] |= 0x00000020u;
}
inline void WidgetOptions::clear_has_flipx() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void WidgetOptions::clear_flipx() {
  flipx_ = false;
  clear_has_flipx();
}
inline bool WidgetOptions::flipx() const {
  return flipx_;
}
inline void WidgetOptions::set_flipx(bool value) {
  set_has_flipx();
  flipx_ = value;
}

// optional bool flipY = 7;
inline bool WidgetOptions::has_flipy() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void WidgetOptions::set_has_flipy() {
  _has_bits_[0] |= 0x00000040u;
}
inline void WidgetOptions::clear_has_flipy() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void WidgetOptions::clear_flipy() {
  flipy_ = false;
  clear_has_flipy();
}
inline bool WidgetOptions::flipy() const {
  return flipy_;
}
inline void WidgetOptions::set_flipy(bool value) {
  set_has_flipy();
  flipy_ = value;
}

// optional int32 colorB = 8;
inline bool WidgetOptions::has_colorb() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void WidgetOptions::set_has_colorb() {
  _has_bits_[0] |= 0x00000080u;
}
inline void WidgetOptions::clear_has_colorb() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void WidgetOptions::clear_colorb() {
  colorb_ = 0;
  clear_has_colorb();
}
inline ::google::protobuf::int32 WidgetOptions::colorb() const {
  return colorb_;
}
inline void WidgetOptions::set_colorb(::google::protobuf::int32 value) {
  set_has_colorb();
  colorb_ = value;
}

// optional int32 colorG = 9;
inline bool WidgetOptions::has_colorg() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void WidgetOptions::set_has_colorg() {
  _has_bits_[0] |= 0x00000100u;
}
inline void WidgetOptions::clear_has_colorg() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void WidgetOptions::clear_colorg() {
  colorg_ = 0;
  clear_has_colorg();
}
inline ::google::protobuf::int32 WidgetOptions::colorg() const {
  return colorg_;
}
inline void WidgetOptions::set_colorg(::google::protobuf::int32 value) {
  set_has_colorg();
  colorg_ = value;
}

// optional int32 colorR = 10;
inline bool WidgetOptions::has_colorr() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void WidgetOptions::set_has_colorr() {
  _has_bits_[0] |= 0x00000200u;
}
inline void WidgetOptions::clear_has_colorr() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void WidgetOptions::clear_colorr() {
  colorr_ = 0;
  clear_has_colorr();
}
inline ::google::protobuf::int32 WidgetOptions::colorr() const {
  return colorr_;
}
inline void WidgetOptions::set_colorr(::google::protobuf::int32 value) {
  set_has_colorr();
  colorr_ = value;
}

// optional int32 opacity = 11;
inline bool WidgetOptions::has_opacity() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void WidgetOptions::set_has_opacity() {
  _has_bits_[0] |= 0x00000400u;
}
inline void WidgetOptions::clear_has_opacity() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void WidgetOptions::clear_opacity() {
  opacity_ = 0;
  clear_has_opacity();
}
inline ::google::protobuf::int32 WidgetOptions::opacity() const {
  return opacity_;
}
inline void WidgetOptions::set_opacity(::google::protobuf::int32 value) {
  set_has_opacity();
  opacity_ = value;
}

// optional bool touchAble = 12;
inline bool WidgetOptions::has_touchable() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void WidgetOptions::set_has_touchable() {
  _has_bits_[0] |= 0x00000800u;
}
inline void WidgetOptions::clear_has_touchable() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void WidgetOptions::clear_touchable() {
  touchable_ = false;
  clear_has_touchable();
}
inline bool WidgetOptions::touchable() const {
  return touchable_;
}
inline void WidgetOptions::set_touchable(bool value) {
  set_has_touchable();
  touchable_ = value;
}

// optional bool visible = 13;
inline bool WidgetOptions::has_visible() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void WidgetOptions::set_has_visible() {
  _has_bits_[0] |= 0x00001000u;
}
inline void WidgetOptions::clear_has_visible() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void WidgetOptions::clear_visible() {
  visible_ = false;
  clear_has_visible();
}
inline bool WidgetOptions::visible() const {
  return visible_;
}
inline void WidgetOptions::set_visible(bool value) {
  set_has_visible();
  visible_ = value;
}

// optional int32 zorder = 14;
inline bool WidgetOptions::has_zorder() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void WidgetOptions::set_has_zorder() {
  _has_bits_[0] |= 0x00002000u;
}
inline void WidgetOptions::clear_has_zorder() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void WidgetOptions::clear_zorder() {
  zorder_ = 0;
  clear_has_zorder();
}
inline ::google::protobuf::int32 WidgetOptions::zorder() const {
  return zorder_;
}
inline void WidgetOptions::set_zorder(::google::protobuf::int32 value) {
  set_has_zorder();
  zorder_ = value;
}

// optional string classType = 15;
inline bool WidgetOptions::has_classtype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void WidgetOptions::set_has_classtype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void WidgetOptions::clear_has_classtype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void WidgetOptions::clear_classtype() {
  if (classtype_ != &::google::protobuf::internal::kEmptyString) {
    classtype_->clear();
  }
  clear_has_classtype();
}
inline const ::std::string& WidgetOptions::classtype() const {
  return *classtype_;
}
inline void WidgetOptions::set_classtype(const ::std::string& value) {
  set_has_classtype();
  if (classtype_ == &::google::protobuf::internal::kEmptyString) {
    classtype_ = new ::std::string;
  }
  classtype_->assign(value);
}
inline void WidgetOptions::set_classtype(const char* value) {
  set_has_classtype();
  if (classtype_ == &::google::protobuf::internal::kEmptyString) {
    classtype_ = new ::std::string;
  }
  classtype_->assign(value);
}
inline void WidgetOptions::set_classtype(const char* value, size_t size) {
  set_has_classtype();
  if (classtype_ == &::google::protobuf::internal::kEmptyString) {
    classtype_ = new ::std::string;
  }
  classtype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WidgetOptions::mutable_classtype() {
  set_has_classtype();
  if (classtype_ == &::google::protobuf::internal::kEmptyString) {
    classtype_ = new ::std::string;
  }
  return classtype_;
}
inline ::std::string* WidgetOptions::release_classtype() {
  clear_has_classtype();
  if (classtype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classtype_;
    classtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WidgetOptions::set_allocated_classtype(::std::string* classtype) {
  if (classtype_ != &::google::protobuf::internal::kEmptyString) {
    delete classtype_;
  }
  if (classtype) {
    set_has_classtype();
    classtype_ = classtype;
  } else {
    clear_has_classtype();
    classtype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float width = 16;
inline bool WidgetOptions::has_width() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void WidgetOptions::set_has_width() {
  _has_bits_[0] |= 0x00008000u;
}
inline void WidgetOptions::clear_has_width() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void WidgetOptions::clear_width() {
  width_ = 0;
  clear_has_width();
}
inline float WidgetOptions::width() const {
  return width_;
}
inline void WidgetOptions::set_width(float value) {
  set_has_width();
  width_ = value;
}

// optional float height = 17;
inline bool WidgetOptions::has_height() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void WidgetOptions::set_has_height() {
  _has_bits_[0] |= 0x00010000u;
}
inline void WidgetOptions::clear_has_height() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void WidgetOptions::clear_height() {
  height_ = 0;
  clear_has_height();
}
inline float WidgetOptions::height() const {
  return height_;
}
inline void WidgetOptions::set_height(float value) {
  set_has_height();
  height_ = value;
}

// optional int32 positionType = 18;
inline bool WidgetOptions::has_positiontype() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void WidgetOptions::set_has_positiontype() {
  _has_bits_[0] |= 0x00020000u;
}
inline void WidgetOptions::clear_has_positiontype() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void WidgetOptions::clear_positiontype() {
  positiontype_ = 0;
  clear_has_positiontype();
}
inline ::google::protobuf::int32 WidgetOptions::positiontype() const {
  return positiontype_;
}
inline void WidgetOptions::set_positiontype(::google::protobuf::int32 value) {
  set_has_positiontype();
  positiontype_ = value;
}

// optional float positionPercentX = 19;
inline bool WidgetOptions::has_positionpercentx() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void WidgetOptions::set_has_positionpercentx() {
  _has_bits_[0] |= 0x00040000u;
}
inline void WidgetOptions::clear_has_positionpercentx() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void WidgetOptions::clear_positionpercentx() {
  positionpercentx_ = 0;
  clear_has_positionpercentx();
}
inline float WidgetOptions::positionpercentx() const {
  return positionpercentx_;
}
inline void WidgetOptions::set_positionpercentx(float value) {
  set_has_positionpercentx();
  positionpercentx_ = value;
}

// optional float positionPercentY = 20;
inline bool WidgetOptions::has_positionpercenty() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void WidgetOptions::set_has_positionpercenty() {
  _has_bits_[0] |= 0x00080000u;
}
inline void WidgetOptions::clear_has_positionpercenty() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void WidgetOptions::clear_positionpercenty() {
  positionpercenty_ = 0;
  clear_has_positionpercenty();
}
inline float WidgetOptions::positionpercenty() const {
  return positionpercenty_;
}
inline void WidgetOptions::set_positionpercenty(float value) {
  set_has_positionpercenty();
  positionpercenty_ = value;
}

// optional int32 sizeType = 21;
inline bool WidgetOptions::has_sizetype() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void WidgetOptions::set_has_sizetype() {
  _has_bits_[0] |= 0x00100000u;
}
inline void WidgetOptions::clear_has_sizetype() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void WidgetOptions::clear_sizetype() {
  sizetype_ = 0;
  clear_has_sizetype();
}
inline ::google::protobuf::int32 WidgetOptions::sizetype() const {
  return sizetype_;
}
inline void WidgetOptions::set_sizetype(::google::protobuf::int32 value) {
  set_has_sizetype();
  sizetype_ = value;
}

// optional float sizePercentX = 22;
inline bool WidgetOptions::has_sizepercentx() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void WidgetOptions::set_has_sizepercentx() {
  _has_bits_[0] |= 0x00200000u;
}
inline void WidgetOptions::clear_has_sizepercentx() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void WidgetOptions::clear_sizepercentx() {
  sizepercentx_ = 0;
  clear_has_sizepercentx();
}
inline float WidgetOptions::sizepercentx() const {
  return sizepercentx_;
}
inline void WidgetOptions::set_sizepercentx(float value) {
  set_has_sizepercentx();
  sizepercentx_ = value;
}

// optional float sizePercentY = 23;
inline bool WidgetOptions::has_sizepercenty() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void WidgetOptions::set_has_sizepercenty() {
  _has_bits_[0] |= 0x00400000u;
}
inline void WidgetOptions::clear_has_sizepercenty() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void WidgetOptions::clear_sizepercenty() {
  sizepercenty_ = 0;
  clear_has_sizepercenty();
}
inline float WidgetOptions::sizepercenty() const {
  return sizepercenty_;
}
inline void WidgetOptions::set_sizepercenty(float value) {
  set_has_sizepercenty();
  sizepercenty_ = value;
}

// optional bool useMergedTexture = 24;
inline bool WidgetOptions::has_usemergedtexture() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void WidgetOptions::set_has_usemergedtexture() {
  _has_bits_[0] |= 0x00800000u;
}
inline void WidgetOptions::clear_has_usemergedtexture() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void WidgetOptions::clear_usemergedtexture() {
  usemergedtexture_ = false;
  clear_has_usemergedtexture();
}
inline bool WidgetOptions::usemergedtexture() const {
  return usemergedtexture_;
}
inline void WidgetOptions::set_usemergedtexture(bool value) {
  set_has_usemergedtexture();
  usemergedtexture_ = value;
}

// optional int32 actionTag = 25;
inline bool WidgetOptions::has_actiontag() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void WidgetOptions::set_has_actiontag() {
  _has_bits_[0] |= 0x01000000u;
}
inline void WidgetOptions::clear_has_actiontag() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void WidgetOptions::clear_actiontag() {
  actiontag_ = 0;
  clear_has_actiontag();
}
inline ::google::protobuf::int32 WidgetOptions::actiontag() const {
  return actiontag_;
}
inline void WidgetOptions::set_actiontag(::google::protobuf::int32 value) {
  set_has_actiontag();
  actiontag_ = value;
}

// optional int32 tag = 26;
inline bool WidgetOptions::has_tag() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void WidgetOptions::set_has_tag() {
  _has_bits_[0] |= 0x02000000u;
}
inline void WidgetOptions::clear_has_tag() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void WidgetOptions::clear_tag() {
  tag_ = 0;
  clear_has_tag();
}
inline ::google::protobuf::int32 WidgetOptions::tag() const {
  return tag_;
}
inline void WidgetOptions::set_tag(::google::protobuf::int32 value) {
  set_has_tag();
  tag_ = value;
}

// optional float anchorPointX = 27;
inline bool WidgetOptions::has_anchorpointx() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void WidgetOptions::set_has_anchorpointx() {
  _has_bits_[0] |= 0x04000000u;
}
inline void WidgetOptions::clear_has_anchorpointx() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void WidgetOptions::clear_anchorpointx() {
  anchorpointx_ = 0;
  clear_has_anchorpointx();
}
inline float WidgetOptions::anchorpointx() const {
  return anchorpointx_;
}
inline void WidgetOptions::set_anchorpointx(float value) {
  set_has_anchorpointx();
  anchorpointx_ = value;
}

// optional float anchorPointY = 28;
inline bool WidgetOptions::has_anchorpointy() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void WidgetOptions::set_has_anchorpointy() {
  _has_bits_[0] |= 0x08000000u;
}
inline void WidgetOptions::clear_has_anchorpointy() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void WidgetOptions::clear_anchorpointy() {
  anchorpointy_ = 0;
  clear_has_anchorpointy();
}
inline float WidgetOptions::anchorpointy() const {
  return anchorpointy_;
}
inline void WidgetOptions::set_anchorpointy(float value) {
  set_has_anchorpointy();
  anchorpointy_ = value;
}

// optional bool ignoreSize = 29;
inline bool WidgetOptions::has_ignoresize() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void WidgetOptions::set_has_ignoresize() {
  _has_bits_[0] |= 0x10000000u;
}
inline void WidgetOptions::clear_has_ignoresize() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void WidgetOptions::clear_ignoresize() {
  ignoresize_ = false;
  clear_has_ignoresize();
}
inline bool WidgetOptions::ignoresize() const {
  return ignoresize_;
}
inline void WidgetOptions::set_ignoresize(bool value) {
  set_has_ignoresize();
  ignoresize_ = value;
}

// optional float rotationSkewX = 30;
inline bool WidgetOptions::has_rotationskewx() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void WidgetOptions::set_has_rotationskewx() {
  _has_bits_[0] |= 0x20000000u;
}
inline void WidgetOptions::clear_has_rotationskewx() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void WidgetOptions::clear_rotationskewx() {
  rotationskewx_ = 0;
  clear_has_rotationskewx();
}
inline float WidgetOptions::rotationskewx() const {
  return rotationskewx_;
}
inline void WidgetOptions::set_rotationskewx(float value) {
  set_has_rotationskewx();
  rotationskewx_ = value;
}

// optional float rotationSkewY = 31;
inline bool WidgetOptions::has_rotationskewy() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void WidgetOptions::set_has_rotationskewy() {
  _has_bits_[0] |= 0x40000000u;
}
inline void WidgetOptions::clear_has_rotationskewy() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void WidgetOptions::clear_rotationskewy() {
  rotationskewy_ = 0;
  clear_has_rotationskewy();
}
inline float WidgetOptions::rotationskewy() const {
  return rotationskewy_;
}
inline void WidgetOptions::set_rotationskewy(float value) {
  set_has_rotationskewy();
  rotationskewy_ = value;
}

// optional .protocolbuffers.LayoutParameter layoutParameter = 32;
inline bool WidgetOptions::has_layoutparameter() const {
  return (_has_bits_[0] & 0x80000000u) != 0;
}
inline void WidgetOptions::set_has_layoutparameter() {
  _has_bits_[0] |= 0x80000000u;
}
inline void WidgetOptions::clear_has_layoutparameter() {
  _has_bits_[0] &= ~0x80000000u;
}
inline void WidgetOptions::clear_layoutparameter() {
  if (layoutparameter_ != NULL) layoutparameter_->::protocolbuffers::LayoutParameter::Clear();
  clear_has_layoutparameter();
}
inline const ::protocolbuffers::LayoutParameter& WidgetOptions::layoutparameter() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return layoutparameter_ != NULL ? *layoutparameter_ : *default_instance().layoutparameter_;
#else
  return layoutparameter_ != NULL ? *layoutparameter_ : *default_instance_->layoutparameter_;
#endif
}
inline ::protocolbuffers::LayoutParameter* WidgetOptions::mutable_layoutparameter() {
  set_has_layoutparameter();
  if (layoutparameter_ == NULL) layoutparameter_ = new ::protocolbuffers::LayoutParameter;
  return layoutparameter_;
}
inline ::protocolbuffers::LayoutParameter* WidgetOptions::release_layoutparameter() {
  clear_has_layoutparameter();
  ::protocolbuffers::LayoutParameter* temp = layoutparameter_;
  layoutparameter_ = NULL;
  return temp;
}
inline void WidgetOptions::set_allocated_layoutparameter(::protocolbuffers::LayoutParameter* layoutparameter) {
  delete layoutparameter_;
  layoutparameter_ = layoutparameter;
  if (layoutparameter) {
    set_has_layoutparameter();
  } else {
    clear_has_layoutparameter();
  }
}

// optional string customProperty = 33;
inline bool WidgetOptions::has_customproperty() const {
  return (_has_bits_[1] & 0x00000001u) != 0;
}
inline void WidgetOptions::set_has_customproperty() {
  _has_bits_[1] |= 0x00000001u;
}
inline void WidgetOptions::clear_has_customproperty() {
  _has_bits_[1] &= ~0x00000001u;
}
inline void WidgetOptions::clear_customproperty() {
  if (customproperty_ != &::google::protobuf::internal::kEmptyString) {
    customproperty_->clear();
  }
  clear_has_customproperty();
}
inline const ::std::string& WidgetOptions::customproperty() const {
  return *customproperty_;
}
inline void WidgetOptions::set_customproperty(const ::std::string& value) {
  set_has_customproperty();
  if (customproperty_ == &::google::protobuf::internal::kEmptyString) {
    customproperty_ = new ::std::string;
  }
  customproperty_->assign(value);
}
inline void WidgetOptions::set_customproperty(const char* value) {
  set_has_customproperty();
  if (customproperty_ == &::google::protobuf::internal::kEmptyString) {
    customproperty_ = new ::std::string;
  }
  customproperty_->assign(value);
}
inline void WidgetOptions::set_customproperty(const char* value, size_t size) {
  set_has_customproperty();
  if (customproperty_ == &::google::protobuf::internal::kEmptyString) {
    customproperty_ = new ::std::string;
  }
  customproperty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WidgetOptions::mutable_customproperty() {
  set_has_customproperty();
  if (customproperty_ == &::google::protobuf::internal::kEmptyString) {
    customproperty_ = new ::std::string;
  }
  return customproperty_;
}
inline ::std::string* WidgetOptions::release_customproperty() {
  clear_has_customproperty();
  if (customproperty_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customproperty_;
    customproperty_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WidgetOptions::set_allocated_customproperty(::std::string* customproperty) {
  if (customproperty_ != &::google::protobuf::internal::kEmptyString) {
    delete customproperty_;
  }
  if (customproperty) {
    set_has_customproperty();
    customproperty_ = customproperty;
  } else {
    clear_has_customproperty();
    customproperty_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string frameEvent = 34;
inline bool WidgetOptions::has_frameevent() const {
  return (_has_bits_[1] & 0x00000002u) != 0;
}
inline void WidgetOptions::set_has_frameevent() {
  _has_bits_[1] |= 0x00000002u;
}
inline void WidgetOptions::clear_has_frameevent() {
  _has_bits_[1] &= ~0x00000002u;
}
inline void WidgetOptions::clear_frameevent() {
  if (frameevent_ != &::google::protobuf::internal::kEmptyString) {
    frameevent_->clear();
  }
  clear_has_frameevent();
}
inline const ::std::string& WidgetOptions::frameevent() const {
  return *frameevent_;
}
inline void WidgetOptions::set_frameevent(const ::std::string& value) {
  set_has_frameevent();
  if (frameevent_ == &::google::protobuf::internal::kEmptyString) {
    frameevent_ = new ::std::string;
  }
  frameevent_->assign(value);
}
inline void WidgetOptions::set_frameevent(const char* value) {
  set_has_frameevent();
  if (frameevent_ == &::google::protobuf::internal::kEmptyString) {
    frameevent_ = new ::std::string;
  }
  frameevent_->assign(value);
}
inline void WidgetOptions::set_frameevent(const char* value, size_t size) {
  set_has_frameevent();
  if (frameevent_ == &::google::protobuf::internal::kEmptyString) {
    frameevent_ = new ::std::string;
  }
  frameevent_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WidgetOptions::mutable_frameevent() {
  set_has_frameevent();
  if (frameevent_ == &::google::protobuf::internal::kEmptyString) {
    frameevent_ = new ::std::string;
  }
  return frameevent_;
}
inline ::std::string* WidgetOptions::release_frameevent() {
  clear_has_frameevent();
  if (frameevent_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = frameevent_;
    frameevent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WidgetOptions::set_allocated_frameevent(::std::string* frameevent) {
  if (frameevent_ != &::google::protobuf::internal::kEmptyString) {
    delete frameevent_;
  }
  if (frameevent) {
    set_has_frameevent();
    frameevent_ = frameevent;
  } else {
    clear_has_frameevent();
    frameevent_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string name = 35;
inline bool WidgetOptions::has_name() const {
  return (_has_bits_[1] & 0x00000004u) != 0;
}
inline void WidgetOptions::set_has_name() {
  _has_bits_[1] |= 0x00000004u;
}
inline void WidgetOptions::clear_has_name() {
  _has_bits_[1] &= ~0x00000004u;
}
inline void WidgetOptions::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& WidgetOptions::name() const {
  return *name_;
}
inline void WidgetOptions::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void WidgetOptions::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void WidgetOptions::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* WidgetOptions::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* WidgetOptions::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void WidgetOptions::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 Alpha = 37;
inline bool WidgetOptions::has_alpha() const {
  return (_has_bits_[1] & 0x00000008u) != 0;
}
inline void WidgetOptions::set_has_alpha() {
  _has_bits_[1] |= 0x00000008u;
}
inline void WidgetOptions::clear_has_alpha() {
  _has_bits_[1] &= ~0x00000008u;
}
inline void WidgetOptions::clear_alpha() {
  alpha_ = 0;
  clear_has_alpha();
}
inline ::google::protobuf::int32 WidgetOptions::alpha() const {
  return alpha_;
}
inline void WidgetOptions::set_alpha(::google::protobuf::int32 value) {
  set_has_alpha();
  alpha_ = value;
}

// repeated .protocolbuffers.ComponentOptions componentOptions = 36;
inline int WidgetOptions::componentoptions_size() const {
  return componentoptions_.size();
}
inline void WidgetOptions::clear_componentoptions() {
  componentoptions_.Clear();
}
inline const ::protocolbuffers::ComponentOptions& WidgetOptions::componentoptions(int index) const {
  return componentoptions_.Get(index);
}
inline ::protocolbuffers::ComponentOptions* WidgetOptions::mutable_componentoptions(int index) {
  return componentoptions_.Mutable(index);
}
inline ::protocolbuffers::ComponentOptions* WidgetOptions::add_componentoptions() {
  return componentoptions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocolbuffers::ComponentOptions >&
WidgetOptions::componentoptions() const {
  return componentoptions_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocolbuffers::ComponentOptions >*
WidgetOptions::mutable_componentoptions() {
  return &componentoptions_;
}

// -------------------------------------------------------------------

// LayoutParameter

// optional int32 type = 1;
inline bool LayoutParameter::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LayoutParameter::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LayoutParameter::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LayoutParameter::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::google::protobuf::int32 LayoutParameter::type() const {
  return type_;
}
inline void LayoutParameter::set_type(::google::protobuf::int32 value) {
  set_has_type();
  type_ = value;
}

// optional int32 gravity = 2;
inline bool LayoutParameter::has_gravity() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LayoutParameter::set_has_gravity() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LayoutParameter::clear_has_gravity() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LayoutParameter::clear_gravity() {
  gravity_ = 0;
  clear_has_gravity();
}
inline ::google::protobuf::int32 LayoutParameter::gravity() const {
  return gravity_;
}
inline void LayoutParameter::set_gravity(::google::protobuf::int32 value) {
  set_has_gravity();
  gravity_ = value;
}

// optional string relativeName = 3;
inline bool LayoutParameter::has_relativename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LayoutParameter::set_has_relativename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LayoutParameter::clear_has_relativename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LayoutParameter::clear_relativename() {
  if (relativename_ != &::google::protobuf::internal::kEmptyString) {
    relativename_->clear();
  }
  clear_has_relativename();
}
inline const ::std::string& LayoutParameter::relativename() const {
  return *relativename_;
}
inline void LayoutParameter::set_relativename(const ::std::string& value) {
  set_has_relativename();
  if (relativename_ == &::google::protobuf::internal::kEmptyString) {
    relativename_ = new ::std::string;
  }
  relativename_->assign(value);
}
inline void LayoutParameter::set_relativename(const char* value) {
  set_has_relativename();
  if (relativename_ == &::google::protobuf::internal::kEmptyString) {
    relativename_ = new ::std::string;
  }
  relativename_->assign(value);
}
inline void LayoutParameter::set_relativename(const char* value, size_t size) {
  set_has_relativename();
  if (relativename_ == &::google::protobuf::internal::kEmptyString) {
    relativename_ = new ::std::string;
  }
  relativename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayoutParameter::mutable_relativename() {
  set_has_relativename();
  if (relativename_ == &::google::protobuf::internal::kEmptyString) {
    relativename_ = new ::std::string;
  }
  return relativename_;
}
inline ::std::string* LayoutParameter::release_relativename() {
  clear_has_relativename();
  if (relativename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = relativename_;
    relativename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LayoutParameter::set_allocated_relativename(::std::string* relativename) {
  if (relativename_ != &::google::protobuf::internal::kEmptyString) {
    delete relativename_;
  }
  if (relativename) {
    set_has_relativename();
    relativename_ = relativename;
  } else {
    clear_has_relativename();
    relativename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string relativeToName = 4;
inline bool LayoutParameter::has_relativetoname() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LayoutParameter::set_has_relativetoname() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LayoutParameter::clear_has_relativetoname() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LayoutParameter::clear_relativetoname() {
  if (relativetoname_ != &::google::protobuf::internal::kEmptyString) {
    relativetoname_->clear();
  }
  clear_has_relativetoname();
}
inline const ::std::string& LayoutParameter::relativetoname() const {
  return *relativetoname_;
}
inline void LayoutParameter::set_relativetoname(const ::std::string& value) {
  set_has_relativetoname();
  if (relativetoname_ == &::google::protobuf::internal::kEmptyString) {
    relativetoname_ = new ::std::string;
  }
  relativetoname_->assign(value);
}
inline void LayoutParameter::set_relativetoname(const char* value) {
  set_has_relativetoname();
  if (relativetoname_ == &::google::protobuf::internal::kEmptyString) {
    relativetoname_ = new ::std::string;
  }
  relativetoname_->assign(value);
}
inline void LayoutParameter::set_relativetoname(const char* value, size_t size) {
  set_has_relativetoname();
  if (relativetoname_ == &::google::protobuf::internal::kEmptyString) {
    relativetoname_ = new ::std::string;
  }
  relativetoname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LayoutParameter::mutable_relativetoname() {
  set_has_relativetoname();
  if (relativetoname_ == &::google::protobuf::internal::kEmptyString) {
    relativetoname_ = new ::std::string;
  }
  return relativetoname_;
}
inline ::std::string* LayoutParameter::release_relativetoname() {
  clear_has_relativetoname();
  if (relativetoname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = relativetoname_;
    relativetoname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LayoutParameter::set_allocated_relativetoname(::std::string* relativetoname) {
  if (relativetoname_ != &::google::protobuf::internal::kEmptyString) {
    delete relativetoname_;
  }
  if (relativetoname) {
    set_has_relativetoname();
    relativetoname_ = relativetoname;
  } else {
    clear_has_relativetoname();
    relativetoname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 align = 5;
inline bool LayoutParameter::has_align() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LayoutParameter::set_has_align() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LayoutParameter::clear_has_align() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LayoutParameter::clear_align() {
  align_ = 0;
  clear_has_align();
}
inline ::google::protobuf::int32 LayoutParameter::align() const {
  return align_;
}
inline void LayoutParameter::set_align(::google::protobuf::int32 value) {
  set_has_align();
  align_ = value;
}

// optional int32 marginLeft = 6;
inline bool LayoutParameter::has_marginleft() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LayoutParameter::set_has_marginleft() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LayoutParameter::clear_has_marginleft() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LayoutParameter::clear_marginleft() {
  marginleft_ = 0;
  clear_has_marginleft();
}
inline ::google::protobuf::int32 LayoutParameter::marginleft() const {
  return marginleft_;
}
inline void LayoutParameter::set_marginleft(::google::protobuf::int32 value) {
  set_has_marginleft();
  marginleft_ = value;
}

// optional int32 marginTop = 7;
inline bool LayoutParameter::has_margintop() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LayoutParameter::set_has_margintop() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LayoutParameter::clear_has_margintop() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LayoutParameter::clear_margintop() {
  margintop_ = 0;
  clear_has_margintop();
}
inline ::google::protobuf::int32 LayoutParameter::margintop() const {
  return margintop_;
}
inline void LayoutParameter::set_margintop(::google::protobuf::int32 value) {
  set_has_margintop();
  margintop_ = value;
}

// optional int32 marginRight = 8;
inline bool LayoutParameter::has_marginright() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LayoutParameter::set_has_marginright() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LayoutParameter::clear_has_marginright() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LayoutParameter::clear_marginright() {
  marginright_ = 0;
  clear_has_marginright();
}
inline ::google::protobuf::int32 LayoutParameter::marginright() const {
  return marginright_;
}
inline void LayoutParameter::set_marginright(::google::protobuf::int32 value) {
  set_has_marginright();
  marginright_ = value;
}

// optional int32 marginDown = 9;
inline bool LayoutParameter::has_margindown() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LayoutParameter::set_has_margindown() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LayoutParameter::clear_has_margindown() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LayoutParameter::clear_margindown() {
  margindown_ = 0;
  clear_has_margindown();
}
inline ::google::protobuf::int32 LayoutParameter::margindown() const {
  return margindown_;
}
inline void LayoutParameter::set_margindown(::google::protobuf::int32 value) {
  set_has_margindown();
  margindown_ = value;
}

// optional int32 layoutEageType = 10;
inline bool LayoutParameter::has_layouteagetype() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LayoutParameter::set_has_layouteagetype() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LayoutParameter::clear_has_layouteagetype() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LayoutParameter::clear_layouteagetype() {
  layouteagetype_ = 0;
  clear_has_layouteagetype();
}
inline ::google::protobuf::int32 LayoutParameter::layouteagetype() const {
  return layouteagetype_;
}
inline void LayoutParameter::set_layouteagetype(::google::protobuf::int32 value) {
  set_has_layouteagetype();
  layouteagetype_ = value;
}

// optional int32 layoutNormalHorizontal = 11;
inline bool LayoutParameter::has_layoutnormalhorizontal() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LayoutParameter::set_has_layoutnormalhorizontal() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LayoutParameter::clear_has_layoutnormalhorizontal() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LayoutParameter::clear_layoutnormalhorizontal() {
  layoutnormalhorizontal_ = 0;
  clear_has_layoutnormalhorizontal();
}
inline ::google::protobuf::int32 LayoutParameter::layoutnormalhorizontal() const {
  return layoutnormalhorizontal_;
}
inline void LayoutParameter::set_layoutnormalhorizontal(::google::protobuf::int32 value) {
  set_has_layoutnormalhorizontal();
  layoutnormalhorizontal_ = value;
}

// optional int32 layoutNormalVertical = 12;
inline bool LayoutParameter::has_layoutnormalvertical() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LayoutParameter::set_has_layoutnormalvertical() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LayoutParameter::clear_has_layoutnormalvertical() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LayoutParameter::clear_layoutnormalvertical() {
  layoutnormalvertical_ = 0;
  clear_has_layoutnormalvertical();
}
inline ::google::protobuf::int32 LayoutParameter::layoutnormalvertical() const {
  return layoutnormalvertical_;
}
inline void LayoutParameter::set_layoutnormalvertical(::google::protobuf::int32 value) {
  set_has_layoutnormalvertical();
  layoutnormalvertical_ = value;
}

// optional int32 layoutParentHorizontal = 13;
inline bool LayoutParameter::has_layoutparenthorizontal() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LayoutParameter::set_has_layoutparenthorizontal() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LayoutParameter::clear_has_layoutparenthorizontal() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LayoutParameter::clear_layoutparenthorizontal() {
  layoutparenthorizontal_ = 0;
  clear_has_layoutparenthorizontal();
}
inline ::google::protobuf::int32 LayoutParameter::layoutparenthorizontal() const {
  return layoutparenthorizontal_;
}
inline void LayoutParameter::set_layoutparenthorizontal(::google::protobuf::int32 value) {
  set_has_layoutparenthorizontal();
  layoutparenthorizontal_ = value;
}

// optional int32 layoutParentVertical = 14;
inline bool LayoutParameter::has_layoutparentvertical() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void LayoutParameter::set_has_layoutparentvertical() {
  _has_bits_[0] |= 0x00002000u;
}
inline void LayoutParameter::clear_has_layoutparentvertical() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void LayoutParameter::clear_layoutparentvertical() {
  layoutparentvertical_ = 0;
  clear_has_layoutparentvertical();
}
inline ::google::protobuf::int32 LayoutParameter::layoutparentvertical() const {
  return layoutparentvertical_;
}
inline void LayoutParameter::set_layoutparentvertical(::google::protobuf::int32 value) {
  set_has_layoutparentvertical();
  layoutparentvertical_ = value;
}

// -------------------------------------------------------------------

// ButtonOptions

// optional string name = 1;
inline bool ButtonOptions::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ButtonOptions::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ButtonOptions::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ButtonOptions::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ButtonOptions::name() const {
  return *name_;
}
inline void ButtonOptions::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ButtonOptions::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ButtonOptions::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ButtonOptions::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ButtonOptions::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ButtonOptions::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classname = 2;
inline bool ButtonOptions::has_classname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ButtonOptions::set_has_classname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ButtonOptions::clear_has_classname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ButtonOptions::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& ButtonOptions::classname() const {
  return *classname_;
}
inline void ButtonOptions::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void ButtonOptions::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void ButtonOptions::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ButtonOptions::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* ButtonOptions::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ButtonOptions::set_allocated_classname(::std::string* classname) {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (classname) {
    set_has_classname();
    classname_ = classname;
  } else {
    clear_has_classname();
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string normal = 3;
inline bool ButtonOptions::has_normal() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ButtonOptions::set_has_normal() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ButtonOptions::clear_has_normal() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ButtonOptions::clear_normal() {
  if (normal_ != &::google::protobuf::internal::kEmptyString) {
    normal_->clear();
  }
  clear_has_normal();
}
inline const ::std::string& ButtonOptions::normal() const {
  return *normal_;
}
inline void ButtonOptions::set_normal(const ::std::string& value) {
  set_has_normal();
  if (normal_ == &::google::protobuf::internal::kEmptyString) {
    normal_ = new ::std::string;
  }
  normal_->assign(value);
}
inline void ButtonOptions::set_normal(const char* value) {
  set_has_normal();
  if (normal_ == &::google::protobuf::internal::kEmptyString) {
    normal_ = new ::std::string;
  }
  normal_->assign(value);
}
inline void ButtonOptions::set_normal(const char* value, size_t size) {
  set_has_normal();
  if (normal_ == &::google::protobuf::internal::kEmptyString) {
    normal_ = new ::std::string;
  }
  normal_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ButtonOptions::mutable_normal() {
  set_has_normal();
  if (normal_ == &::google::protobuf::internal::kEmptyString) {
    normal_ = new ::std::string;
  }
  return normal_;
}
inline ::std::string* ButtonOptions::release_normal() {
  clear_has_normal();
  if (normal_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = normal_;
    normal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ButtonOptions::set_allocated_normal(::std::string* normal) {
  if (normal_ != &::google::protobuf::internal::kEmptyString) {
    delete normal_;
  }
  if (normal) {
    set_has_normal();
    normal_ = normal;
  } else {
    clear_has_normal();
    normal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string pressed = 4;
inline bool ButtonOptions::has_pressed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ButtonOptions::set_has_pressed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ButtonOptions::clear_has_pressed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ButtonOptions::clear_pressed() {
  if (pressed_ != &::google::protobuf::internal::kEmptyString) {
    pressed_->clear();
  }
  clear_has_pressed();
}
inline const ::std::string& ButtonOptions::pressed() const {
  return *pressed_;
}
inline void ButtonOptions::set_pressed(const ::std::string& value) {
  set_has_pressed();
  if (pressed_ == &::google::protobuf::internal::kEmptyString) {
    pressed_ = new ::std::string;
  }
  pressed_->assign(value);
}
inline void ButtonOptions::set_pressed(const char* value) {
  set_has_pressed();
  if (pressed_ == &::google::protobuf::internal::kEmptyString) {
    pressed_ = new ::std::string;
  }
  pressed_->assign(value);
}
inline void ButtonOptions::set_pressed(const char* value, size_t size) {
  set_has_pressed();
  if (pressed_ == &::google::protobuf::internal::kEmptyString) {
    pressed_ = new ::std::string;
  }
  pressed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ButtonOptions::mutable_pressed() {
  set_has_pressed();
  if (pressed_ == &::google::protobuf::internal::kEmptyString) {
    pressed_ = new ::std::string;
  }
  return pressed_;
}
inline ::std::string* ButtonOptions::release_pressed() {
  clear_has_pressed();
  if (pressed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = pressed_;
    pressed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ButtonOptions::set_allocated_pressed(::std::string* pressed) {
  if (pressed_ != &::google::protobuf::internal::kEmptyString) {
    delete pressed_;
  }
  if (pressed) {
    set_has_pressed();
    pressed_ = pressed;
  } else {
    clear_has_pressed();
    pressed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string disabled = 5;
inline bool ButtonOptions::has_disabled() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ButtonOptions::set_has_disabled() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ButtonOptions::clear_has_disabled() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ButtonOptions::clear_disabled() {
  if (disabled_ != &::google::protobuf::internal::kEmptyString) {
    disabled_->clear();
  }
  clear_has_disabled();
}
inline const ::std::string& ButtonOptions::disabled() const {
  return *disabled_;
}
inline void ButtonOptions::set_disabled(const ::std::string& value) {
  set_has_disabled();
  if (disabled_ == &::google::protobuf::internal::kEmptyString) {
    disabled_ = new ::std::string;
  }
  disabled_->assign(value);
}
inline void ButtonOptions::set_disabled(const char* value) {
  set_has_disabled();
  if (disabled_ == &::google::protobuf::internal::kEmptyString) {
    disabled_ = new ::std::string;
  }
  disabled_->assign(value);
}
inline void ButtonOptions::set_disabled(const char* value, size_t size) {
  set_has_disabled();
  if (disabled_ == &::google::protobuf::internal::kEmptyString) {
    disabled_ = new ::std::string;
  }
  disabled_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ButtonOptions::mutable_disabled() {
  set_has_disabled();
  if (disabled_ == &::google::protobuf::internal::kEmptyString) {
    disabled_ = new ::std::string;
  }
  return disabled_;
}
inline ::std::string* ButtonOptions::release_disabled() {
  clear_has_disabled();
  if (disabled_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = disabled_;
    disabled_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ButtonOptions::set_allocated_disabled(::std::string* disabled) {
  if (disabled_ != &::google::protobuf::internal::kEmptyString) {
    delete disabled_;
  }
  if (disabled) {
    set_has_disabled();
    disabled_ = disabled;
  } else {
    clear_has_disabled();
    disabled_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protocolbuffers.ResourceData normalData = 6;
inline bool ButtonOptions::has_normaldata() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ButtonOptions::set_has_normaldata() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ButtonOptions::clear_has_normaldata() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ButtonOptions::clear_normaldata() {
  if (normaldata_ != NULL) normaldata_->::protocolbuffers::ResourceData::Clear();
  clear_has_normaldata();
}
inline const ::protocolbuffers::ResourceData& ButtonOptions::normaldata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return normaldata_ != NULL ? *normaldata_ : *default_instance().normaldata_;
#else
  return normaldata_ != NULL ? *normaldata_ : *default_instance_->normaldata_;
#endif
}
inline ::protocolbuffers::ResourceData* ButtonOptions::mutable_normaldata() {
  set_has_normaldata();
  if (normaldata_ == NULL) normaldata_ = new ::protocolbuffers::ResourceData;
  return normaldata_;
}
inline ::protocolbuffers::ResourceData* ButtonOptions::release_normaldata() {
  clear_has_normaldata();
  ::protocolbuffers::ResourceData* temp = normaldata_;
  normaldata_ = NULL;
  return temp;
}
inline void ButtonOptions::set_allocated_normaldata(::protocolbuffers::ResourceData* normaldata) {
  delete normaldata_;
  normaldata_ = normaldata;
  if (normaldata) {
    set_has_normaldata();
  } else {
    clear_has_normaldata();
  }
}

// optional .protocolbuffers.ResourceData pressedData = 7;
inline bool ButtonOptions::has_presseddata() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ButtonOptions::set_has_presseddata() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ButtonOptions::clear_has_presseddata() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ButtonOptions::clear_presseddata() {
  if (presseddata_ != NULL) presseddata_->::protocolbuffers::ResourceData::Clear();
  clear_has_presseddata();
}
inline const ::protocolbuffers::ResourceData& ButtonOptions::presseddata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return presseddata_ != NULL ? *presseddata_ : *default_instance().presseddata_;
#else
  return presseddata_ != NULL ? *presseddata_ : *default_instance_->presseddata_;
#endif
}
inline ::protocolbuffers::ResourceData* ButtonOptions::mutable_presseddata() {
  set_has_presseddata();
  if (presseddata_ == NULL) presseddata_ = new ::protocolbuffers::ResourceData;
  return presseddata_;
}
inline ::protocolbuffers::ResourceData* ButtonOptions::release_presseddata() {
  clear_has_presseddata();
  ::protocolbuffers::ResourceData* temp = presseddata_;
  presseddata_ = NULL;
  return temp;
}
inline void ButtonOptions::set_allocated_presseddata(::protocolbuffers::ResourceData* presseddata) {
  delete presseddata_;
  presseddata_ = presseddata;
  if (presseddata) {
    set_has_presseddata();
  } else {
    clear_has_presseddata();
  }
}

// optional .protocolbuffers.ResourceData disabledData = 8;
inline bool ButtonOptions::has_disableddata() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ButtonOptions::set_has_disableddata() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ButtonOptions::clear_has_disableddata() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ButtonOptions::clear_disableddata() {
  if (disableddata_ != NULL) disableddata_->::protocolbuffers::ResourceData::Clear();
  clear_has_disableddata();
}
inline const ::protocolbuffers::ResourceData& ButtonOptions::disableddata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return disableddata_ != NULL ? *disableddata_ : *default_instance().disableddata_;
#else
  return disableddata_ != NULL ? *disableddata_ : *default_instance_->disableddata_;
#endif
}
inline ::protocolbuffers::ResourceData* ButtonOptions::mutable_disableddata() {
  set_has_disableddata();
  if (disableddata_ == NULL) disableddata_ = new ::protocolbuffers::ResourceData;
  return disableddata_;
}
inline ::protocolbuffers::ResourceData* ButtonOptions::release_disableddata() {
  clear_has_disableddata();
  ::protocolbuffers::ResourceData* temp = disableddata_;
  disableddata_ = NULL;
  return temp;
}
inline void ButtonOptions::set_allocated_disableddata(::protocolbuffers::ResourceData* disableddata) {
  delete disableddata_;
  disableddata_ = disableddata;
  if (disableddata) {
    set_has_disableddata();
  } else {
    clear_has_disableddata();
  }
}

// optional string text = 9;
inline bool ButtonOptions::has_text() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ButtonOptions::set_has_text() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ButtonOptions::clear_has_text() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ButtonOptions::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& ButtonOptions::text() const {
  return *text_;
}
inline void ButtonOptions::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void ButtonOptions::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void ButtonOptions::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ButtonOptions::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* ButtonOptions::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ButtonOptions::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fontName = 10;
inline bool ButtonOptions::has_fontname() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ButtonOptions::set_has_fontname() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ButtonOptions::clear_has_fontname() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ButtonOptions::clear_fontname() {
  if (fontname_ != &::google::protobuf::internal::kEmptyString) {
    fontname_->clear();
  }
  clear_has_fontname();
}
inline const ::std::string& ButtonOptions::fontname() const {
  return *fontname_;
}
inline void ButtonOptions::set_fontname(const ::std::string& value) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(value);
}
inline void ButtonOptions::set_fontname(const char* value) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(value);
}
inline void ButtonOptions::set_fontname(const char* value, size_t size) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ButtonOptions::mutable_fontname() {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    fontname_ = new ::std::string;
  }
  return fontname_;
}
inline ::std::string* ButtonOptions::release_fontname() {
  clear_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fontname_;
    fontname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ButtonOptions::set_allocated_fontname(::std::string* fontname) {
  if (fontname_ != &::google::protobuf::internal::kEmptyString) {
    delete fontname_;
  }
  if (fontname) {
    set_has_fontname();
    fontname_ = fontname;
  } else {
    clear_has_fontname();
    fontname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 fontSize = 11;
inline bool ButtonOptions::has_fontsize() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ButtonOptions::set_has_fontsize() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ButtonOptions::clear_has_fontsize() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ButtonOptions::clear_fontsize() {
  fontsize_ = 0;
  clear_has_fontsize();
}
inline ::google::protobuf::int32 ButtonOptions::fontsize() const {
  return fontsize_;
}
inline void ButtonOptions::set_fontsize(::google::protobuf::int32 value) {
  set_has_fontsize();
  fontsize_ = value;
}

// optional int32 textColorR = 12;
inline bool ButtonOptions::has_textcolorr() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ButtonOptions::set_has_textcolorr() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ButtonOptions::clear_has_textcolorr() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ButtonOptions::clear_textcolorr() {
  textcolorr_ = 0;
  clear_has_textcolorr();
}
inline ::google::protobuf::int32 ButtonOptions::textcolorr() const {
  return textcolorr_;
}
inline void ButtonOptions::set_textcolorr(::google::protobuf::int32 value) {
  set_has_textcolorr();
  textcolorr_ = value;
}

// optional int32 textColorG = 13;
inline bool ButtonOptions::has_textcolorg() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ButtonOptions::set_has_textcolorg() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ButtonOptions::clear_has_textcolorg() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ButtonOptions::clear_textcolorg() {
  textcolorg_ = 0;
  clear_has_textcolorg();
}
inline ::google::protobuf::int32 ButtonOptions::textcolorg() const {
  return textcolorg_;
}
inline void ButtonOptions::set_textcolorg(::google::protobuf::int32 value) {
  set_has_textcolorg();
  textcolorg_ = value;
}

// optional int32 textColorB = 14;
inline bool ButtonOptions::has_textcolorb() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ButtonOptions::set_has_textcolorb() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ButtonOptions::clear_has_textcolorb() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ButtonOptions::clear_textcolorb() {
  textcolorb_ = 0;
  clear_has_textcolorb();
}
inline ::google::protobuf::int32 ButtonOptions::textcolorb() const {
  return textcolorb_;
}
inline void ButtonOptions::set_textcolorb(::google::protobuf::int32 value) {
  set_has_textcolorb();
  textcolorb_ = value;
}

// optional float capInsetsX = 15;
inline bool ButtonOptions::has_capinsetsx() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ButtonOptions::set_has_capinsetsx() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ButtonOptions::clear_has_capinsetsx() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ButtonOptions::clear_capinsetsx() {
  capinsetsx_ = 0;
  clear_has_capinsetsx();
}
inline float ButtonOptions::capinsetsx() const {
  return capinsetsx_;
}
inline void ButtonOptions::set_capinsetsx(float value) {
  set_has_capinsetsx();
  capinsetsx_ = value;
}

// optional float capInsetsY = 16;
inline bool ButtonOptions::has_capinsetsy() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ButtonOptions::set_has_capinsetsy() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ButtonOptions::clear_has_capinsetsy() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ButtonOptions::clear_capinsetsy() {
  capinsetsy_ = 0;
  clear_has_capinsetsy();
}
inline float ButtonOptions::capinsetsy() const {
  return capinsetsy_;
}
inline void ButtonOptions::set_capinsetsy(float value) {
  set_has_capinsetsy();
  capinsetsy_ = value;
}

// optional float capInsetsWidth = 17;
inline bool ButtonOptions::has_capinsetswidth() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ButtonOptions::set_has_capinsetswidth() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ButtonOptions::clear_has_capinsetswidth() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ButtonOptions::clear_capinsetswidth() {
  capinsetswidth_ = 0;
  clear_has_capinsetswidth();
}
inline float ButtonOptions::capinsetswidth() const {
  return capinsetswidth_;
}
inline void ButtonOptions::set_capinsetswidth(float value) {
  set_has_capinsetswidth();
  capinsetswidth_ = value;
}

// optional float capInsetsHeight = 18;
inline bool ButtonOptions::has_capinsetsheight() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ButtonOptions::set_has_capinsetsheight() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ButtonOptions::clear_has_capinsetsheight() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ButtonOptions::clear_capinsetsheight() {
  capinsetsheight_ = 0;
  clear_has_capinsetsheight();
}
inline float ButtonOptions::capinsetsheight() const {
  return capinsetsheight_;
}
inline void ButtonOptions::set_capinsetsheight(float value) {
  set_has_capinsetsheight();
  capinsetsheight_ = value;
}

// optional float scale9Width = 19;
inline bool ButtonOptions::has_scale9width() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ButtonOptions::set_has_scale9width() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ButtonOptions::clear_has_scale9width() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ButtonOptions::clear_scale9width() {
  scale9width_ = 0;
  clear_has_scale9width();
}
inline float ButtonOptions::scale9width() const {
  return scale9width_;
}
inline void ButtonOptions::set_scale9width(float value) {
  set_has_scale9width();
  scale9width_ = value;
}

// optional float scale9Height = 20;
inline bool ButtonOptions::has_scale9height() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ButtonOptions::set_has_scale9height() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ButtonOptions::clear_has_scale9height() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ButtonOptions::clear_scale9height() {
  scale9height_ = 0;
  clear_has_scale9height();
}
inline float ButtonOptions::scale9height() const {
  return scale9height_;
}
inline void ButtonOptions::set_scale9height(float value) {
  set_has_scale9height();
  scale9height_ = value;
}

// optional bool scale9Enable = 21;
inline bool ButtonOptions::has_scale9enable() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ButtonOptions::set_has_scale9enable() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ButtonOptions::clear_has_scale9enable() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ButtonOptions::clear_scale9enable() {
  scale9enable_ = false;
  clear_has_scale9enable();
}
inline bool ButtonOptions::scale9enable() const {
  return scale9enable_;
}
inline void ButtonOptions::set_scale9enable(bool value) {
  set_has_scale9enable();
  scale9enable_ = value;
}

// optional bool displaystate = 22;
inline bool ButtonOptions::has_displaystate() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ButtonOptions::set_has_displaystate() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ButtonOptions::clear_has_displaystate() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ButtonOptions::clear_displaystate() {
  displaystate_ = false;
  clear_has_displaystate();
}
inline bool ButtonOptions::displaystate() const {
  return displaystate_;
}
inline void ButtonOptions::set_displaystate(bool value) {
  set_has_displaystate();
  displaystate_ = value;
}

// optional .protocolbuffers.ResourceData fontResource = 23;
inline bool ButtonOptions::has_fontresource() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ButtonOptions::set_has_fontresource() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ButtonOptions::clear_has_fontresource() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ButtonOptions::clear_fontresource() {
  if (fontresource_ != NULL) fontresource_->::protocolbuffers::ResourceData::Clear();
  clear_has_fontresource();
}
inline const ::protocolbuffers::ResourceData& ButtonOptions::fontresource() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fontresource_ != NULL ? *fontresource_ : *default_instance().fontresource_;
#else
  return fontresource_ != NULL ? *fontresource_ : *default_instance_->fontresource_;
#endif
}
inline ::protocolbuffers::ResourceData* ButtonOptions::mutable_fontresource() {
  set_has_fontresource();
  if (fontresource_ == NULL) fontresource_ = new ::protocolbuffers::ResourceData;
  return fontresource_;
}
inline ::protocolbuffers::ResourceData* ButtonOptions::release_fontresource() {
  clear_has_fontresource();
  ::protocolbuffers::ResourceData* temp = fontresource_;
  fontresource_ = NULL;
  return temp;
}
inline void ButtonOptions::set_allocated_fontresource(::protocolbuffers::ResourceData* fontresource) {
  delete fontresource_;
  fontresource_ = fontresource;
  if (fontresource) {
    set_has_fontresource();
  } else {
    clear_has_fontresource();
  }
}

// -------------------------------------------------------------------

// ResourceData

// optional string path = 1;
inline bool ResourceData::has_path() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ResourceData::set_has_path() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ResourceData::clear_has_path() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ResourceData::clear_path() {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    path_->clear();
  }
  clear_has_path();
}
inline const ::std::string& ResourceData::path() const {
  return *path_;
}
inline void ResourceData::set_path(const ::std::string& value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void ResourceData::set_path(const char* value) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(value);
}
inline void ResourceData::set_path(const char* value, size_t size) {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  path_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResourceData::mutable_path() {
  set_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    path_ = new ::std::string;
  }
  return path_;
}
inline ::std::string* ResourceData::release_path() {
  clear_has_path();
  if (path_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = path_;
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResourceData::set_allocated_path(::std::string* path) {
  if (path_ != &::google::protobuf::internal::kEmptyString) {
    delete path_;
  }
  if (path) {
    set_has_path();
    path_ = path;
  } else {
    clear_has_path();
    path_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string plistFile = 2;
inline bool ResourceData::has_plistfile() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ResourceData::set_has_plistfile() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ResourceData::clear_has_plistfile() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ResourceData::clear_plistfile() {
  if (plistfile_ != &::google::protobuf::internal::kEmptyString) {
    plistfile_->clear();
  }
  clear_has_plistfile();
}
inline const ::std::string& ResourceData::plistfile() const {
  return *plistfile_;
}
inline void ResourceData::set_plistfile(const ::std::string& value) {
  set_has_plistfile();
  if (plistfile_ == &::google::protobuf::internal::kEmptyString) {
    plistfile_ = new ::std::string;
  }
  plistfile_->assign(value);
}
inline void ResourceData::set_plistfile(const char* value) {
  set_has_plistfile();
  if (plistfile_ == &::google::protobuf::internal::kEmptyString) {
    plistfile_ = new ::std::string;
  }
  plistfile_->assign(value);
}
inline void ResourceData::set_plistfile(const char* value, size_t size) {
  set_has_plistfile();
  if (plistfile_ == &::google::protobuf::internal::kEmptyString) {
    plistfile_ = new ::std::string;
  }
  plistfile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ResourceData::mutable_plistfile() {
  set_has_plistfile();
  if (plistfile_ == &::google::protobuf::internal::kEmptyString) {
    plistfile_ = new ::std::string;
  }
  return plistfile_;
}
inline ::std::string* ResourceData::release_plistfile() {
  clear_has_plistfile();
  if (plistfile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = plistfile_;
    plistfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ResourceData::set_allocated_plistfile(::std::string* plistfile) {
  if (plistfile_ != &::google::protobuf::internal::kEmptyString) {
    delete plistfile_;
  }
  if (plistfile) {
    set_has_plistfile();
    plistfile_ = plistfile;
  } else {
    clear_has_plistfile();
    plistfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 resourceType = 3;
inline bool ResourceData::has_resourcetype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ResourceData::set_has_resourcetype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ResourceData::clear_has_resourcetype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ResourceData::clear_resourcetype() {
  resourcetype_ = 0;
  clear_has_resourcetype();
}
inline ::google::protobuf::int32 ResourceData::resourcetype() const {
  return resourcetype_;
}
inline void ResourceData::set_resourcetype(::google::protobuf::int32 value) {
  set_has_resourcetype();
  resourcetype_ = value;
}

// -------------------------------------------------------------------

// CheckBoxOptions

// optional string name = 1;
inline bool CheckBoxOptions::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void CheckBoxOptions::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void CheckBoxOptions::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void CheckBoxOptions::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& CheckBoxOptions::name() const {
  return *name_;
}
inline void CheckBoxOptions::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CheckBoxOptions::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void CheckBoxOptions::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckBoxOptions::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* CheckBoxOptions::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckBoxOptions::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classname = 2;
inline bool CheckBoxOptions::has_classname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void CheckBoxOptions::set_has_classname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void CheckBoxOptions::clear_has_classname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void CheckBoxOptions::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& CheckBoxOptions::classname() const {
  return *classname_;
}
inline void CheckBoxOptions::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void CheckBoxOptions::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void CheckBoxOptions::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckBoxOptions::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* CheckBoxOptions::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckBoxOptions::set_allocated_classname(::std::string* classname) {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (classname) {
    set_has_classname();
    classname_ = classname;
  } else {
    clear_has_classname();
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string backGroundBox = 3;
inline bool CheckBoxOptions::has_backgroundbox() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void CheckBoxOptions::set_has_backgroundbox() {
  _has_bits_[0] |= 0x00000004u;
}
inline void CheckBoxOptions::clear_has_backgroundbox() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void CheckBoxOptions::clear_backgroundbox() {
  if (backgroundbox_ != &::google::protobuf::internal::kEmptyString) {
    backgroundbox_->clear();
  }
  clear_has_backgroundbox();
}
inline const ::std::string& CheckBoxOptions::backgroundbox() const {
  return *backgroundbox_;
}
inline void CheckBoxOptions::set_backgroundbox(const ::std::string& value) {
  set_has_backgroundbox();
  if (backgroundbox_ == &::google::protobuf::internal::kEmptyString) {
    backgroundbox_ = new ::std::string;
  }
  backgroundbox_->assign(value);
}
inline void CheckBoxOptions::set_backgroundbox(const char* value) {
  set_has_backgroundbox();
  if (backgroundbox_ == &::google::protobuf::internal::kEmptyString) {
    backgroundbox_ = new ::std::string;
  }
  backgroundbox_->assign(value);
}
inline void CheckBoxOptions::set_backgroundbox(const char* value, size_t size) {
  set_has_backgroundbox();
  if (backgroundbox_ == &::google::protobuf::internal::kEmptyString) {
    backgroundbox_ = new ::std::string;
  }
  backgroundbox_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckBoxOptions::mutable_backgroundbox() {
  set_has_backgroundbox();
  if (backgroundbox_ == &::google::protobuf::internal::kEmptyString) {
    backgroundbox_ = new ::std::string;
  }
  return backgroundbox_;
}
inline ::std::string* CheckBoxOptions::release_backgroundbox() {
  clear_has_backgroundbox();
  if (backgroundbox_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = backgroundbox_;
    backgroundbox_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckBoxOptions::set_allocated_backgroundbox(::std::string* backgroundbox) {
  if (backgroundbox_ != &::google::protobuf::internal::kEmptyString) {
    delete backgroundbox_;
  }
  if (backgroundbox) {
    set_has_backgroundbox();
    backgroundbox_ = backgroundbox;
  } else {
    clear_has_backgroundbox();
    backgroundbox_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string backGroundBoxSelected = 4;
inline bool CheckBoxOptions::has_backgroundboxselected() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void CheckBoxOptions::set_has_backgroundboxselected() {
  _has_bits_[0] |= 0x00000008u;
}
inline void CheckBoxOptions::clear_has_backgroundboxselected() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void CheckBoxOptions::clear_backgroundboxselected() {
  if (backgroundboxselected_ != &::google::protobuf::internal::kEmptyString) {
    backgroundboxselected_->clear();
  }
  clear_has_backgroundboxselected();
}
inline const ::std::string& CheckBoxOptions::backgroundboxselected() const {
  return *backgroundboxselected_;
}
inline void CheckBoxOptions::set_backgroundboxselected(const ::std::string& value) {
  set_has_backgroundboxselected();
  if (backgroundboxselected_ == &::google::protobuf::internal::kEmptyString) {
    backgroundboxselected_ = new ::std::string;
  }
  backgroundboxselected_->assign(value);
}
inline void CheckBoxOptions::set_backgroundboxselected(const char* value) {
  set_has_backgroundboxselected();
  if (backgroundboxselected_ == &::google::protobuf::internal::kEmptyString) {
    backgroundboxselected_ = new ::std::string;
  }
  backgroundboxselected_->assign(value);
}
inline void CheckBoxOptions::set_backgroundboxselected(const char* value, size_t size) {
  set_has_backgroundboxselected();
  if (backgroundboxselected_ == &::google::protobuf::internal::kEmptyString) {
    backgroundboxselected_ = new ::std::string;
  }
  backgroundboxselected_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckBoxOptions::mutable_backgroundboxselected() {
  set_has_backgroundboxselected();
  if (backgroundboxselected_ == &::google::protobuf::internal::kEmptyString) {
    backgroundboxselected_ = new ::std::string;
  }
  return backgroundboxselected_;
}
inline ::std::string* CheckBoxOptions::release_backgroundboxselected() {
  clear_has_backgroundboxselected();
  if (backgroundboxselected_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = backgroundboxselected_;
    backgroundboxselected_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckBoxOptions::set_allocated_backgroundboxselected(::std::string* backgroundboxselected) {
  if (backgroundboxselected_ != &::google::protobuf::internal::kEmptyString) {
    delete backgroundboxselected_;
  }
  if (backgroundboxselected) {
    set_has_backgroundboxselected();
    backgroundboxselected_ = backgroundboxselected;
  } else {
    clear_has_backgroundboxselected();
    backgroundboxselected_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string backGroundBoxDisabled = 5;
inline bool CheckBoxOptions::has_backgroundboxdisabled() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void CheckBoxOptions::set_has_backgroundboxdisabled() {
  _has_bits_[0] |= 0x00000010u;
}
inline void CheckBoxOptions::clear_has_backgroundboxdisabled() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void CheckBoxOptions::clear_backgroundboxdisabled() {
  if (backgroundboxdisabled_ != &::google::protobuf::internal::kEmptyString) {
    backgroundboxdisabled_->clear();
  }
  clear_has_backgroundboxdisabled();
}
inline const ::std::string& CheckBoxOptions::backgroundboxdisabled() const {
  return *backgroundboxdisabled_;
}
inline void CheckBoxOptions::set_backgroundboxdisabled(const ::std::string& value) {
  set_has_backgroundboxdisabled();
  if (backgroundboxdisabled_ == &::google::protobuf::internal::kEmptyString) {
    backgroundboxdisabled_ = new ::std::string;
  }
  backgroundboxdisabled_->assign(value);
}
inline void CheckBoxOptions::set_backgroundboxdisabled(const char* value) {
  set_has_backgroundboxdisabled();
  if (backgroundboxdisabled_ == &::google::protobuf::internal::kEmptyString) {
    backgroundboxdisabled_ = new ::std::string;
  }
  backgroundboxdisabled_->assign(value);
}
inline void CheckBoxOptions::set_backgroundboxdisabled(const char* value, size_t size) {
  set_has_backgroundboxdisabled();
  if (backgroundboxdisabled_ == &::google::protobuf::internal::kEmptyString) {
    backgroundboxdisabled_ = new ::std::string;
  }
  backgroundboxdisabled_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckBoxOptions::mutable_backgroundboxdisabled() {
  set_has_backgroundboxdisabled();
  if (backgroundboxdisabled_ == &::google::protobuf::internal::kEmptyString) {
    backgroundboxdisabled_ = new ::std::string;
  }
  return backgroundboxdisabled_;
}
inline ::std::string* CheckBoxOptions::release_backgroundboxdisabled() {
  clear_has_backgroundboxdisabled();
  if (backgroundboxdisabled_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = backgroundboxdisabled_;
    backgroundboxdisabled_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckBoxOptions::set_allocated_backgroundboxdisabled(::std::string* backgroundboxdisabled) {
  if (backgroundboxdisabled_ != &::google::protobuf::internal::kEmptyString) {
    delete backgroundboxdisabled_;
  }
  if (backgroundboxdisabled) {
    set_has_backgroundboxdisabled();
    backgroundboxdisabled_ = backgroundboxdisabled;
  } else {
    clear_has_backgroundboxdisabled();
    backgroundboxdisabled_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string frontCross = 6;
inline bool CheckBoxOptions::has_frontcross() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void CheckBoxOptions::set_has_frontcross() {
  _has_bits_[0] |= 0x00000020u;
}
inline void CheckBoxOptions::clear_has_frontcross() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void CheckBoxOptions::clear_frontcross() {
  if (frontcross_ != &::google::protobuf::internal::kEmptyString) {
    frontcross_->clear();
  }
  clear_has_frontcross();
}
inline const ::std::string& CheckBoxOptions::frontcross() const {
  return *frontcross_;
}
inline void CheckBoxOptions::set_frontcross(const ::std::string& value) {
  set_has_frontcross();
  if (frontcross_ == &::google::protobuf::internal::kEmptyString) {
    frontcross_ = new ::std::string;
  }
  frontcross_->assign(value);
}
inline void CheckBoxOptions::set_frontcross(const char* value) {
  set_has_frontcross();
  if (frontcross_ == &::google::protobuf::internal::kEmptyString) {
    frontcross_ = new ::std::string;
  }
  frontcross_->assign(value);
}
inline void CheckBoxOptions::set_frontcross(const char* value, size_t size) {
  set_has_frontcross();
  if (frontcross_ == &::google::protobuf::internal::kEmptyString) {
    frontcross_ = new ::std::string;
  }
  frontcross_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckBoxOptions::mutable_frontcross() {
  set_has_frontcross();
  if (frontcross_ == &::google::protobuf::internal::kEmptyString) {
    frontcross_ = new ::std::string;
  }
  return frontcross_;
}
inline ::std::string* CheckBoxOptions::release_frontcross() {
  clear_has_frontcross();
  if (frontcross_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = frontcross_;
    frontcross_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckBoxOptions::set_allocated_frontcross(::std::string* frontcross) {
  if (frontcross_ != &::google::protobuf::internal::kEmptyString) {
    delete frontcross_;
  }
  if (frontcross) {
    set_has_frontcross();
    frontcross_ = frontcross;
  } else {
    clear_has_frontcross();
    frontcross_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string frontCrossDisabled = 7;
inline bool CheckBoxOptions::has_frontcrossdisabled() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void CheckBoxOptions::set_has_frontcrossdisabled() {
  _has_bits_[0] |= 0x00000040u;
}
inline void CheckBoxOptions::clear_has_frontcrossdisabled() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void CheckBoxOptions::clear_frontcrossdisabled() {
  if (frontcrossdisabled_ != &::google::protobuf::internal::kEmptyString) {
    frontcrossdisabled_->clear();
  }
  clear_has_frontcrossdisabled();
}
inline const ::std::string& CheckBoxOptions::frontcrossdisabled() const {
  return *frontcrossdisabled_;
}
inline void CheckBoxOptions::set_frontcrossdisabled(const ::std::string& value) {
  set_has_frontcrossdisabled();
  if (frontcrossdisabled_ == &::google::protobuf::internal::kEmptyString) {
    frontcrossdisabled_ = new ::std::string;
  }
  frontcrossdisabled_->assign(value);
}
inline void CheckBoxOptions::set_frontcrossdisabled(const char* value) {
  set_has_frontcrossdisabled();
  if (frontcrossdisabled_ == &::google::protobuf::internal::kEmptyString) {
    frontcrossdisabled_ = new ::std::string;
  }
  frontcrossdisabled_->assign(value);
}
inline void CheckBoxOptions::set_frontcrossdisabled(const char* value, size_t size) {
  set_has_frontcrossdisabled();
  if (frontcrossdisabled_ == &::google::protobuf::internal::kEmptyString) {
    frontcrossdisabled_ = new ::std::string;
  }
  frontcrossdisabled_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* CheckBoxOptions::mutable_frontcrossdisabled() {
  set_has_frontcrossdisabled();
  if (frontcrossdisabled_ == &::google::protobuf::internal::kEmptyString) {
    frontcrossdisabled_ = new ::std::string;
  }
  return frontcrossdisabled_;
}
inline ::std::string* CheckBoxOptions::release_frontcrossdisabled() {
  clear_has_frontcrossdisabled();
  if (frontcrossdisabled_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = frontcrossdisabled_;
    frontcrossdisabled_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void CheckBoxOptions::set_allocated_frontcrossdisabled(::std::string* frontcrossdisabled) {
  if (frontcrossdisabled_ != &::google::protobuf::internal::kEmptyString) {
    delete frontcrossdisabled_;
  }
  if (frontcrossdisabled) {
    set_has_frontcrossdisabled();
    frontcrossdisabled_ = frontcrossdisabled;
  } else {
    clear_has_frontcrossdisabled();
    frontcrossdisabled_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protocolbuffers.ResourceData backGroundBoxData = 8;
inline bool CheckBoxOptions::has_backgroundboxdata() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void CheckBoxOptions::set_has_backgroundboxdata() {
  _has_bits_[0] |= 0x00000080u;
}
inline void CheckBoxOptions::clear_has_backgroundboxdata() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void CheckBoxOptions::clear_backgroundboxdata() {
  if (backgroundboxdata_ != NULL) backgroundboxdata_->::protocolbuffers::ResourceData::Clear();
  clear_has_backgroundboxdata();
}
inline const ::protocolbuffers::ResourceData& CheckBoxOptions::backgroundboxdata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return backgroundboxdata_ != NULL ? *backgroundboxdata_ : *default_instance().backgroundboxdata_;
#else
  return backgroundboxdata_ != NULL ? *backgroundboxdata_ : *default_instance_->backgroundboxdata_;
#endif
}
inline ::protocolbuffers::ResourceData* CheckBoxOptions::mutable_backgroundboxdata() {
  set_has_backgroundboxdata();
  if (backgroundboxdata_ == NULL) backgroundboxdata_ = new ::protocolbuffers::ResourceData;
  return backgroundboxdata_;
}
inline ::protocolbuffers::ResourceData* CheckBoxOptions::release_backgroundboxdata() {
  clear_has_backgroundboxdata();
  ::protocolbuffers::ResourceData* temp = backgroundboxdata_;
  backgroundboxdata_ = NULL;
  return temp;
}
inline void CheckBoxOptions::set_allocated_backgroundboxdata(::protocolbuffers::ResourceData* backgroundboxdata) {
  delete backgroundboxdata_;
  backgroundboxdata_ = backgroundboxdata;
  if (backgroundboxdata) {
    set_has_backgroundboxdata();
  } else {
    clear_has_backgroundboxdata();
  }
}

// optional .protocolbuffers.ResourceData backGroundBoxSelectedData = 9;
inline bool CheckBoxOptions::has_backgroundboxselecteddata() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void CheckBoxOptions::set_has_backgroundboxselecteddata() {
  _has_bits_[0] |= 0x00000100u;
}
inline void CheckBoxOptions::clear_has_backgroundboxselecteddata() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void CheckBoxOptions::clear_backgroundboxselecteddata() {
  if (backgroundboxselecteddata_ != NULL) backgroundboxselecteddata_->::protocolbuffers::ResourceData::Clear();
  clear_has_backgroundboxselecteddata();
}
inline const ::protocolbuffers::ResourceData& CheckBoxOptions::backgroundboxselecteddata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return backgroundboxselecteddata_ != NULL ? *backgroundboxselecteddata_ : *default_instance().backgroundboxselecteddata_;
#else
  return backgroundboxselecteddata_ != NULL ? *backgroundboxselecteddata_ : *default_instance_->backgroundboxselecteddata_;
#endif
}
inline ::protocolbuffers::ResourceData* CheckBoxOptions::mutable_backgroundboxselecteddata() {
  set_has_backgroundboxselecteddata();
  if (backgroundboxselecteddata_ == NULL) backgroundboxselecteddata_ = new ::protocolbuffers::ResourceData;
  return backgroundboxselecteddata_;
}
inline ::protocolbuffers::ResourceData* CheckBoxOptions::release_backgroundboxselecteddata() {
  clear_has_backgroundboxselecteddata();
  ::protocolbuffers::ResourceData* temp = backgroundboxselecteddata_;
  backgroundboxselecteddata_ = NULL;
  return temp;
}
inline void CheckBoxOptions::set_allocated_backgroundboxselecteddata(::protocolbuffers::ResourceData* backgroundboxselecteddata) {
  delete backgroundboxselecteddata_;
  backgroundboxselecteddata_ = backgroundboxselecteddata;
  if (backgroundboxselecteddata) {
    set_has_backgroundboxselecteddata();
  } else {
    clear_has_backgroundboxselecteddata();
  }
}

// optional .protocolbuffers.ResourceData frontCrossData = 10;
inline bool CheckBoxOptions::has_frontcrossdata() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void CheckBoxOptions::set_has_frontcrossdata() {
  _has_bits_[0] |= 0x00000200u;
}
inline void CheckBoxOptions::clear_has_frontcrossdata() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void CheckBoxOptions::clear_frontcrossdata() {
  if (frontcrossdata_ != NULL) frontcrossdata_->::protocolbuffers::ResourceData::Clear();
  clear_has_frontcrossdata();
}
inline const ::protocolbuffers::ResourceData& CheckBoxOptions::frontcrossdata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return frontcrossdata_ != NULL ? *frontcrossdata_ : *default_instance().frontcrossdata_;
#else
  return frontcrossdata_ != NULL ? *frontcrossdata_ : *default_instance_->frontcrossdata_;
#endif
}
inline ::protocolbuffers::ResourceData* CheckBoxOptions::mutable_frontcrossdata() {
  set_has_frontcrossdata();
  if (frontcrossdata_ == NULL) frontcrossdata_ = new ::protocolbuffers::ResourceData;
  return frontcrossdata_;
}
inline ::protocolbuffers::ResourceData* CheckBoxOptions::release_frontcrossdata() {
  clear_has_frontcrossdata();
  ::protocolbuffers::ResourceData* temp = frontcrossdata_;
  frontcrossdata_ = NULL;
  return temp;
}
inline void CheckBoxOptions::set_allocated_frontcrossdata(::protocolbuffers::ResourceData* frontcrossdata) {
  delete frontcrossdata_;
  frontcrossdata_ = frontcrossdata;
  if (frontcrossdata) {
    set_has_frontcrossdata();
  } else {
    clear_has_frontcrossdata();
  }
}

// optional .protocolbuffers.ResourceData backGroundBoxDisabledData = 11;
inline bool CheckBoxOptions::has_backgroundboxdisableddata() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void CheckBoxOptions::set_has_backgroundboxdisableddata() {
  _has_bits_[0] |= 0x00000400u;
}
inline void CheckBoxOptions::clear_has_backgroundboxdisableddata() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void CheckBoxOptions::clear_backgroundboxdisableddata() {
  if (backgroundboxdisableddata_ != NULL) backgroundboxdisableddata_->::protocolbuffers::ResourceData::Clear();
  clear_has_backgroundboxdisableddata();
}
inline const ::protocolbuffers::ResourceData& CheckBoxOptions::backgroundboxdisableddata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return backgroundboxdisableddata_ != NULL ? *backgroundboxdisableddata_ : *default_instance().backgroundboxdisableddata_;
#else
  return backgroundboxdisableddata_ != NULL ? *backgroundboxdisableddata_ : *default_instance_->backgroundboxdisableddata_;
#endif
}
inline ::protocolbuffers::ResourceData* CheckBoxOptions::mutable_backgroundboxdisableddata() {
  set_has_backgroundboxdisableddata();
  if (backgroundboxdisableddata_ == NULL) backgroundboxdisableddata_ = new ::protocolbuffers::ResourceData;
  return backgroundboxdisableddata_;
}
inline ::protocolbuffers::ResourceData* CheckBoxOptions::release_backgroundboxdisableddata() {
  clear_has_backgroundboxdisableddata();
  ::protocolbuffers::ResourceData* temp = backgroundboxdisableddata_;
  backgroundboxdisableddata_ = NULL;
  return temp;
}
inline void CheckBoxOptions::set_allocated_backgroundboxdisableddata(::protocolbuffers::ResourceData* backgroundboxdisableddata) {
  delete backgroundboxdisableddata_;
  backgroundboxdisableddata_ = backgroundboxdisableddata;
  if (backgroundboxdisableddata) {
    set_has_backgroundboxdisableddata();
  } else {
    clear_has_backgroundboxdisableddata();
  }
}

// optional .protocolbuffers.ResourceData frontCrossDisabledData = 12;
inline bool CheckBoxOptions::has_frontcrossdisableddata() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void CheckBoxOptions::set_has_frontcrossdisableddata() {
  _has_bits_[0] |= 0x00000800u;
}
inline void CheckBoxOptions::clear_has_frontcrossdisableddata() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void CheckBoxOptions::clear_frontcrossdisableddata() {
  if (frontcrossdisableddata_ != NULL) frontcrossdisableddata_->::protocolbuffers::ResourceData::Clear();
  clear_has_frontcrossdisableddata();
}
inline const ::protocolbuffers::ResourceData& CheckBoxOptions::frontcrossdisableddata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return frontcrossdisableddata_ != NULL ? *frontcrossdisableddata_ : *default_instance().frontcrossdisableddata_;
#else
  return frontcrossdisableddata_ != NULL ? *frontcrossdisableddata_ : *default_instance_->frontcrossdisableddata_;
#endif
}
inline ::protocolbuffers::ResourceData* CheckBoxOptions::mutable_frontcrossdisableddata() {
  set_has_frontcrossdisableddata();
  if (frontcrossdisableddata_ == NULL) frontcrossdisableddata_ = new ::protocolbuffers::ResourceData;
  return frontcrossdisableddata_;
}
inline ::protocolbuffers::ResourceData* CheckBoxOptions::release_frontcrossdisableddata() {
  clear_has_frontcrossdisableddata();
  ::protocolbuffers::ResourceData* temp = frontcrossdisableddata_;
  frontcrossdisableddata_ = NULL;
  return temp;
}
inline void CheckBoxOptions::set_allocated_frontcrossdisableddata(::protocolbuffers::ResourceData* frontcrossdisableddata) {
  delete frontcrossdisableddata_;
  frontcrossdisableddata_ = frontcrossdisableddata;
  if (frontcrossdisableddata) {
    set_has_frontcrossdisableddata();
  } else {
    clear_has_frontcrossdisableddata();
  }
}

// optional bool selectedState = 13;
inline bool CheckBoxOptions::has_selectedstate() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void CheckBoxOptions::set_has_selectedstate() {
  _has_bits_[0] |= 0x00001000u;
}
inline void CheckBoxOptions::clear_has_selectedstate() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void CheckBoxOptions::clear_selectedstate() {
  selectedstate_ = false;
  clear_has_selectedstate();
}
inline bool CheckBoxOptions::selectedstate() const {
  return selectedstate_;
}
inline void CheckBoxOptions::set_selectedstate(bool value) {
  set_has_selectedstate();
  selectedstate_ = value;
}

// optional bool displaystate = 14;
inline bool CheckBoxOptions::has_displaystate() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void CheckBoxOptions::set_has_displaystate() {
  _has_bits_[0] |= 0x00002000u;
}
inline void CheckBoxOptions::clear_has_displaystate() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void CheckBoxOptions::clear_displaystate() {
  displaystate_ = false;
  clear_has_displaystate();
}
inline bool CheckBoxOptions::displaystate() const {
  return displaystate_;
}
inline void CheckBoxOptions::set_displaystate(bool value) {
  set_has_displaystate();
  displaystate_ = value;
}

// -------------------------------------------------------------------

// ImageViewOptions

// optional string name = 1;
inline bool ImageViewOptions::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ImageViewOptions::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ImageViewOptions::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ImageViewOptions::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ImageViewOptions::name() const {
  return *name_;
}
inline void ImageViewOptions::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ImageViewOptions::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ImageViewOptions::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImageViewOptions::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ImageViewOptions::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ImageViewOptions::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classname = 2;
inline bool ImageViewOptions::has_classname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ImageViewOptions::set_has_classname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ImageViewOptions::clear_has_classname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ImageViewOptions::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& ImageViewOptions::classname() const {
  return *classname_;
}
inline void ImageViewOptions::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void ImageViewOptions::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void ImageViewOptions::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImageViewOptions::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* ImageViewOptions::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ImageViewOptions::set_allocated_classname(::std::string* classname) {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (classname) {
    set_has_classname();
    classname_ = classname;
  } else {
    clear_has_classname();
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fileName = 3;
inline bool ImageViewOptions::has_filename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ImageViewOptions::set_has_filename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ImageViewOptions::clear_has_filename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ImageViewOptions::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& ImageViewOptions::filename() const {
  return *filename_;
}
inline void ImageViewOptions::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void ImageViewOptions::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void ImageViewOptions::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ImageViewOptions::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* ImageViewOptions::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ImageViewOptions::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protocolbuffers.ResourceData fileNameData = 4;
inline bool ImageViewOptions::has_filenamedata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ImageViewOptions::set_has_filenamedata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ImageViewOptions::clear_has_filenamedata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ImageViewOptions::clear_filenamedata() {
  if (filenamedata_ != NULL) filenamedata_->::protocolbuffers::ResourceData::Clear();
  clear_has_filenamedata();
}
inline const ::protocolbuffers::ResourceData& ImageViewOptions::filenamedata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return filenamedata_ != NULL ? *filenamedata_ : *default_instance().filenamedata_;
#else
  return filenamedata_ != NULL ? *filenamedata_ : *default_instance_->filenamedata_;
#endif
}
inline ::protocolbuffers::ResourceData* ImageViewOptions::mutable_filenamedata() {
  set_has_filenamedata();
  if (filenamedata_ == NULL) filenamedata_ = new ::protocolbuffers::ResourceData;
  return filenamedata_;
}
inline ::protocolbuffers::ResourceData* ImageViewOptions::release_filenamedata() {
  clear_has_filenamedata();
  ::protocolbuffers::ResourceData* temp = filenamedata_;
  filenamedata_ = NULL;
  return temp;
}
inline void ImageViewOptions::set_allocated_filenamedata(::protocolbuffers::ResourceData* filenamedata) {
  delete filenamedata_;
  filenamedata_ = filenamedata;
  if (filenamedata) {
    set_has_filenamedata();
  } else {
    clear_has_filenamedata();
  }
}

// optional float capInsetsX = 5;
inline bool ImageViewOptions::has_capinsetsx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ImageViewOptions::set_has_capinsetsx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ImageViewOptions::clear_has_capinsetsx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ImageViewOptions::clear_capinsetsx() {
  capinsetsx_ = 0;
  clear_has_capinsetsx();
}
inline float ImageViewOptions::capinsetsx() const {
  return capinsetsx_;
}
inline void ImageViewOptions::set_capinsetsx(float value) {
  set_has_capinsetsx();
  capinsetsx_ = value;
}

// optional float capInsetsY = 6;
inline bool ImageViewOptions::has_capinsetsy() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ImageViewOptions::set_has_capinsetsy() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ImageViewOptions::clear_has_capinsetsy() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ImageViewOptions::clear_capinsetsy() {
  capinsetsy_ = 0;
  clear_has_capinsetsy();
}
inline float ImageViewOptions::capinsetsy() const {
  return capinsetsy_;
}
inline void ImageViewOptions::set_capinsetsy(float value) {
  set_has_capinsetsy();
  capinsetsy_ = value;
}

// optional float capInsetsHeight = 7;
inline bool ImageViewOptions::has_capinsetsheight() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ImageViewOptions::set_has_capinsetsheight() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ImageViewOptions::clear_has_capinsetsheight() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ImageViewOptions::clear_capinsetsheight() {
  capinsetsheight_ = 0;
  clear_has_capinsetsheight();
}
inline float ImageViewOptions::capinsetsheight() const {
  return capinsetsheight_;
}
inline void ImageViewOptions::set_capinsetsheight(float value) {
  set_has_capinsetsheight();
  capinsetsheight_ = value;
}

// optional float capInsetsWidth = 8;
inline bool ImageViewOptions::has_capinsetswidth() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ImageViewOptions::set_has_capinsetswidth() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ImageViewOptions::clear_has_capinsetswidth() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ImageViewOptions::clear_capinsetswidth() {
  capinsetswidth_ = 0;
  clear_has_capinsetswidth();
}
inline float ImageViewOptions::capinsetswidth() const {
  return capinsetswidth_;
}
inline void ImageViewOptions::set_capinsetswidth(float value) {
  set_has_capinsetswidth();
  capinsetswidth_ = value;
}

// optional float scale9Width = 9;
inline bool ImageViewOptions::has_scale9width() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ImageViewOptions::set_has_scale9width() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ImageViewOptions::clear_has_scale9width() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ImageViewOptions::clear_scale9width() {
  scale9width_ = 0;
  clear_has_scale9width();
}
inline float ImageViewOptions::scale9width() const {
  return scale9width_;
}
inline void ImageViewOptions::set_scale9width(float value) {
  set_has_scale9width();
  scale9width_ = value;
}

// optional float scale9Height = 10;
inline bool ImageViewOptions::has_scale9height() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ImageViewOptions::set_has_scale9height() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ImageViewOptions::clear_has_scale9height() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ImageViewOptions::clear_scale9height() {
  scale9height_ = 0;
  clear_has_scale9height();
}
inline float ImageViewOptions::scale9height() const {
  return scale9height_;
}
inline void ImageViewOptions::set_scale9height(float value) {
  set_has_scale9height();
  scale9height_ = value;
}

// optional bool scale9Enable = 11;
inline bool ImageViewOptions::has_scale9enable() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ImageViewOptions::set_has_scale9enable() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ImageViewOptions::clear_has_scale9enable() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ImageViewOptions::clear_scale9enable() {
  scale9enable_ = false;
  clear_has_scale9enable();
}
inline bool ImageViewOptions::scale9enable() const {
  return scale9enable_;
}
inline void ImageViewOptions::set_scale9enable(bool value) {
  set_has_scale9enable();
  scale9enable_ = value;
}

// optional bool flippedX = 12;
inline bool ImageViewOptions::has_flippedx() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ImageViewOptions::set_has_flippedx() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ImageViewOptions::clear_has_flippedx() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ImageViewOptions::clear_flippedx() {
  flippedx_ = false;
  clear_has_flippedx();
}
inline bool ImageViewOptions::flippedx() const {
  return flippedx_;
}
inline void ImageViewOptions::set_flippedx(bool value) {
  set_has_flippedx();
  flippedx_ = value;
}

// optional bool flippedY = 13;
inline bool ImageViewOptions::has_flippedy() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ImageViewOptions::set_has_flippedy() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ImageViewOptions::clear_has_flippedy() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ImageViewOptions::clear_flippedy() {
  flippedy_ = false;
  clear_has_flippedy();
}
inline bool ImageViewOptions::flippedy() const {
  return flippedy_;
}
inline void ImageViewOptions::set_flippedy(bool value) {
  set_has_flippedy();
  flippedy_ = value;
}

// -------------------------------------------------------------------

// TextAtlasOptions

// optional string name = 1;
inline bool TextAtlasOptions::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextAtlasOptions::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TextAtlasOptions::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TextAtlasOptions::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TextAtlasOptions::name() const {
  return *name_;
}
inline void TextAtlasOptions::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TextAtlasOptions::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TextAtlasOptions::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextAtlasOptions::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TextAtlasOptions::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TextAtlasOptions::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classname = 2;
inline bool TextAtlasOptions::has_classname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TextAtlasOptions::set_has_classname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TextAtlasOptions::clear_has_classname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TextAtlasOptions::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& TextAtlasOptions::classname() const {
  return *classname_;
}
inline void TextAtlasOptions::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void TextAtlasOptions::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void TextAtlasOptions::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextAtlasOptions::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* TextAtlasOptions::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TextAtlasOptions::set_allocated_classname(::std::string* classname) {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (classname) {
    set_has_classname();
    classname_ = classname;
  } else {
    clear_has_classname();
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string stringValue = 3;
inline bool TextAtlasOptions::has_stringvalue() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TextAtlasOptions::set_has_stringvalue() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TextAtlasOptions::clear_has_stringvalue() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TextAtlasOptions::clear_stringvalue() {
  if (stringvalue_ != &::google::protobuf::internal::kEmptyString) {
    stringvalue_->clear();
  }
  clear_has_stringvalue();
}
inline const ::std::string& TextAtlasOptions::stringvalue() const {
  return *stringvalue_;
}
inline void TextAtlasOptions::set_stringvalue(const ::std::string& value) {
  set_has_stringvalue();
  if (stringvalue_ == &::google::protobuf::internal::kEmptyString) {
    stringvalue_ = new ::std::string;
  }
  stringvalue_->assign(value);
}
inline void TextAtlasOptions::set_stringvalue(const char* value) {
  set_has_stringvalue();
  if (stringvalue_ == &::google::protobuf::internal::kEmptyString) {
    stringvalue_ = new ::std::string;
  }
  stringvalue_->assign(value);
}
inline void TextAtlasOptions::set_stringvalue(const char* value, size_t size) {
  set_has_stringvalue();
  if (stringvalue_ == &::google::protobuf::internal::kEmptyString) {
    stringvalue_ = new ::std::string;
  }
  stringvalue_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextAtlasOptions::mutable_stringvalue() {
  set_has_stringvalue();
  if (stringvalue_ == &::google::protobuf::internal::kEmptyString) {
    stringvalue_ = new ::std::string;
  }
  return stringvalue_;
}
inline ::std::string* TextAtlasOptions::release_stringvalue() {
  clear_has_stringvalue();
  if (stringvalue_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = stringvalue_;
    stringvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TextAtlasOptions::set_allocated_stringvalue(::std::string* stringvalue) {
  if (stringvalue_ != &::google::protobuf::internal::kEmptyString) {
    delete stringvalue_;
  }
  if (stringvalue) {
    set_has_stringvalue();
    stringvalue_ = stringvalue;
  } else {
    clear_has_stringvalue();
    stringvalue_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string charMapFile = 4;
inline bool TextAtlasOptions::has_charmapfile() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TextAtlasOptions::set_has_charmapfile() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TextAtlasOptions::clear_has_charmapfile() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TextAtlasOptions::clear_charmapfile() {
  if (charmapfile_ != &::google::protobuf::internal::kEmptyString) {
    charmapfile_->clear();
  }
  clear_has_charmapfile();
}
inline const ::std::string& TextAtlasOptions::charmapfile() const {
  return *charmapfile_;
}
inline void TextAtlasOptions::set_charmapfile(const ::std::string& value) {
  set_has_charmapfile();
  if (charmapfile_ == &::google::protobuf::internal::kEmptyString) {
    charmapfile_ = new ::std::string;
  }
  charmapfile_->assign(value);
}
inline void TextAtlasOptions::set_charmapfile(const char* value) {
  set_has_charmapfile();
  if (charmapfile_ == &::google::protobuf::internal::kEmptyString) {
    charmapfile_ = new ::std::string;
  }
  charmapfile_->assign(value);
}
inline void TextAtlasOptions::set_charmapfile(const char* value, size_t size) {
  set_has_charmapfile();
  if (charmapfile_ == &::google::protobuf::internal::kEmptyString) {
    charmapfile_ = new ::std::string;
  }
  charmapfile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextAtlasOptions::mutable_charmapfile() {
  set_has_charmapfile();
  if (charmapfile_ == &::google::protobuf::internal::kEmptyString) {
    charmapfile_ = new ::std::string;
  }
  return charmapfile_;
}
inline ::std::string* TextAtlasOptions::release_charmapfile() {
  clear_has_charmapfile();
  if (charmapfile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = charmapfile_;
    charmapfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TextAtlasOptions::set_allocated_charmapfile(::std::string* charmapfile) {
  if (charmapfile_ != &::google::protobuf::internal::kEmptyString) {
    delete charmapfile_;
  }
  if (charmapfile) {
    set_has_charmapfile();
    charmapfile_ = charmapfile;
  } else {
    clear_has_charmapfile();
    charmapfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protocolbuffers.ResourceData charMapFileData = 5;
inline bool TextAtlasOptions::has_charmapfiledata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TextAtlasOptions::set_has_charmapfiledata() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TextAtlasOptions::clear_has_charmapfiledata() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TextAtlasOptions::clear_charmapfiledata() {
  if (charmapfiledata_ != NULL) charmapfiledata_->::protocolbuffers::ResourceData::Clear();
  clear_has_charmapfiledata();
}
inline const ::protocolbuffers::ResourceData& TextAtlasOptions::charmapfiledata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return charmapfiledata_ != NULL ? *charmapfiledata_ : *default_instance().charmapfiledata_;
#else
  return charmapfiledata_ != NULL ? *charmapfiledata_ : *default_instance_->charmapfiledata_;
#endif
}
inline ::protocolbuffers::ResourceData* TextAtlasOptions::mutable_charmapfiledata() {
  set_has_charmapfiledata();
  if (charmapfiledata_ == NULL) charmapfiledata_ = new ::protocolbuffers::ResourceData;
  return charmapfiledata_;
}
inline ::protocolbuffers::ResourceData* TextAtlasOptions::release_charmapfiledata() {
  clear_has_charmapfiledata();
  ::protocolbuffers::ResourceData* temp = charmapfiledata_;
  charmapfiledata_ = NULL;
  return temp;
}
inline void TextAtlasOptions::set_allocated_charmapfiledata(::protocolbuffers::ResourceData* charmapfiledata) {
  delete charmapfiledata_;
  charmapfiledata_ = charmapfiledata;
  if (charmapfiledata) {
    set_has_charmapfiledata();
  } else {
    clear_has_charmapfiledata();
  }
}

// optional string startCharMap = 6;
inline bool TextAtlasOptions::has_startcharmap() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TextAtlasOptions::set_has_startcharmap() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TextAtlasOptions::clear_has_startcharmap() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TextAtlasOptions::clear_startcharmap() {
  if (startcharmap_ != &::google::protobuf::internal::kEmptyString) {
    startcharmap_->clear();
  }
  clear_has_startcharmap();
}
inline const ::std::string& TextAtlasOptions::startcharmap() const {
  return *startcharmap_;
}
inline void TextAtlasOptions::set_startcharmap(const ::std::string& value) {
  set_has_startcharmap();
  if (startcharmap_ == &::google::protobuf::internal::kEmptyString) {
    startcharmap_ = new ::std::string;
  }
  startcharmap_->assign(value);
}
inline void TextAtlasOptions::set_startcharmap(const char* value) {
  set_has_startcharmap();
  if (startcharmap_ == &::google::protobuf::internal::kEmptyString) {
    startcharmap_ = new ::std::string;
  }
  startcharmap_->assign(value);
}
inline void TextAtlasOptions::set_startcharmap(const char* value, size_t size) {
  set_has_startcharmap();
  if (startcharmap_ == &::google::protobuf::internal::kEmptyString) {
    startcharmap_ = new ::std::string;
  }
  startcharmap_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextAtlasOptions::mutable_startcharmap() {
  set_has_startcharmap();
  if (startcharmap_ == &::google::protobuf::internal::kEmptyString) {
    startcharmap_ = new ::std::string;
  }
  return startcharmap_;
}
inline ::std::string* TextAtlasOptions::release_startcharmap() {
  clear_has_startcharmap();
  if (startcharmap_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = startcharmap_;
    startcharmap_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TextAtlasOptions::set_allocated_startcharmap(::std::string* startcharmap) {
  if (startcharmap_ != &::google::protobuf::internal::kEmptyString) {
    delete startcharmap_;
  }
  if (startcharmap) {
    set_has_startcharmap();
    startcharmap_ = startcharmap;
  } else {
    clear_has_startcharmap();
    startcharmap_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 itemWidth = 7;
inline bool TextAtlasOptions::has_itemwidth() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TextAtlasOptions::set_has_itemwidth() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TextAtlasOptions::clear_has_itemwidth() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TextAtlasOptions::clear_itemwidth() {
  itemwidth_ = 0;
  clear_has_itemwidth();
}
inline ::google::protobuf::int32 TextAtlasOptions::itemwidth() const {
  return itemwidth_;
}
inline void TextAtlasOptions::set_itemwidth(::google::protobuf::int32 value) {
  set_has_itemwidth();
  itemwidth_ = value;
}

// optional int32 itemHeight = 8;
inline bool TextAtlasOptions::has_itemheight() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TextAtlasOptions::set_has_itemheight() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TextAtlasOptions::clear_has_itemheight() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TextAtlasOptions::clear_itemheight() {
  itemheight_ = 0;
  clear_has_itemheight();
}
inline ::google::protobuf::int32 TextAtlasOptions::itemheight() const {
  return itemheight_;
}
inline void TextAtlasOptions::set_itemheight(::google::protobuf::int32 value) {
  set_has_itemheight();
  itemheight_ = value;
}

// -------------------------------------------------------------------

// TextBMFontOptions

// optional string name = 1;
inline bool TextBMFontOptions::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextBMFontOptions::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TextBMFontOptions::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TextBMFontOptions::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TextBMFontOptions::name() const {
  return *name_;
}
inline void TextBMFontOptions::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TextBMFontOptions::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TextBMFontOptions::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextBMFontOptions::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TextBMFontOptions::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TextBMFontOptions::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classname = 2;
inline bool TextBMFontOptions::has_classname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TextBMFontOptions::set_has_classname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TextBMFontOptions::clear_has_classname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TextBMFontOptions::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& TextBMFontOptions::classname() const {
  return *classname_;
}
inline void TextBMFontOptions::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void TextBMFontOptions::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void TextBMFontOptions::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextBMFontOptions::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* TextBMFontOptions::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TextBMFontOptions::set_allocated_classname(::std::string* classname) {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (classname) {
    set_has_classname();
    classname_ = classname;
  } else {
    clear_has_classname();
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string text = 3;
inline bool TextBMFontOptions::has_text() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TextBMFontOptions::set_has_text() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TextBMFontOptions::clear_has_text() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TextBMFontOptions::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& TextBMFontOptions::text() const {
  return *text_;
}
inline void TextBMFontOptions::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void TextBMFontOptions::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void TextBMFontOptions::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextBMFontOptions::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* TextBMFontOptions::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TextBMFontOptions::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protocolbuffers.ResourceData fileNameData = 4;
inline bool TextBMFontOptions::has_filenamedata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TextBMFontOptions::set_has_filenamedata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TextBMFontOptions::clear_has_filenamedata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TextBMFontOptions::clear_filenamedata() {
  if (filenamedata_ != NULL) filenamedata_->::protocolbuffers::ResourceData::Clear();
  clear_has_filenamedata();
}
inline const ::protocolbuffers::ResourceData& TextBMFontOptions::filenamedata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return filenamedata_ != NULL ? *filenamedata_ : *default_instance().filenamedata_;
#else
  return filenamedata_ != NULL ? *filenamedata_ : *default_instance_->filenamedata_;
#endif
}
inline ::protocolbuffers::ResourceData* TextBMFontOptions::mutable_filenamedata() {
  set_has_filenamedata();
  if (filenamedata_ == NULL) filenamedata_ = new ::protocolbuffers::ResourceData;
  return filenamedata_;
}
inline ::protocolbuffers::ResourceData* TextBMFontOptions::release_filenamedata() {
  clear_has_filenamedata();
  ::protocolbuffers::ResourceData* temp = filenamedata_;
  filenamedata_ = NULL;
  return temp;
}
inline void TextBMFontOptions::set_allocated_filenamedata(::protocolbuffers::ResourceData* filenamedata) {
  delete filenamedata_;
  filenamedata_ = filenamedata;
  if (filenamedata) {
    set_has_filenamedata();
  } else {
    clear_has_filenamedata();
  }
}

// -------------------------------------------------------------------

// TextOptions

// optional string name = 1;
inline bool TextOptions::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextOptions::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TextOptions::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TextOptions::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TextOptions::name() const {
  return *name_;
}
inline void TextOptions::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TextOptions::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TextOptions::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextOptions::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TextOptions::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TextOptions::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classname = 2;
inline bool TextOptions::has_classname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TextOptions::set_has_classname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TextOptions::clear_has_classname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TextOptions::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& TextOptions::classname() const {
  return *classname_;
}
inline void TextOptions::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void TextOptions::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void TextOptions::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextOptions::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* TextOptions::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TextOptions::set_allocated_classname(::std::string* classname) {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (classname) {
    set_has_classname();
    classname_ = classname;
  } else {
    clear_has_classname();
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fontName = 3;
inline bool TextOptions::has_fontname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TextOptions::set_has_fontname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TextOptions::clear_has_fontname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TextOptions::clear_fontname() {
  if (fontname_ != &::google::protobuf::internal::kEmptyString) {
    fontname_->clear();
  }
  clear_has_fontname();
}
inline const ::std::string& TextOptions::fontname() const {
  return *fontname_;
}
inline void TextOptions::set_fontname(const ::std::string& value) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(value);
}
inline void TextOptions::set_fontname(const char* value) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(value);
}
inline void TextOptions::set_fontname(const char* value, size_t size) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextOptions::mutable_fontname() {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    fontname_ = new ::std::string;
  }
  return fontname_;
}
inline ::std::string* TextOptions::release_fontname() {
  clear_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fontname_;
    fontname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TextOptions::set_allocated_fontname(::std::string* fontname) {
  if (fontname_ != &::google::protobuf::internal::kEmptyString) {
    delete fontname_;
  }
  if (fontname) {
    set_has_fontname();
    fontname_ = fontname;
  } else {
    clear_has_fontname();
    fontname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protocolbuffers.ResourceData fontFile = 4;
inline bool TextOptions::has_fontfile() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TextOptions::set_has_fontfile() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TextOptions::clear_has_fontfile() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TextOptions::clear_fontfile() {
  if (fontfile_ != NULL) fontfile_->::protocolbuffers::ResourceData::Clear();
  clear_has_fontfile();
}
inline const ::protocolbuffers::ResourceData& TextOptions::fontfile() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fontfile_ != NULL ? *fontfile_ : *default_instance().fontfile_;
#else
  return fontfile_ != NULL ? *fontfile_ : *default_instance_->fontfile_;
#endif
}
inline ::protocolbuffers::ResourceData* TextOptions::mutable_fontfile() {
  set_has_fontfile();
  if (fontfile_ == NULL) fontfile_ = new ::protocolbuffers::ResourceData;
  return fontfile_;
}
inline ::protocolbuffers::ResourceData* TextOptions::release_fontfile() {
  clear_has_fontfile();
  ::protocolbuffers::ResourceData* temp = fontfile_;
  fontfile_ = NULL;
  return temp;
}
inline void TextOptions::set_allocated_fontfile(::protocolbuffers::ResourceData* fontfile) {
  delete fontfile_;
  fontfile_ = fontfile;
  if (fontfile) {
    set_has_fontfile();
  } else {
    clear_has_fontfile();
  }
}

// optional int32 fontSize = 5;
inline bool TextOptions::has_fontsize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TextOptions::set_has_fontsize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TextOptions::clear_has_fontsize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TextOptions::clear_fontsize() {
  fontsize_ = 0;
  clear_has_fontsize();
}
inline ::google::protobuf::int32 TextOptions::fontsize() const {
  return fontsize_;
}
inline void TextOptions::set_fontsize(::google::protobuf::int32 value) {
  set_has_fontsize();
  fontsize_ = value;
}

// optional string text = 6;
inline bool TextOptions::has_text() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TextOptions::set_has_text() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TextOptions::clear_has_text() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TextOptions::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& TextOptions::text() const {
  return *text_;
}
inline void TextOptions::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void TextOptions::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void TextOptions::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextOptions::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* TextOptions::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TextOptions::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional float areaWidth = 7;
inline bool TextOptions::has_areawidth() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TextOptions::set_has_areawidth() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TextOptions::clear_has_areawidth() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TextOptions::clear_areawidth() {
  areawidth_ = 0;
  clear_has_areawidth();
}
inline float TextOptions::areawidth() const {
  return areawidth_;
}
inline void TextOptions::set_areawidth(float value) {
  set_has_areawidth();
  areawidth_ = value;
}

// optional float areaHeight = 8;
inline bool TextOptions::has_areaheight() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TextOptions::set_has_areaheight() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TextOptions::clear_has_areaheight() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TextOptions::clear_areaheight() {
  areaheight_ = 0;
  clear_has_areaheight();
}
inline float TextOptions::areaheight() const {
  return areaheight_;
}
inline void TextOptions::set_areaheight(float value) {
  set_has_areaheight();
  areaheight_ = value;
}

// optional int32 hAlignment = 9;
inline bool TextOptions::has_halignment() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TextOptions::set_has_halignment() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TextOptions::clear_has_halignment() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TextOptions::clear_halignment() {
  halignment_ = 0;
  clear_has_halignment();
}
inline ::google::protobuf::int32 TextOptions::halignment() const {
  return halignment_;
}
inline void TextOptions::set_halignment(::google::protobuf::int32 value) {
  set_has_halignment();
  halignment_ = value;
}

// optional int32 vAlignment = 10;
inline bool TextOptions::has_valignment() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TextOptions::set_has_valignment() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TextOptions::clear_has_valignment() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TextOptions::clear_valignment() {
  valignment_ = 0;
  clear_has_valignment();
}
inline ::google::protobuf::int32 TextOptions::valignment() const {
  return valignment_;
}
inline void TextOptions::set_valignment(::google::protobuf::int32 value) {
  set_has_valignment();
  valignment_ = value;
}

// optional bool touchScaleEnable = 11;
inline bool TextOptions::has_touchscaleenable() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TextOptions::set_has_touchscaleenable() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TextOptions::clear_has_touchscaleenable() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TextOptions::clear_touchscaleenable() {
  touchscaleenable_ = false;
  clear_has_touchscaleenable();
}
inline bool TextOptions::touchscaleenable() const {
  return touchscaleenable_;
}
inline void TextOptions::set_touchscaleenable(bool value) {
  set_has_touchscaleenable();
  touchscaleenable_ = value;
}

// optional .protocolbuffers.ResourceData fontResource = 12;
inline bool TextOptions::has_fontresource() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TextOptions::set_has_fontresource() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TextOptions::clear_has_fontresource() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TextOptions::clear_fontresource() {
  if (fontresource_ != NULL) fontresource_->::protocolbuffers::ResourceData::Clear();
  clear_has_fontresource();
}
inline const ::protocolbuffers::ResourceData& TextOptions::fontresource() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fontresource_ != NULL ? *fontresource_ : *default_instance().fontresource_;
#else
  return fontresource_ != NULL ? *fontresource_ : *default_instance_->fontresource_;
#endif
}
inline ::protocolbuffers::ResourceData* TextOptions::mutable_fontresource() {
  set_has_fontresource();
  if (fontresource_ == NULL) fontresource_ = new ::protocolbuffers::ResourceData;
  return fontresource_;
}
inline ::protocolbuffers::ResourceData* TextOptions::release_fontresource() {
  clear_has_fontresource();
  ::protocolbuffers::ResourceData* temp = fontresource_;
  fontresource_ = NULL;
  return temp;
}
inline void TextOptions::set_allocated_fontresource(::protocolbuffers::ResourceData* fontresource) {
  delete fontresource_;
  fontresource_ = fontresource;
  if (fontresource) {
    set_has_fontresource();
  } else {
    clear_has_fontresource();
  }
}

// optional bool IsCustomSize = 13;
inline bool TextOptions::has_iscustomsize() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TextOptions::set_has_iscustomsize() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TextOptions::clear_has_iscustomsize() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TextOptions::clear_iscustomsize() {
  iscustomsize_ = false;
  clear_has_iscustomsize();
}
inline bool TextOptions::iscustomsize() const {
  return iscustomsize_;
}
inline void TextOptions::set_iscustomsize(bool value) {
  set_has_iscustomsize();
  iscustomsize_ = value;
}

// -------------------------------------------------------------------

// LoadingBarOptions

// optional string name = 1;
inline bool LoadingBarOptions::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LoadingBarOptions::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void LoadingBarOptions::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void LoadingBarOptions::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& LoadingBarOptions::name() const {
  return *name_;
}
inline void LoadingBarOptions::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LoadingBarOptions::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void LoadingBarOptions::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadingBarOptions::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* LoadingBarOptions::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadingBarOptions::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classname = 2;
inline bool LoadingBarOptions::has_classname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void LoadingBarOptions::set_has_classname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void LoadingBarOptions::clear_has_classname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void LoadingBarOptions::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& LoadingBarOptions::classname() const {
  return *classname_;
}
inline void LoadingBarOptions::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void LoadingBarOptions::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void LoadingBarOptions::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadingBarOptions::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* LoadingBarOptions::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadingBarOptions::set_allocated_classname(::std::string* classname) {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (classname) {
    set_has_classname();
    classname_ = classname;
  } else {
    clear_has_classname();
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string texture = 3;
inline bool LoadingBarOptions::has_texture() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void LoadingBarOptions::set_has_texture() {
  _has_bits_[0] |= 0x00000004u;
}
inline void LoadingBarOptions::clear_has_texture() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void LoadingBarOptions::clear_texture() {
  if (texture_ != &::google::protobuf::internal::kEmptyString) {
    texture_->clear();
  }
  clear_has_texture();
}
inline const ::std::string& LoadingBarOptions::texture() const {
  return *texture_;
}
inline void LoadingBarOptions::set_texture(const ::std::string& value) {
  set_has_texture();
  if (texture_ == &::google::protobuf::internal::kEmptyString) {
    texture_ = new ::std::string;
  }
  texture_->assign(value);
}
inline void LoadingBarOptions::set_texture(const char* value) {
  set_has_texture();
  if (texture_ == &::google::protobuf::internal::kEmptyString) {
    texture_ = new ::std::string;
  }
  texture_->assign(value);
}
inline void LoadingBarOptions::set_texture(const char* value, size_t size) {
  set_has_texture();
  if (texture_ == &::google::protobuf::internal::kEmptyString) {
    texture_ = new ::std::string;
  }
  texture_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* LoadingBarOptions::mutable_texture() {
  set_has_texture();
  if (texture_ == &::google::protobuf::internal::kEmptyString) {
    texture_ = new ::std::string;
  }
  return texture_;
}
inline ::std::string* LoadingBarOptions::release_texture() {
  clear_has_texture();
  if (texture_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = texture_;
    texture_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void LoadingBarOptions::set_allocated_texture(::std::string* texture) {
  if (texture_ != &::google::protobuf::internal::kEmptyString) {
    delete texture_;
  }
  if (texture) {
    set_has_texture();
    texture_ = texture;
  } else {
    clear_has_texture();
    texture_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protocolbuffers.ResourceData textureData = 4;
inline bool LoadingBarOptions::has_texturedata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void LoadingBarOptions::set_has_texturedata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void LoadingBarOptions::clear_has_texturedata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void LoadingBarOptions::clear_texturedata() {
  if (texturedata_ != NULL) texturedata_->::protocolbuffers::ResourceData::Clear();
  clear_has_texturedata();
}
inline const ::protocolbuffers::ResourceData& LoadingBarOptions::texturedata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return texturedata_ != NULL ? *texturedata_ : *default_instance().texturedata_;
#else
  return texturedata_ != NULL ? *texturedata_ : *default_instance_->texturedata_;
#endif
}
inline ::protocolbuffers::ResourceData* LoadingBarOptions::mutable_texturedata() {
  set_has_texturedata();
  if (texturedata_ == NULL) texturedata_ = new ::protocolbuffers::ResourceData;
  return texturedata_;
}
inline ::protocolbuffers::ResourceData* LoadingBarOptions::release_texturedata() {
  clear_has_texturedata();
  ::protocolbuffers::ResourceData* temp = texturedata_;
  texturedata_ = NULL;
  return temp;
}
inline void LoadingBarOptions::set_allocated_texturedata(::protocolbuffers::ResourceData* texturedata) {
  delete texturedata_;
  texturedata_ = texturedata;
  if (texturedata) {
    set_has_texturedata();
  } else {
    clear_has_texturedata();
  }
}

// optional int32 percent = 5;
inline bool LoadingBarOptions::has_percent() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void LoadingBarOptions::set_has_percent() {
  _has_bits_[0] |= 0x00000010u;
}
inline void LoadingBarOptions::clear_has_percent() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void LoadingBarOptions::clear_percent() {
  percent_ = 0;
  clear_has_percent();
}
inline ::google::protobuf::int32 LoadingBarOptions::percent() const {
  return percent_;
}
inline void LoadingBarOptions::set_percent(::google::protobuf::int32 value) {
  set_has_percent();
  percent_ = value;
}

// optional int32 direction = 6;
inline bool LoadingBarOptions::has_direction() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void LoadingBarOptions::set_has_direction() {
  _has_bits_[0] |= 0x00000020u;
}
inline void LoadingBarOptions::clear_has_direction() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void LoadingBarOptions::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::google::protobuf::int32 LoadingBarOptions::direction() const {
  return direction_;
}
inline void LoadingBarOptions::set_direction(::google::protobuf::int32 value) {
  set_has_direction();
  direction_ = value;
}

// optional float capInsetsX = 7;
inline bool LoadingBarOptions::has_capinsetsx() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void LoadingBarOptions::set_has_capinsetsx() {
  _has_bits_[0] |= 0x00000040u;
}
inline void LoadingBarOptions::clear_has_capinsetsx() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void LoadingBarOptions::clear_capinsetsx() {
  capinsetsx_ = 0;
  clear_has_capinsetsx();
}
inline float LoadingBarOptions::capinsetsx() const {
  return capinsetsx_;
}
inline void LoadingBarOptions::set_capinsetsx(float value) {
  set_has_capinsetsx();
  capinsetsx_ = value;
}

// optional float capInsetsY = 8;
inline bool LoadingBarOptions::has_capinsetsy() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void LoadingBarOptions::set_has_capinsetsy() {
  _has_bits_[0] |= 0x00000080u;
}
inline void LoadingBarOptions::clear_has_capinsetsy() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void LoadingBarOptions::clear_capinsetsy() {
  capinsetsy_ = 0;
  clear_has_capinsetsy();
}
inline float LoadingBarOptions::capinsetsy() const {
  return capinsetsy_;
}
inline void LoadingBarOptions::set_capinsetsy(float value) {
  set_has_capinsetsy();
  capinsetsy_ = value;
}

// optional float capInsetsWidth = 9;
inline bool LoadingBarOptions::has_capinsetswidth() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void LoadingBarOptions::set_has_capinsetswidth() {
  _has_bits_[0] |= 0x00000100u;
}
inline void LoadingBarOptions::clear_has_capinsetswidth() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void LoadingBarOptions::clear_capinsetswidth() {
  capinsetswidth_ = 0;
  clear_has_capinsetswidth();
}
inline float LoadingBarOptions::capinsetswidth() const {
  return capinsetswidth_;
}
inline void LoadingBarOptions::set_capinsetswidth(float value) {
  set_has_capinsetswidth();
  capinsetswidth_ = value;
}

// optional float capInsetsHeight = 10;
inline bool LoadingBarOptions::has_capinsetsheight() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void LoadingBarOptions::set_has_capinsetsheight() {
  _has_bits_[0] |= 0x00000200u;
}
inline void LoadingBarOptions::clear_has_capinsetsheight() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void LoadingBarOptions::clear_capinsetsheight() {
  capinsetsheight_ = 0;
  clear_has_capinsetsheight();
}
inline float LoadingBarOptions::capinsetsheight() const {
  return capinsetsheight_;
}
inline void LoadingBarOptions::set_capinsetsheight(float value) {
  set_has_capinsetsheight();
  capinsetsheight_ = value;
}

// optional bool scale9Enable = 11;
inline bool LoadingBarOptions::has_scale9enable() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void LoadingBarOptions::set_has_scale9enable() {
  _has_bits_[0] |= 0x00000400u;
}
inline void LoadingBarOptions::clear_has_scale9enable() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void LoadingBarOptions::clear_scale9enable() {
  scale9enable_ = false;
  clear_has_scale9enable();
}
inline bool LoadingBarOptions::scale9enable() const {
  return scale9enable_;
}
inline void LoadingBarOptions::set_scale9enable(bool value) {
  set_has_scale9enable();
  scale9enable_ = value;
}

// optional float scale9Width = 12;
inline bool LoadingBarOptions::has_scale9width() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void LoadingBarOptions::set_has_scale9width() {
  _has_bits_[0] |= 0x00000800u;
}
inline void LoadingBarOptions::clear_has_scale9width() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void LoadingBarOptions::clear_scale9width() {
  scale9width_ = 0;
  clear_has_scale9width();
}
inline float LoadingBarOptions::scale9width() const {
  return scale9width_;
}
inline void LoadingBarOptions::set_scale9width(float value) {
  set_has_scale9width();
  scale9width_ = value;
}

// optional float scale9Height = 13;
inline bool LoadingBarOptions::has_scale9height() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void LoadingBarOptions::set_has_scale9height() {
  _has_bits_[0] |= 0x00001000u;
}
inline void LoadingBarOptions::clear_has_scale9height() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void LoadingBarOptions::clear_scale9height() {
  scale9height_ = 0;
  clear_has_scale9height();
}
inline float LoadingBarOptions::scale9height() const {
  return scale9height_;
}
inline void LoadingBarOptions::set_scale9height(float value) {
  set_has_scale9height();
  scale9height_ = value;
}

// -------------------------------------------------------------------

// ListViewOptions

// optional string name = 1;
inline bool ListViewOptions::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ListViewOptions::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ListViewOptions::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ListViewOptions::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ListViewOptions::name() const {
  return *name_;
}
inline void ListViewOptions::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ListViewOptions::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ListViewOptions::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListViewOptions::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ListViewOptions::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ListViewOptions::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classname = 2;
inline bool ListViewOptions::has_classname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ListViewOptions::set_has_classname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ListViewOptions::clear_has_classname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ListViewOptions::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& ListViewOptions::classname() const {
  return *classname_;
}
inline void ListViewOptions::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void ListViewOptions::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void ListViewOptions::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListViewOptions::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* ListViewOptions::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ListViewOptions::set_allocated_classname(::std::string* classname) {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (classname) {
    set_has_classname();
    classname_ = classname;
  } else {
    clear_has_classname();
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string backGroundImage = 3;
inline bool ListViewOptions::has_backgroundimage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ListViewOptions::set_has_backgroundimage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ListViewOptions::clear_has_backgroundimage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ListViewOptions::clear_backgroundimage() {
  if (backgroundimage_ != &::google::protobuf::internal::kEmptyString) {
    backgroundimage_->clear();
  }
  clear_has_backgroundimage();
}
inline const ::std::string& ListViewOptions::backgroundimage() const {
  return *backgroundimage_;
}
inline void ListViewOptions::set_backgroundimage(const ::std::string& value) {
  set_has_backgroundimage();
  if (backgroundimage_ == &::google::protobuf::internal::kEmptyString) {
    backgroundimage_ = new ::std::string;
  }
  backgroundimage_->assign(value);
}
inline void ListViewOptions::set_backgroundimage(const char* value) {
  set_has_backgroundimage();
  if (backgroundimage_ == &::google::protobuf::internal::kEmptyString) {
    backgroundimage_ = new ::std::string;
  }
  backgroundimage_->assign(value);
}
inline void ListViewOptions::set_backgroundimage(const char* value, size_t size) {
  set_has_backgroundimage();
  if (backgroundimage_ == &::google::protobuf::internal::kEmptyString) {
    backgroundimage_ = new ::std::string;
  }
  backgroundimage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ListViewOptions::mutable_backgroundimage() {
  set_has_backgroundimage();
  if (backgroundimage_ == &::google::protobuf::internal::kEmptyString) {
    backgroundimage_ = new ::std::string;
  }
  return backgroundimage_;
}
inline ::std::string* ListViewOptions::release_backgroundimage() {
  clear_has_backgroundimage();
  if (backgroundimage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = backgroundimage_;
    backgroundimage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ListViewOptions::set_allocated_backgroundimage(::std::string* backgroundimage) {
  if (backgroundimage_ != &::google::protobuf::internal::kEmptyString) {
    delete backgroundimage_;
  }
  if (backgroundimage) {
    set_has_backgroundimage();
    backgroundimage_ = backgroundimage;
  } else {
    clear_has_backgroundimage();
    backgroundimage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protocolbuffers.ResourceData backGroundImageData = 4;
inline bool ListViewOptions::has_backgroundimagedata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ListViewOptions::set_has_backgroundimagedata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ListViewOptions::clear_has_backgroundimagedata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ListViewOptions::clear_backgroundimagedata() {
  if (backgroundimagedata_ != NULL) backgroundimagedata_->::protocolbuffers::ResourceData::Clear();
  clear_has_backgroundimagedata();
}
inline const ::protocolbuffers::ResourceData& ListViewOptions::backgroundimagedata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return backgroundimagedata_ != NULL ? *backgroundimagedata_ : *default_instance().backgroundimagedata_;
#else
  return backgroundimagedata_ != NULL ? *backgroundimagedata_ : *default_instance_->backgroundimagedata_;
#endif
}
inline ::protocolbuffers::ResourceData* ListViewOptions::mutable_backgroundimagedata() {
  set_has_backgroundimagedata();
  if (backgroundimagedata_ == NULL) backgroundimagedata_ = new ::protocolbuffers::ResourceData;
  return backgroundimagedata_;
}
inline ::protocolbuffers::ResourceData* ListViewOptions::release_backgroundimagedata() {
  clear_has_backgroundimagedata();
  ::protocolbuffers::ResourceData* temp = backgroundimagedata_;
  backgroundimagedata_ = NULL;
  return temp;
}
inline void ListViewOptions::set_allocated_backgroundimagedata(::protocolbuffers::ResourceData* backgroundimagedata) {
  delete backgroundimagedata_;
  backgroundimagedata_ = backgroundimagedata;
  if (backgroundimagedata) {
    set_has_backgroundimagedata();
  } else {
    clear_has_backgroundimagedata();
  }
}

// optional int32 bgColorR = 5;
inline bool ListViewOptions::has_bgcolorr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ListViewOptions::set_has_bgcolorr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ListViewOptions::clear_has_bgcolorr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ListViewOptions::clear_bgcolorr() {
  bgcolorr_ = 0;
  clear_has_bgcolorr();
}
inline ::google::protobuf::int32 ListViewOptions::bgcolorr() const {
  return bgcolorr_;
}
inline void ListViewOptions::set_bgcolorr(::google::protobuf::int32 value) {
  set_has_bgcolorr();
  bgcolorr_ = value;
}

// optional int32 bgColorG = 6;
inline bool ListViewOptions::has_bgcolorg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ListViewOptions::set_has_bgcolorg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ListViewOptions::clear_has_bgcolorg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ListViewOptions::clear_bgcolorg() {
  bgcolorg_ = 0;
  clear_has_bgcolorg();
}
inline ::google::protobuf::int32 ListViewOptions::bgcolorg() const {
  return bgcolorg_;
}
inline void ListViewOptions::set_bgcolorg(::google::protobuf::int32 value) {
  set_has_bgcolorg();
  bgcolorg_ = value;
}

// optional int32 bgColorB = 7;
inline bool ListViewOptions::has_bgcolorb() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ListViewOptions::set_has_bgcolorb() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ListViewOptions::clear_has_bgcolorb() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ListViewOptions::clear_bgcolorb() {
  bgcolorb_ = 0;
  clear_has_bgcolorb();
}
inline ::google::protobuf::int32 ListViewOptions::bgcolorb() const {
  return bgcolorb_;
}
inline void ListViewOptions::set_bgcolorb(::google::protobuf::int32 value) {
  set_has_bgcolorb();
  bgcolorb_ = value;
}

// optional int32 bgStartColorR = 8;
inline bool ListViewOptions::has_bgstartcolorr() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ListViewOptions::set_has_bgstartcolorr() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ListViewOptions::clear_has_bgstartcolorr() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ListViewOptions::clear_bgstartcolorr() {
  bgstartcolorr_ = 0;
  clear_has_bgstartcolorr();
}
inline ::google::protobuf::int32 ListViewOptions::bgstartcolorr() const {
  return bgstartcolorr_;
}
inline void ListViewOptions::set_bgstartcolorr(::google::protobuf::int32 value) {
  set_has_bgstartcolorr();
  bgstartcolorr_ = value;
}

// optional int32 bgStartColorG = 9;
inline bool ListViewOptions::has_bgstartcolorg() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ListViewOptions::set_has_bgstartcolorg() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ListViewOptions::clear_has_bgstartcolorg() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ListViewOptions::clear_bgstartcolorg() {
  bgstartcolorg_ = 0;
  clear_has_bgstartcolorg();
}
inline ::google::protobuf::int32 ListViewOptions::bgstartcolorg() const {
  return bgstartcolorg_;
}
inline void ListViewOptions::set_bgstartcolorg(::google::protobuf::int32 value) {
  set_has_bgstartcolorg();
  bgstartcolorg_ = value;
}

// optional int32 bgStartColorB = 10;
inline bool ListViewOptions::has_bgstartcolorb() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ListViewOptions::set_has_bgstartcolorb() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ListViewOptions::clear_has_bgstartcolorb() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ListViewOptions::clear_bgstartcolorb() {
  bgstartcolorb_ = 0;
  clear_has_bgstartcolorb();
}
inline ::google::protobuf::int32 ListViewOptions::bgstartcolorb() const {
  return bgstartcolorb_;
}
inline void ListViewOptions::set_bgstartcolorb(::google::protobuf::int32 value) {
  set_has_bgstartcolorb();
  bgstartcolorb_ = value;
}

// optional int32 bgEndColorR = 11;
inline bool ListViewOptions::has_bgendcolorr() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ListViewOptions::set_has_bgendcolorr() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ListViewOptions::clear_has_bgendcolorr() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ListViewOptions::clear_bgendcolorr() {
  bgendcolorr_ = 0;
  clear_has_bgendcolorr();
}
inline ::google::protobuf::int32 ListViewOptions::bgendcolorr() const {
  return bgendcolorr_;
}
inline void ListViewOptions::set_bgendcolorr(::google::protobuf::int32 value) {
  set_has_bgendcolorr();
  bgendcolorr_ = value;
}

// optional int32 bgEndColorG = 12;
inline bool ListViewOptions::has_bgendcolorg() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ListViewOptions::set_has_bgendcolorg() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ListViewOptions::clear_has_bgendcolorg() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ListViewOptions::clear_bgendcolorg() {
  bgendcolorg_ = 0;
  clear_has_bgendcolorg();
}
inline ::google::protobuf::int32 ListViewOptions::bgendcolorg() const {
  return bgendcolorg_;
}
inline void ListViewOptions::set_bgendcolorg(::google::protobuf::int32 value) {
  set_has_bgendcolorg();
  bgendcolorg_ = value;
}

// optional int32 bgEndColorB = 13;
inline bool ListViewOptions::has_bgendcolorb() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ListViewOptions::set_has_bgendcolorb() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ListViewOptions::clear_has_bgendcolorb() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ListViewOptions::clear_bgendcolorb() {
  bgendcolorb_ = 0;
  clear_has_bgendcolorb();
}
inline ::google::protobuf::int32 ListViewOptions::bgendcolorb() const {
  return bgendcolorb_;
}
inline void ListViewOptions::set_bgendcolorb(::google::protobuf::int32 value) {
  set_has_bgendcolorb();
  bgendcolorb_ = value;
}

// optional int32 colorType = 14;
inline bool ListViewOptions::has_colortype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ListViewOptions::set_has_colortype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ListViewOptions::clear_has_colortype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ListViewOptions::clear_colortype() {
  colortype_ = 0;
  clear_has_colortype();
}
inline ::google::protobuf::int32 ListViewOptions::colortype() const {
  return colortype_;
}
inline void ListViewOptions::set_colortype(::google::protobuf::int32 value) {
  set_has_colortype();
  colortype_ = value;
}

// optional int32 bgColorOpacity = 15;
inline bool ListViewOptions::has_bgcoloropacity() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ListViewOptions::set_has_bgcoloropacity() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ListViewOptions::clear_has_bgcoloropacity() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ListViewOptions::clear_bgcoloropacity() {
  bgcoloropacity_ = 0;
  clear_has_bgcoloropacity();
}
inline ::google::protobuf::int32 ListViewOptions::bgcoloropacity() const {
  return bgcoloropacity_;
}
inline void ListViewOptions::set_bgcoloropacity(::google::protobuf::int32 value) {
  set_has_bgcoloropacity();
  bgcoloropacity_ = value;
}

// optional float vectorX = 16;
inline bool ListViewOptions::has_vectorx() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ListViewOptions::set_has_vectorx() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ListViewOptions::clear_has_vectorx() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ListViewOptions::clear_vectorx() {
  vectorx_ = 0;
  clear_has_vectorx();
}
inline float ListViewOptions::vectorx() const {
  return vectorx_;
}
inline void ListViewOptions::set_vectorx(float value) {
  set_has_vectorx();
  vectorx_ = value;
}

// optional float vectorY = 17;
inline bool ListViewOptions::has_vectory() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ListViewOptions::set_has_vectory() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ListViewOptions::clear_has_vectory() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ListViewOptions::clear_vectory() {
  vectory_ = 0;
  clear_has_vectory();
}
inline float ListViewOptions::vectory() const {
  return vectory_;
}
inline void ListViewOptions::set_vectory(float value) {
  set_has_vectory();
  vectory_ = value;
}

// optional float capInsetsX = 18;
inline bool ListViewOptions::has_capinsetsx() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ListViewOptions::set_has_capinsetsx() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ListViewOptions::clear_has_capinsetsx() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ListViewOptions::clear_capinsetsx() {
  capinsetsx_ = 0;
  clear_has_capinsetsx();
}
inline float ListViewOptions::capinsetsx() const {
  return capinsetsx_;
}
inline void ListViewOptions::set_capinsetsx(float value) {
  set_has_capinsetsx();
  capinsetsx_ = value;
}

// optional float capInsetsY = 19;
inline bool ListViewOptions::has_capinsetsy() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ListViewOptions::set_has_capinsetsy() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ListViewOptions::clear_has_capinsetsy() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ListViewOptions::clear_capinsetsy() {
  capinsetsy_ = 0;
  clear_has_capinsetsy();
}
inline float ListViewOptions::capinsetsy() const {
  return capinsetsy_;
}
inline void ListViewOptions::set_capinsetsy(float value) {
  set_has_capinsetsy();
  capinsetsy_ = value;
}

// optional float capInsetsWidth = 20;
inline bool ListViewOptions::has_capinsetswidth() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ListViewOptions::set_has_capinsetswidth() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ListViewOptions::clear_has_capinsetswidth() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ListViewOptions::clear_capinsetswidth() {
  capinsetswidth_ = 0;
  clear_has_capinsetswidth();
}
inline float ListViewOptions::capinsetswidth() const {
  return capinsetswidth_;
}
inline void ListViewOptions::set_capinsetswidth(float value) {
  set_has_capinsetswidth();
  capinsetswidth_ = value;
}

// optional float capInsetsHeight = 21;
inline bool ListViewOptions::has_capinsetsheight() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ListViewOptions::set_has_capinsetsheight() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ListViewOptions::clear_has_capinsetsheight() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ListViewOptions::clear_capinsetsheight() {
  capinsetsheight_ = 0;
  clear_has_capinsetsheight();
}
inline float ListViewOptions::capinsetsheight() const {
  return capinsetsheight_;
}
inline void ListViewOptions::set_capinsetsheight(float value) {
  set_has_capinsetsheight();
  capinsetsheight_ = value;
}

// optional bool backGroundScale9Enable = 22;
inline bool ListViewOptions::has_backgroundscale9enable() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ListViewOptions::set_has_backgroundscale9enable() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ListViewOptions::clear_has_backgroundscale9enable() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ListViewOptions::clear_backgroundscale9enable() {
  backgroundscale9enable_ = false;
  clear_has_backgroundscale9enable();
}
inline bool ListViewOptions::backgroundscale9enable() const {
  return backgroundscale9enable_;
}
inline void ListViewOptions::set_backgroundscale9enable(bool value) {
  set_has_backgroundscale9enable();
  backgroundscale9enable_ = value;
}

// optional float innerWidth = 23;
inline bool ListViewOptions::has_innerwidth() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ListViewOptions::set_has_innerwidth() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ListViewOptions::clear_has_innerwidth() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ListViewOptions::clear_innerwidth() {
  innerwidth_ = 0;
  clear_has_innerwidth();
}
inline float ListViewOptions::innerwidth() const {
  return innerwidth_;
}
inline void ListViewOptions::set_innerwidth(float value) {
  set_has_innerwidth();
  innerwidth_ = value;
}

// optional float innerHeight = 24;
inline bool ListViewOptions::has_innerheight() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ListViewOptions::set_has_innerheight() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ListViewOptions::clear_has_innerheight() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ListViewOptions::clear_innerheight() {
  innerheight_ = 0;
  clear_has_innerheight();
}
inline float ListViewOptions::innerheight() const {
  return innerheight_;
}
inline void ListViewOptions::set_innerheight(float value) {
  set_has_innerheight();
  innerheight_ = value;
}

// optional bool clipAble = 25;
inline bool ListViewOptions::has_clipable() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ListViewOptions::set_has_clipable() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ListViewOptions::clear_has_clipable() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ListViewOptions::clear_clipable() {
  clipable_ = false;
  clear_has_clipable();
}
inline bool ListViewOptions::clipable() const {
  return clipable_;
}
inline void ListViewOptions::set_clipable(bool value) {
  set_has_clipable();
  clipable_ = value;
}

// optional bool bounceEnable = 26;
inline bool ListViewOptions::has_bounceenable() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void ListViewOptions::set_has_bounceenable() {
  _has_bits_[0] |= 0x02000000u;
}
inline void ListViewOptions::clear_has_bounceenable() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void ListViewOptions::clear_bounceenable() {
  bounceenable_ = false;
  clear_has_bounceenable();
}
inline bool ListViewOptions::bounceenable() const {
  return bounceenable_;
}
inline void ListViewOptions::set_bounceenable(bool value) {
  set_has_bounceenable();
  bounceenable_ = value;
}

// optional int32 direction = 27;
inline bool ListViewOptions::has_direction() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void ListViewOptions::set_has_direction() {
  _has_bits_[0] |= 0x04000000u;
}
inline void ListViewOptions::clear_has_direction() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void ListViewOptions::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::google::protobuf::int32 ListViewOptions::direction() const {
  return direction_;
}
inline void ListViewOptions::set_direction(::google::protobuf::int32 value) {
  set_has_direction();
  direction_ = value;
}

// optional int32 gravity = 28;
inline bool ListViewOptions::has_gravity() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void ListViewOptions::set_has_gravity() {
  _has_bits_[0] |= 0x08000000u;
}
inline void ListViewOptions::clear_has_gravity() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void ListViewOptions::clear_gravity() {
  gravity_ = 0;
  clear_has_gravity();
}
inline ::google::protobuf::int32 ListViewOptions::gravity() const {
  return gravity_;
}
inline void ListViewOptions::set_gravity(::google::protobuf::int32 value) {
  set_has_gravity();
  gravity_ = value;
}

// optional int32 itemMargin = 29;
inline bool ListViewOptions::has_itemmargin() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void ListViewOptions::set_has_itemmargin() {
  _has_bits_[0] |= 0x10000000u;
}
inline void ListViewOptions::clear_has_itemmargin() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void ListViewOptions::clear_itemmargin() {
  itemmargin_ = 0;
  clear_has_itemmargin();
}
inline ::google::protobuf::int32 ListViewOptions::itemmargin() const {
  return itemmargin_;
}
inline void ListViewOptions::set_itemmargin(::google::protobuf::int32 value) {
  set_has_itemmargin();
  itemmargin_ = value;
}

// optional float scale9Width = 30;
inline bool ListViewOptions::has_scale9width() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void ListViewOptions::set_has_scale9width() {
  _has_bits_[0] |= 0x20000000u;
}
inline void ListViewOptions::clear_has_scale9width() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void ListViewOptions::clear_scale9width() {
  scale9width_ = 0;
  clear_has_scale9width();
}
inline float ListViewOptions::scale9width() const {
  return scale9width_;
}
inline void ListViewOptions::set_scale9width(float value) {
  set_has_scale9width();
  scale9width_ = value;
}

// optional float scale9Height = 31;
inline bool ListViewOptions::has_scale9height() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void ListViewOptions::set_has_scale9height() {
  _has_bits_[0] |= 0x40000000u;
}
inline void ListViewOptions::clear_has_scale9height() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void ListViewOptions::clear_scale9height() {
  scale9height_ = 0;
  clear_has_scale9height();
}
inline float ListViewOptions::scale9height() const {
  return scale9height_;
}
inline void ListViewOptions::set_scale9height(float value) {
  set_has_scale9height();
  scale9height_ = value;
}

// -------------------------------------------------------------------

// PageViewOptions

// optional string name = 1;
inline bool PageViewOptions::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PageViewOptions::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PageViewOptions::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PageViewOptions::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PageViewOptions::name() const {
  return *name_;
}
inline void PageViewOptions::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PageViewOptions::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PageViewOptions::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PageViewOptions::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PageViewOptions::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PageViewOptions::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classname = 2;
inline bool PageViewOptions::has_classname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PageViewOptions::set_has_classname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PageViewOptions::clear_has_classname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PageViewOptions::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& PageViewOptions::classname() const {
  return *classname_;
}
inline void PageViewOptions::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void PageViewOptions::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void PageViewOptions::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PageViewOptions::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* PageViewOptions::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PageViewOptions::set_allocated_classname(::std::string* classname) {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (classname) {
    set_has_classname();
    classname_ = classname;
  } else {
    clear_has_classname();
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string backGroundImage = 3;
inline bool PageViewOptions::has_backgroundimage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PageViewOptions::set_has_backgroundimage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PageViewOptions::clear_has_backgroundimage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PageViewOptions::clear_backgroundimage() {
  if (backgroundimage_ != &::google::protobuf::internal::kEmptyString) {
    backgroundimage_->clear();
  }
  clear_has_backgroundimage();
}
inline const ::std::string& PageViewOptions::backgroundimage() const {
  return *backgroundimage_;
}
inline void PageViewOptions::set_backgroundimage(const ::std::string& value) {
  set_has_backgroundimage();
  if (backgroundimage_ == &::google::protobuf::internal::kEmptyString) {
    backgroundimage_ = new ::std::string;
  }
  backgroundimage_->assign(value);
}
inline void PageViewOptions::set_backgroundimage(const char* value) {
  set_has_backgroundimage();
  if (backgroundimage_ == &::google::protobuf::internal::kEmptyString) {
    backgroundimage_ = new ::std::string;
  }
  backgroundimage_->assign(value);
}
inline void PageViewOptions::set_backgroundimage(const char* value, size_t size) {
  set_has_backgroundimage();
  if (backgroundimage_ == &::google::protobuf::internal::kEmptyString) {
    backgroundimage_ = new ::std::string;
  }
  backgroundimage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PageViewOptions::mutable_backgroundimage() {
  set_has_backgroundimage();
  if (backgroundimage_ == &::google::protobuf::internal::kEmptyString) {
    backgroundimage_ = new ::std::string;
  }
  return backgroundimage_;
}
inline ::std::string* PageViewOptions::release_backgroundimage() {
  clear_has_backgroundimage();
  if (backgroundimage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = backgroundimage_;
    backgroundimage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PageViewOptions::set_allocated_backgroundimage(::std::string* backgroundimage) {
  if (backgroundimage_ != &::google::protobuf::internal::kEmptyString) {
    delete backgroundimage_;
  }
  if (backgroundimage) {
    set_has_backgroundimage();
    backgroundimage_ = backgroundimage;
  } else {
    clear_has_backgroundimage();
    backgroundimage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protocolbuffers.ResourceData backGroundImageData = 4;
inline bool PageViewOptions::has_backgroundimagedata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PageViewOptions::set_has_backgroundimagedata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PageViewOptions::clear_has_backgroundimagedata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PageViewOptions::clear_backgroundimagedata() {
  if (backgroundimagedata_ != NULL) backgroundimagedata_->::protocolbuffers::ResourceData::Clear();
  clear_has_backgroundimagedata();
}
inline const ::protocolbuffers::ResourceData& PageViewOptions::backgroundimagedata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return backgroundimagedata_ != NULL ? *backgroundimagedata_ : *default_instance().backgroundimagedata_;
#else
  return backgroundimagedata_ != NULL ? *backgroundimagedata_ : *default_instance_->backgroundimagedata_;
#endif
}
inline ::protocolbuffers::ResourceData* PageViewOptions::mutable_backgroundimagedata() {
  set_has_backgroundimagedata();
  if (backgroundimagedata_ == NULL) backgroundimagedata_ = new ::protocolbuffers::ResourceData;
  return backgroundimagedata_;
}
inline ::protocolbuffers::ResourceData* PageViewOptions::release_backgroundimagedata() {
  clear_has_backgroundimagedata();
  ::protocolbuffers::ResourceData* temp = backgroundimagedata_;
  backgroundimagedata_ = NULL;
  return temp;
}
inline void PageViewOptions::set_allocated_backgroundimagedata(::protocolbuffers::ResourceData* backgroundimagedata) {
  delete backgroundimagedata_;
  backgroundimagedata_ = backgroundimagedata;
  if (backgroundimagedata) {
    set_has_backgroundimagedata();
  } else {
    clear_has_backgroundimagedata();
  }
}

// optional bool clipAble = 5;
inline bool PageViewOptions::has_clipable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PageViewOptions::set_has_clipable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PageViewOptions::clear_has_clipable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PageViewOptions::clear_clipable() {
  clipable_ = false;
  clear_has_clipable();
}
inline bool PageViewOptions::clipable() const {
  return clipable_;
}
inline void PageViewOptions::set_clipable(bool value) {
  set_has_clipable();
  clipable_ = value;
}

// optional int32 bgColorR = 6;
inline bool PageViewOptions::has_bgcolorr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PageViewOptions::set_has_bgcolorr() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PageViewOptions::clear_has_bgcolorr() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PageViewOptions::clear_bgcolorr() {
  bgcolorr_ = 0;
  clear_has_bgcolorr();
}
inline ::google::protobuf::int32 PageViewOptions::bgcolorr() const {
  return bgcolorr_;
}
inline void PageViewOptions::set_bgcolorr(::google::protobuf::int32 value) {
  set_has_bgcolorr();
  bgcolorr_ = value;
}

// optional int32 bgColorG = 7;
inline bool PageViewOptions::has_bgcolorg() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PageViewOptions::set_has_bgcolorg() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PageViewOptions::clear_has_bgcolorg() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PageViewOptions::clear_bgcolorg() {
  bgcolorg_ = 0;
  clear_has_bgcolorg();
}
inline ::google::protobuf::int32 PageViewOptions::bgcolorg() const {
  return bgcolorg_;
}
inline void PageViewOptions::set_bgcolorg(::google::protobuf::int32 value) {
  set_has_bgcolorg();
  bgcolorg_ = value;
}

// optional int32 bgColorB = 8;
inline bool PageViewOptions::has_bgcolorb() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PageViewOptions::set_has_bgcolorb() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PageViewOptions::clear_has_bgcolorb() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PageViewOptions::clear_bgcolorb() {
  bgcolorb_ = 0;
  clear_has_bgcolorb();
}
inline ::google::protobuf::int32 PageViewOptions::bgcolorb() const {
  return bgcolorb_;
}
inline void PageViewOptions::set_bgcolorb(::google::protobuf::int32 value) {
  set_has_bgcolorb();
  bgcolorb_ = value;
}

// optional int32 bgStartColorR = 9;
inline bool PageViewOptions::has_bgstartcolorr() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PageViewOptions::set_has_bgstartcolorr() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PageViewOptions::clear_has_bgstartcolorr() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PageViewOptions::clear_bgstartcolorr() {
  bgstartcolorr_ = 0;
  clear_has_bgstartcolorr();
}
inline ::google::protobuf::int32 PageViewOptions::bgstartcolorr() const {
  return bgstartcolorr_;
}
inline void PageViewOptions::set_bgstartcolorr(::google::protobuf::int32 value) {
  set_has_bgstartcolorr();
  bgstartcolorr_ = value;
}

// optional int32 bgStartColorG = 10;
inline bool PageViewOptions::has_bgstartcolorg() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PageViewOptions::set_has_bgstartcolorg() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PageViewOptions::clear_has_bgstartcolorg() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PageViewOptions::clear_bgstartcolorg() {
  bgstartcolorg_ = 0;
  clear_has_bgstartcolorg();
}
inline ::google::protobuf::int32 PageViewOptions::bgstartcolorg() const {
  return bgstartcolorg_;
}
inline void PageViewOptions::set_bgstartcolorg(::google::protobuf::int32 value) {
  set_has_bgstartcolorg();
  bgstartcolorg_ = value;
}

// optional int32 bgStartColorB = 11;
inline bool PageViewOptions::has_bgstartcolorb() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PageViewOptions::set_has_bgstartcolorb() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PageViewOptions::clear_has_bgstartcolorb() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PageViewOptions::clear_bgstartcolorb() {
  bgstartcolorb_ = 0;
  clear_has_bgstartcolorb();
}
inline ::google::protobuf::int32 PageViewOptions::bgstartcolorb() const {
  return bgstartcolorb_;
}
inline void PageViewOptions::set_bgstartcolorb(::google::protobuf::int32 value) {
  set_has_bgstartcolorb();
  bgstartcolorb_ = value;
}

// optional int32 bgEndColorR = 12;
inline bool PageViewOptions::has_bgendcolorr() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PageViewOptions::set_has_bgendcolorr() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PageViewOptions::clear_has_bgendcolorr() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PageViewOptions::clear_bgendcolorr() {
  bgendcolorr_ = 0;
  clear_has_bgendcolorr();
}
inline ::google::protobuf::int32 PageViewOptions::bgendcolorr() const {
  return bgendcolorr_;
}
inline void PageViewOptions::set_bgendcolorr(::google::protobuf::int32 value) {
  set_has_bgendcolorr();
  bgendcolorr_ = value;
}

// optional int32 bgEndColorG = 13;
inline bool PageViewOptions::has_bgendcolorg() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PageViewOptions::set_has_bgendcolorg() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PageViewOptions::clear_has_bgendcolorg() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PageViewOptions::clear_bgendcolorg() {
  bgendcolorg_ = 0;
  clear_has_bgendcolorg();
}
inline ::google::protobuf::int32 PageViewOptions::bgendcolorg() const {
  return bgendcolorg_;
}
inline void PageViewOptions::set_bgendcolorg(::google::protobuf::int32 value) {
  set_has_bgendcolorg();
  bgendcolorg_ = value;
}

// optional int32 bgEndColorB = 14;
inline bool PageViewOptions::has_bgendcolorb() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PageViewOptions::set_has_bgendcolorb() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PageViewOptions::clear_has_bgendcolorb() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PageViewOptions::clear_bgendcolorb() {
  bgendcolorb_ = 0;
  clear_has_bgendcolorb();
}
inline ::google::protobuf::int32 PageViewOptions::bgendcolorb() const {
  return bgendcolorb_;
}
inline void PageViewOptions::set_bgendcolorb(::google::protobuf::int32 value) {
  set_has_bgendcolorb();
  bgendcolorb_ = value;
}

// optional int32 colorType = 15;
inline bool PageViewOptions::has_colortype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PageViewOptions::set_has_colortype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PageViewOptions::clear_has_colortype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PageViewOptions::clear_colortype() {
  colortype_ = 0;
  clear_has_colortype();
}
inline ::google::protobuf::int32 PageViewOptions::colortype() const {
  return colortype_;
}
inline void PageViewOptions::set_colortype(::google::protobuf::int32 value) {
  set_has_colortype();
  colortype_ = value;
}

// optional int32 bgColorOpacity = 16;
inline bool PageViewOptions::has_bgcoloropacity() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PageViewOptions::set_has_bgcoloropacity() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PageViewOptions::clear_has_bgcoloropacity() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PageViewOptions::clear_bgcoloropacity() {
  bgcoloropacity_ = 0;
  clear_has_bgcoloropacity();
}
inline ::google::protobuf::int32 PageViewOptions::bgcoloropacity() const {
  return bgcoloropacity_;
}
inline void PageViewOptions::set_bgcoloropacity(::google::protobuf::int32 value) {
  set_has_bgcoloropacity();
  bgcoloropacity_ = value;
}

// optional float vectorX = 17;
inline bool PageViewOptions::has_vectorx() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PageViewOptions::set_has_vectorx() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PageViewOptions::clear_has_vectorx() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PageViewOptions::clear_vectorx() {
  vectorx_ = 0;
  clear_has_vectorx();
}
inline float PageViewOptions::vectorx() const {
  return vectorx_;
}
inline void PageViewOptions::set_vectorx(float value) {
  set_has_vectorx();
  vectorx_ = value;
}

// optional float vectorY = 18;
inline bool PageViewOptions::has_vectory() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PageViewOptions::set_has_vectory() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PageViewOptions::clear_has_vectory() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PageViewOptions::clear_vectory() {
  vectory_ = 0;
  clear_has_vectory();
}
inline float PageViewOptions::vectory() const {
  return vectory_;
}
inline void PageViewOptions::set_vectory(float value) {
  set_has_vectory();
  vectory_ = value;
}

// optional float capInsetsX = 19;
inline bool PageViewOptions::has_capinsetsx() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PageViewOptions::set_has_capinsetsx() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PageViewOptions::clear_has_capinsetsx() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PageViewOptions::clear_capinsetsx() {
  capinsetsx_ = 0;
  clear_has_capinsetsx();
}
inline float PageViewOptions::capinsetsx() const {
  return capinsetsx_;
}
inline void PageViewOptions::set_capinsetsx(float value) {
  set_has_capinsetsx();
  capinsetsx_ = value;
}

// optional float capInsetsY = 20;
inline bool PageViewOptions::has_capinsetsy() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PageViewOptions::set_has_capinsetsy() {
  _has_bits_[0] |= 0x00080000u;
}
inline void PageViewOptions::clear_has_capinsetsy() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void PageViewOptions::clear_capinsetsy() {
  capinsetsy_ = 0;
  clear_has_capinsetsy();
}
inline float PageViewOptions::capinsetsy() const {
  return capinsetsy_;
}
inline void PageViewOptions::set_capinsetsy(float value) {
  set_has_capinsetsy();
  capinsetsy_ = value;
}

// optional float capInsetsWidth = 21;
inline bool PageViewOptions::has_capinsetswidth() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PageViewOptions::set_has_capinsetswidth() {
  _has_bits_[0] |= 0x00100000u;
}
inline void PageViewOptions::clear_has_capinsetswidth() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void PageViewOptions::clear_capinsetswidth() {
  capinsetswidth_ = 0;
  clear_has_capinsetswidth();
}
inline float PageViewOptions::capinsetswidth() const {
  return capinsetswidth_;
}
inline void PageViewOptions::set_capinsetswidth(float value) {
  set_has_capinsetswidth();
  capinsetswidth_ = value;
}

// optional float capInsetsHeight = 22;
inline bool PageViewOptions::has_capinsetsheight() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PageViewOptions::set_has_capinsetsheight() {
  _has_bits_[0] |= 0x00200000u;
}
inline void PageViewOptions::clear_has_capinsetsheight() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void PageViewOptions::clear_capinsetsheight() {
  capinsetsheight_ = 0;
  clear_has_capinsetsheight();
}
inline float PageViewOptions::capinsetsheight() const {
  return capinsetsheight_;
}
inline void PageViewOptions::set_capinsetsheight(float value) {
  set_has_capinsetsheight();
  capinsetsheight_ = value;
}

// optional bool backGroundScale9Enable = 23;
inline bool PageViewOptions::has_backgroundscale9enable() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PageViewOptions::set_has_backgroundscale9enable() {
  _has_bits_[0] |= 0x00400000u;
}
inline void PageViewOptions::clear_has_backgroundscale9enable() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void PageViewOptions::clear_backgroundscale9enable() {
  backgroundscale9enable_ = false;
  clear_has_backgroundscale9enable();
}
inline bool PageViewOptions::backgroundscale9enable() const {
  return backgroundscale9enable_;
}
inline void PageViewOptions::set_backgroundscale9enable(bool value) {
  set_has_backgroundscale9enable();
  backgroundscale9enable_ = value;
}

// optional float scale9Width = 24;
inline bool PageViewOptions::has_scale9width() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PageViewOptions::set_has_scale9width() {
  _has_bits_[0] |= 0x00800000u;
}
inline void PageViewOptions::clear_has_scale9width() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void PageViewOptions::clear_scale9width() {
  scale9width_ = 0;
  clear_has_scale9width();
}
inline float PageViewOptions::scale9width() const {
  return scale9width_;
}
inline void PageViewOptions::set_scale9width(float value) {
  set_has_scale9width();
  scale9width_ = value;
}

// optional float scale9Height = 25;
inline bool PageViewOptions::has_scale9height() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PageViewOptions::set_has_scale9height() {
  _has_bits_[0] |= 0x01000000u;
}
inline void PageViewOptions::clear_has_scale9height() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void PageViewOptions::clear_scale9height() {
  scale9height_ = 0;
  clear_has_scale9height();
}
inline float PageViewOptions::scale9height() const {
  return scale9height_;
}
inline void PageViewOptions::set_scale9height(float value) {
  set_has_scale9height();
  scale9height_ = value;
}

// -------------------------------------------------------------------

// PanelOptions

// optional string name = 1;
inline bool PanelOptions::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void PanelOptions::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void PanelOptions::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void PanelOptions::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& PanelOptions::name() const {
  return *name_;
}
inline void PanelOptions::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PanelOptions::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void PanelOptions::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PanelOptions::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* PanelOptions::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PanelOptions::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classname = 2;
inline bool PanelOptions::has_classname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void PanelOptions::set_has_classname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void PanelOptions::clear_has_classname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void PanelOptions::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& PanelOptions::classname() const {
  return *classname_;
}
inline void PanelOptions::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void PanelOptions::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void PanelOptions::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PanelOptions::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* PanelOptions::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PanelOptions::set_allocated_classname(::std::string* classname) {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (classname) {
    set_has_classname();
    classname_ = classname;
  } else {
    clear_has_classname();
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string backGroundImage = 3;
inline bool PanelOptions::has_backgroundimage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void PanelOptions::set_has_backgroundimage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void PanelOptions::clear_has_backgroundimage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void PanelOptions::clear_backgroundimage() {
  if (backgroundimage_ != &::google::protobuf::internal::kEmptyString) {
    backgroundimage_->clear();
  }
  clear_has_backgroundimage();
}
inline const ::std::string& PanelOptions::backgroundimage() const {
  return *backgroundimage_;
}
inline void PanelOptions::set_backgroundimage(const ::std::string& value) {
  set_has_backgroundimage();
  if (backgroundimage_ == &::google::protobuf::internal::kEmptyString) {
    backgroundimage_ = new ::std::string;
  }
  backgroundimage_->assign(value);
}
inline void PanelOptions::set_backgroundimage(const char* value) {
  set_has_backgroundimage();
  if (backgroundimage_ == &::google::protobuf::internal::kEmptyString) {
    backgroundimage_ = new ::std::string;
  }
  backgroundimage_->assign(value);
}
inline void PanelOptions::set_backgroundimage(const char* value, size_t size) {
  set_has_backgroundimage();
  if (backgroundimage_ == &::google::protobuf::internal::kEmptyString) {
    backgroundimage_ = new ::std::string;
  }
  backgroundimage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* PanelOptions::mutable_backgroundimage() {
  set_has_backgroundimage();
  if (backgroundimage_ == &::google::protobuf::internal::kEmptyString) {
    backgroundimage_ = new ::std::string;
  }
  return backgroundimage_;
}
inline ::std::string* PanelOptions::release_backgroundimage() {
  clear_has_backgroundimage();
  if (backgroundimage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = backgroundimage_;
    backgroundimage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void PanelOptions::set_allocated_backgroundimage(::std::string* backgroundimage) {
  if (backgroundimage_ != &::google::protobuf::internal::kEmptyString) {
    delete backgroundimage_;
  }
  if (backgroundimage) {
    set_has_backgroundimage();
    backgroundimage_ = backgroundimage;
  } else {
    clear_has_backgroundimage();
    backgroundimage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protocolbuffers.ResourceData backGroundImageData = 4;
inline bool PanelOptions::has_backgroundimagedata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void PanelOptions::set_has_backgroundimagedata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void PanelOptions::clear_has_backgroundimagedata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void PanelOptions::clear_backgroundimagedata() {
  if (backgroundimagedata_ != NULL) backgroundimagedata_->::protocolbuffers::ResourceData::Clear();
  clear_has_backgroundimagedata();
}
inline const ::protocolbuffers::ResourceData& PanelOptions::backgroundimagedata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return backgroundimagedata_ != NULL ? *backgroundimagedata_ : *default_instance().backgroundimagedata_;
#else
  return backgroundimagedata_ != NULL ? *backgroundimagedata_ : *default_instance_->backgroundimagedata_;
#endif
}
inline ::protocolbuffers::ResourceData* PanelOptions::mutable_backgroundimagedata() {
  set_has_backgroundimagedata();
  if (backgroundimagedata_ == NULL) backgroundimagedata_ = new ::protocolbuffers::ResourceData;
  return backgroundimagedata_;
}
inline ::protocolbuffers::ResourceData* PanelOptions::release_backgroundimagedata() {
  clear_has_backgroundimagedata();
  ::protocolbuffers::ResourceData* temp = backgroundimagedata_;
  backgroundimagedata_ = NULL;
  return temp;
}
inline void PanelOptions::set_allocated_backgroundimagedata(::protocolbuffers::ResourceData* backgroundimagedata) {
  delete backgroundimagedata_;
  backgroundimagedata_ = backgroundimagedata;
  if (backgroundimagedata) {
    set_has_backgroundimagedata();
  } else {
    clear_has_backgroundimagedata();
  }
}

// optional bool clipAble = 5;
inline bool PanelOptions::has_clipable() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void PanelOptions::set_has_clipable() {
  _has_bits_[0] |= 0x00000010u;
}
inline void PanelOptions::clear_has_clipable() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void PanelOptions::clear_clipable() {
  clipable_ = false;
  clear_has_clipable();
}
inline bool PanelOptions::clipable() const {
  return clipable_;
}
inline void PanelOptions::set_clipable(bool value) {
  set_has_clipable();
  clipable_ = value;
}

// optional int32 bgColorR = 6;
inline bool PanelOptions::has_bgcolorr() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void PanelOptions::set_has_bgcolorr() {
  _has_bits_[0] |= 0x00000020u;
}
inline void PanelOptions::clear_has_bgcolorr() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void PanelOptions::clear_bgcolorr() {
  bgcolorr_ = 0;
  clear_has_bgcolorr();
}
inline ::google::protobuf::int32 PanelOptions::bgcolorr() const {
  return bgcolorr_;
}
inline void PanelOptions::set_bgcolorr(::google::protobuf::int32 value) {
  set_has_bgcolorr();
  bgcolorr_ = value;
}

// optional int32 bgColorG = 7;
inline bool PanelOptions::has_bgcolorg() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void PanelOptions::set_has_bgcolorg() {
  _has_bits_[0] |= 0x00000040u;
}
inline void PanelOptions::clear_has_bgcolorg() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void PanelOptions::clear_bgcolorg() {
  bgcolorg_ = 0;
  clear_has_bgcolorg();
}
inline ::google::protobuf::int32 PanelOptions::bgcolorg() const {
  return bgcolorg_;
}
inline void PanelOptions::set_bgcolorg(::google::protobuf::int32 value) {
  set_has_bgcolorg();
  bgcolorg_ = value;
}

// optional int32 bgColorB = 8;
inline bool PanelOptions::has_bgcolorb() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void PanelOptions::set_has_bgcolorb() {
  _has_bits_[0] |= 0x00000080u;
}
inline void PanelOptions::clear_has_bgcolorb() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void PanelOptions::clear_bgcolorb() {
  bgcolorb_ = 0;
  clear_has_bgcolorb();
}
inline ::google::protobuf::int32 PanelOptions::bgcolorb() const {
  return bgcolorb_;
}
inline void PanelOptions::set_bgcolorb(::google::protobuf::int32 value) {
  set_has_bgcolorb();
  bgcolorb_ = value;
}

// optional int32 bgStartColorR = 9;
inline bool PanelOptions::has_bgstartcolorr() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void PanelOptions::set_has_bgstartcolorr() {
  _has_bits_[0] |= 0x00000100u;
}
inline void PanelOptions::clear_has_bgstartcolorr() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void PanelOptions::clear_bgstartcolorr() {
  bgstartcolorr_ = 0;
  clear_has_bgstartcolorr();
}
inline ::google::protobuf::int32 PanelOptions::bgstartcolorr() const {
  return bgstartcolorr_;
}
inline void PanelOptions::set_bgstartcolorr(::google::protobuf::int32 value) {
  set_has_bgstartcolorr();
  bgstartcolorr_ = value;
}

// optional int32 bgStartColorG = 10;
inline bool PanelOptions::has_bgstartcolorg() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void PanelOptions::set_has_bgstartcolorg() {
  _has_bits_[0] |= 0x00000200u;
}
inline void PanelOptions::clear_has_bgstartcolorg() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void PanelOptions::clear_bgstartcolorg() {
  bgstartcolorg_ = 0;
  clear_has_bgstartcolorg();
}
inline ::google::protobuf::int32 PanelOptions::bgstartcolorg() const {
  return bgstartcolorg_;
}
inline void PanelOptions::set_bgstartcolorg(::google::protobuf::int32 value) {
  set_has_bgstartcolorg();
  bgstartcolorg_ = value;
}

// optional int32 bgStartColorB = 11;
inline bool PanelOptions::has_bgstartcolorb() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void PanelOptions::set_has_bgstartcolorb() {
  _has_bits_[0] |= 0x00000400u;
}
inline void PanelOptions::clear_has_bgstartcolorb() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void PanelOptions::clear_bgstartcolorb() {
  bgstartcolorb_ = 0;
  clear_has_bgstartcolorb();
}
inline ::google::protobuf::int32 PanelOptions::bgstartcolorb() const {
  return bgstartcolorb_;
}
inline void PanelOptions::set_bgstartcolorb(::google::protobuf::int32 value) {
  set_has_bgstartcolorb();
  bgstartcolorb_ = value;
}

// optional int32 bgEndColorR = 12;
inline bool PanelOptions::has_bgendcolorr() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void PanelOptions::set_has_bgendcolorr() {
  _has_bits_[0] |= 0x00000800u;
}
inline void PanelOptions::clear_has_bgendcolorr() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void PanelOptions::clear_bgendcolorr() {
  bgendcolorr_ = 0;
  clear_has_bgendcolorr();
}
inline ::google::protobuf::int32 PanelOptions::bgendcolorr() const {
  return bgendcolorr_;
}
inline void PanelOptions::set_bgendcolorr(::google::protobuf::int32 value) {
  set_has_bgendcolorr();
  bgendcolorr_ = value;
}

// optional int32 bgEndColorG = 13;
inline bool PanelOptions::has_bgendcolorg() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void PanelOptions::set_has_bgendcolorg() {
  _has_bits_[0] |= 0x00001000u;
}
inline void PanelOptions::clear_has_bgendcolorg() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void PanelOptions::clear_bgendcolorg() {
  bgendcolorg_ = 0;
  clear_has_bgendcolorg();
}
inline ::google::protobuf::int32 PanelOptions::bgendcolorg() const {
  return bgendcolorg_;
}
inline void PanelOptions::set_bgendcolorg(::google::protobuf::int32 value) {
  set_has_bgendcolorg();
  bgendcolorg_ = value;
}

// optional int32 bgEndColorB = 14;
inline bool PanelOptions::has_bgendcolorb() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void PanelOptions::set_has_bgendcolorb() {
  _has_bits_[0] |= 0x00002000u;
}
inline void PanelOptions::clear_has_bgendcolorb() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void PanelOptions::clear_bgendcolorb() {
  bgendcolorb_ = 0;
  clear_has_bgendcolorb();
}
inline ::google::protobuf::int32 PanelOptions::bgendcolorb() const {
  return bgendcolorb_;
}
inline void PanelOptions::set_bgendcolorb(::google::protobuf::int32 value) {
  set_has_bgendcolorb();
  bgendcolorb_ = value;
}

// optional int32 colorType = 15;
inline bool PanelOptions::has_colortype() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void PanelOptions::set_has_colortype() {
  _has_bits_[0] |= 0x00004000u;
}
inline void PanelOptions::clear_has_colortype() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void PanelOptions::clear_colortype() {
  colortype_ = 0;
  clear_has_colortype();
}
inline ::google::protobuf::int32 PanelOptions::colortype() const {
  return colortype_;
}
inline void PanelOptions::set_colortype(::google::protobuf::int32 value) {
  set_has_colortype();
  colortype_ = value;
}

// optional int32 bgColorOpacity = 16;
inline bool PanelOptions::has_bgcoloropacity() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void PanelOptions::set_has_bgcoloropacity() {
  _has_bits_[0] |= 0x00008000u;
}
inline void PanelOptions::clear_has_bgcoloropacity() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void PanelOptions::clear_bgcoloropacity() {
  bgcoloropacity_ = 0;
  clear_has_bgcoloropacity();
}
inline ::google::protobuf::int32 PanelOptions::bgcoloropacity() const {
  return bgcoloropacity_;
}
inline void PanelOptions::set_bgcoloropacity(::google::protobuf::int32 value) {
  set_has_bgcoloropacity();
  bgcoloropacity_ = value;
}

// optional float vectorX = 17;
inline bool PanelOptions::has_vectorx() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void PanelOptions::set_has_vectorx() {
  _has_bits_[0] |= 0x00010000u;
}
inline void PanelOptions::clear_has_vectorx() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void PanelOptions::clear_vectorx() {
  vectorx_ = 0;
  clear_has_vectorx();
}
inline float PanelOptions::vectorx() const {
  return vectorx_;
}
inline void PanelOptions::set_vectorx(float value) {
  set_has_vectorx();
  vectorx_ = value;
}

// optional float vectorY = 18;
inline bool PanelOptions::has_vectory() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void PanelOptions::set_has_vectory() {
  _has_bits_[0] |= 0x00020000u;
}
inline void PanelOptions::clear_has_vectory() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void PanelOptions::clear_vectory() {
  vectory_ = 0;
  clear_has_vectory();
}
inline float PanelOptions::vectory() const {
  return vectory_;
}
inline void PanelOptions::set_vectory(float value) {
  set_has_vectory();
  vectory_ = value;
}

// optional float capInsetsX = 19;
inline bool PanelOptions::has_capinsetsx() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void PanelOptions::set_has_capinsetsx() {
  _has_bits_[0] |= 0x00040000u;
}
inline void PanelOptions::clear_has_capinsetsx() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void PanelOptions::clear_capinsetsx() {
  capinsetsx_ = 0;
  clear_has_capinsetsx();
}
inline float PanelOptions::capinsetsx() const {
  return capinsetsx_;
}
inline void PanelOptions::set_capinsetsx(float value) {
  set_has_capinsetsx();
  capinsetsx_ = value;
}

// optional float capInsetsY = 20;
inline bool PanelOptions::has_capinsetsy() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void PanelOptions::set_has_capinsetsy() {
  _has_bits_[0] |= 0x00080000u;
}
inline void PanelOptions::clear_has_capinsetsy() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void PanelOptions::clear_capinsetsy() {
  capinsetsy_ = 0;
  clear_has_capinsetsy();
}
inline float PanelOptions::capinsetsy() const {
  return capinsetsy_;
}
inline void PanelOptions::set_capinsetsy(float value) {
  set_has_capinsetsy();
  capinsetsy_ = value;
}

// optional float capInsetsWidth = 21;
inline bool PanelOptions::has_capinsetswidth() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void PanelOptions::set_has_capinsetswidth() {
  _has_bits_[0] |= 0x00100000u;
}
inline void PanelOptions::clear_has_capinsetswidth() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void PanelOptions::clear_capinsetswidth() {
  capinsetswidth_ = 0;
  clear_has_capinsetswidth();
}
inline float PanelOptions::capinsetswidth() const {
  return capinsetswidth_;
}
inline void PanelOptions::set_capinsetswidth(float value) {
  set_has_capinsetswidth();
  capinsetswidth_ = value;
}

// optional float capInsetsHeight = 22;
inline bool PanelOptions::has_capinsetsheight() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void PanelOptions::set_has_capinsetsheight() {
  _has_bits_[0] |= 0x00200000u;
}
inline void PanelOptions::clear_has_capinsetsheight() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void PanelOptions::clear_capinsetsheight() {
  capinsetsheight_ = 0;
  clear_has_capinsetsheight();
}
inline float PanelOptions::capinsetsheight() const {
  return capinsetsheight_;
}
inline void PanelOptions::set_capinsetsheight(float value) {
  set_has_capinsetsheight();
  capinsetsheight_ = value;
}

// optional bool backGroundScale9Enable = 23;
inline bool PanelOptions::has_backgroundscale9enable() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void PanelOptions::set_has_backgroundscale9enable() {
  _has_bits_[0] |= 0x00400000u;
}
inline void PanelOptions::clear_has_backgroundscale9enable() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void PanelOptions::clear_backgroundscale9enable() {
  backgroundscale9enable_ = false;
  clear_has_backgroundscale9enable();
}
inline bool PanelOptions::backgroundscale9enable() const {
  return backgroundscale9enable_;
}
inline void PanelOptions::set_backgroundscale9enable(bool value) {
  set_has_backgroundscale9enable();
  backgroundscale9enable_ = value;
}

// optional int32 layoutType = 24;
inline bool PanelOptions::has_layouttype() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void PanelOptions::set_has_layouttype() {
  _has_bits_[0] |= 0x00800000u;
}
inline void PanelOptions::clear_has_layouttype() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void PanelOptions::clear_layouttype() {
  layouttype_ = 0;
  clear_has_layouttype();
}
inline ::google::protobuf::int32 PanelOptions::layouttype() const {
  return layouttype_;
}
inline void PanelOptions::set_layouttype(::google::protobuf::int32 value) {
  set_has_layouttype();
  layouttype_ = value;
}

// optional bool adaptScreen = 25;
inline bool PanelOptions::has_adaptscreen() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void PanelOptions::set_has_adaptscreen() {
  _has_bits_[0] |= 0x01000000u;
}
inline void PanelOptions::clear_has_adaptscreen() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void PanelOptions::clear_adaptscreen() {
  adaptscreen_ = false;
  clear_has_adaptscreen();
}
inline bool PanelOptions::adaptscreen() const {
  return adaptscreen_;
}
inline void PanelOptions::set_adaptscreen(bool value) {
  set_has_adaptscreen();
  adaptscreen_ = value;
}

// optional float scale9Width = 26;
inline bool PanelOptions::has_scale9width() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void PanelOptions::set_has_scale9width() {
  _has_bits_[0] |= 0x02000000u;
}
inline void PanelOptions::clear_has_scale9width() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void PanelOptions::clear_scale9width() {
  scale9width_ = 0;
  clear_has_scale9width();
}
inline float PanelOptions::scale9width() const {
  return scale9width_;
}
inline void PanelOptions::set_scale9width(float value) {
  set_has_scale9width();
  scale9width_ = value;
}

// optional float scale9Height = 27;
inline bool PanelOptions::has_scale9height() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void PanelOptions::set_has_scale9height() {
  _has_bits_[0] |= 0x04000000u;
}
inline void PanelOptions::clear_has_scale9height() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void PanelOptions::clear_scale9height() {
  scale9height_ = 0;
  clear_has_scale9height();
}
inline float PanelOptions::scale9height() const {
  return scale9height_;
}
inline void PanelOptions::set_scale9height(float value) {
  set_has_scale9height();
  scale9height_ = value;
}

// -------------------------------------------------------------------

// ScrollViewOptions

// optional string name = 1;
inline bool ScrollViewOptions::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ScrollViewOptions::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ScrollViewOptions::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ScrollViewOptions::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ScrollViewOptions::name() const {
  return *name_;
}
inline void ScrollViewOptions::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ScrollViewOptions::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ScrollViewOptions::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ScrollViewOptions::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ScrollViewOptions::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ScrollViewOptions::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classname = 2;
inline bool ScrollViewOptions::has_classname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ScrollViewOptions::set_has_classname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ScrollViewOptions::clear_has_classname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ScrollViewOptions::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& ScrollViewOptions::classname() const {
  return *classname_;
}
inline void ScrollViewOptions::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void ScrollViewOptions::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void ScrollViewOptions::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ScrollViewOptions::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* ScrollViewOptions::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ScrollViewOptions::set_allocated_classname(::std::string* classname) {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (classname) {
    set_has_classname();
    classname_ = classname;
  } else {
    clear_has_classname();
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string backGroundImage = 3;
inline bool ScrollViewOptions::has_backgroundimage() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ScrollViewOptions::set_has_backgroundimage() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ScrollViewOptions::clear_has_backgroundimage() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ScrollViewOptions::clear_backgroundimage() {
  if (backgroundimage_ != &::google::protobuf::internal::kEmptyString) {
    backgroundimage_->clear();
  }
  clear_has_backgroundimage();
}
inline const ::std::string& ScrollViewOptions::backgroundimage() const {
  return *backgroundimage_;
}
inline void ScrollViewOptions::set_backgroundimage(const ::std::string& value) {
  set_has_backgroundimage();
  if (backgroundimage_ == &::google::protobuf::internal::kEmptyString) {
    backgroundimage_ = new ::std::string;
  }
  backgroundimage_->assign(value);
}
inline void ScrollViewOptions::set_backgroundimage(const char* value) {
  set_has_backgroundimage();
  if (backgroundimage_ == &::google::protobuf::internal::kEmptyString) {
    backgroundimage_ = new ::std::string;
  }
  backgroundimage_->assign(value);
}
inline void ScrollViewOptions::set_backgroundimage(const char* value, size_t size) {
  set_has_backgroundimage();
  if (backgroundimage_ == &::google::protobuf::internal::kEmptyString) {
    backgroundimage_ = new ::std::string;
  }
  backgroundimage_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ScrollViewOptions::mutable_backgroundimage() {
  set_has_backgroundimage();
  if (backgroundimage_ == &::google::protobuf::internal::kEmptyString) {
    backgroundimage_ = new ::std::string;
  }
  return backgroundimage_;
}
inline ::std::string* ScrollViewOptions::release_backgroundimage() {
  clear_has_backgroundimage();
  if (backgroundimage_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = backgroundimage_;
    backgroundimage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ScrollViewOptions::set_allocated_backgroundimage(::std::string* backgroundimage) {
  if (backgroundimage_ != &::google::protobuf::internal::kEmptyString) {
    delete backgroundimage_;
  }
  if (backgroundimage) {
    set_has_backgroundimage();
    backgroundimage_ = backgroundimage;
  } else {
    clear_has_backgroundimage();
    backgroundimage_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protocolbuffers.ResourceData backGroundImageData = 4;
inline bool ScrollViewOptions::has_backgroundimagedata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ScrollViewOptions::set_has_backgroundimagedata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ScrollViewOptions::clear_has_backgroundimagedata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ScrollViewOptions::clear_backgroundimagedata() {
  if (backgroundimagedata_ != NULL) backgroundimagedata_->::protocolbuffers::ResourceData::Clear();
  clear_has_backgroundimagedata();
}
inline const ::protocolbuffers::ResourceData& ScrollViewOptions::backgroundimagedata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return backgroundimagedata_ != NULL ? *backgroundimagedata_ : *default_instance().backgroundimagedata_;
#else
  return backgroundimagedata_ != NULL ? *backgroundimagedata_ : *default_instance_->backgroundimagedata_;
#endif
}
inline ::protocolbuffers::ResourceData* ScrollViewOptions::mutable_backgroundimagedata() {
  set_has_backgroundimagedata();
  if (backgroundimagedata_ == NULL) backgroundimagedata_ = new ::protocolbuffers::ResourceData;
  return backgroundimagedata_;
}
inline ::protocolbuffers::ResourceData* ScrollViewOptions::release_backgroundimagedata() {
  clear_has_backgroundimagedata();
  ::protocolbuffers::ResourceData* temp = backgroundimagedata_;
  backgroundimagedata_ = NULL;
  return temp;
}
inline void ScrollViewOptions::set_allocated_backgroundimagedata(::protocolbuffers::ResourceData* backgroundimagedata) {
  delete backgroundimagedata_;
  backgroundimagedata_ = backgroundimagedata;
  if (backgroundimagedata) {
    set_has_backgroundimagedata();
  } else {
    clear_has_backgroundimagedata();
  }
}

// optional int32 bgColorR = 5;
inline bool ScrollViewOptions::has_bgcolorr() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ScrollViewOptions::set_has_bgcolorr() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ScrollViewOptions::clear_has_bgcolorr() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ScrollViewOptions::clear_bgcolorr() {
  bgcolorr_ = 0;
  clear_has_bgcolorr();
}
inline ::google::protobuf::int32 ScrollViewOptions::bgcolorr() const {
  return bgcolorr_;
}
inline void ScrollViewOptions::set_bgcolorr(::google::protobuf::int32 value) {
  set_has_bgcolorr();
  bgcolorr_ = value;
}

// optional int32 bgColorG = 6;
inline bool ScrollViewOptions::has_bgcolorg() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ScrollViewOptions::set_has_bgcolorg() {
  _has_bits_[0] |= 0x00000020u;
}
inline void ScrollViewOptions::clear_has_bgcolorg() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void ScrollViewOptions::clear_bgcolorg() {
  bgcolorg_ = 0;
  clear_has_bgcolorg();
}
inline ::google::protobuf::int32 ScrollViewOptions::bgcolorg() const {
  return bgcolorg_;
}
inline void ScrollViewOptions::set_bgcolorg(::google::protobuf::int32 value) {
  set_has_bgcolorg();
  bgcolorg_ = value;
}

// optional int32 bgColorB = 7;
inline bool ScrollViewOptions::has_bgcolorb() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ScrollViewOptions::set_has_bgcolorb() {
  _has_bits_[0] |= 0x00000040u;
}
inline void ScrollViewOptions::clear_has_bgcolorb() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void ScrollViewOptions::clear_bgcolorb() {
  bgcolorb_ = 0;
  clear_has_bgcolorb();
}
inline ::google::protobuf::int32 ScrollViewOptions::bgcolorb() const {
  return bgcolorb_;
}
inline void ScrollViewOptions::set_bgcolorb(::google::protobuf::int32 value) {
  set_has_bgcolorb();
  bgcolorb_ = value;
}

// optional int32 bgStartColorR = 8;
inline bool ScrollViewOptions::has_bgstartcolorr() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void ScrollViewOptions::set_has_bgstartcolorr() {
  _has_bits_[0] |= 0x00000080u;
}
inline void ScrollViewOptions::clear_has_bgstartcolorr() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void ScrollViewOptions::clear_bgstartcolorr() {
  bgstartcolorr_ = 0;
  clear_has_bgstartcolorr();
}
inline ::google::protobuf::int32 ScrollViewOptions::bgstartcolorr() const {
  return bgstartcolorr_;
}
inline void ScrollViewOptions::set_bgstartcolorr(::google::protobuf::int32 value) {
  set_has_bgstartcolorr();
  bgstartcolorr_ = value;
}

// optional int32 bgStartColorG = 9;
inline bool ScrollViewOptions::has_bgstartcolorg() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void ScrollViewOptions::set_has_bgstartcolorg() {
  _has_bits_[0] |= 0x00000100u;
}
inline void ScrollViewOptions::clear_has_bgstartcolorg() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void ScrollViewOptions::clear_bgstartcolorg() {
  bgstartcolorg_ = 0;
  clear_has_bgstartcolorg();
}
inline ::google::protobuf::int32 ScrollViewOptions::bgstartcolorg() const {
  return bgstartcolorg_;
}
inline void ScrollViewOptions::set_bgstartcolorg(::google::protobuf::int32 value) {
  set_has_bgstartcolorg();
  bgstartcolorg_ = value;
}

// optional int32 bgStartColorB = 10;
inline bool ScrollViewOptions::has_bgstartcolorb() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void ScrollViewOptions::set_has_bgstartcolorb() {
  _has_bits_[0] |= 0x00000200u;
}
inline void ScrollViewOptions::clear_has_bgstartcolorb() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void ScrollViewOptions::clear_bgstartcolorb() {
  bgstartcolorb_ = 0;
  clear_has_bgstartcolorb();
}
inline ::google::protobuf::int32 ScrollViewOptions::bgstartcolorb() const {
  return bgstartcolorb_;
}
inline void ScrollViewOptions::set_bgstartcolorb(::google::protobuf::int32 value) {
  set_has_bgstartcolorb();
  bgstartcolorb_ = value;
}

// optional int32 bgEndColorR = 11;
inline bool ScrollViewOptions::has_bgendcolorr() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void ScrollViewOptions::set_has_bgendcolorr() {
  _has_bits_[0] |= 0x00000400u;
}
inline void ScrollViewOptions::clear_has_bgendcolorr() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void ScrollViewOptions::clear_bgendcolorr() {
  bgendcolorr_ = 0;
  clear_has_bgendcolorr();
}
inline ::google::protobuf::int32 ScrollViewOptions::bgendcolorr() const {
  return bgendcolorr_;
}
inline void ScrollViewOptions::set_bgendcolorr(::google::protobuf::int32 value) {
  set_has_bgendcolorr();
  bgendcolorr_ = value;
}

// optional int32 bgEndColorG = 12;
inline bool ScrollViewOptions::has_bgendcolorg() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void ScrollViewOptions::set_has_bgendcolorg() {
  _has_bits_[0] |= 0x00000800u;
}
inline void ScrollViewOptions::clear_has_bgendcolorg() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void ScrollViewOptions::clear_bgendcolorg() {
  bgendcolorg_ = 0;
  clear_has_bgendcolorg();
}
inline ::google::protobuf::int32 ScrollViewOptions::bgendcolorg() const {
  return bgendcolorg_;
}
inline void ScrollViewOptions::set_bgendcolorg(::google::protobuf::int32 value) {
  set_has_bgendcolorg();
  bgendcolorg_ = value;
}

// optional int32 bgEndColorB = 13;
inline bool ScrollViewOptions::has_bgendcolorb() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void ScrollViewOptions::set_has_bgendcolorb() {
  _has_bits_[0] |= 0x00001000u;
}
inline void ScrollViewOptions::clear_has_bgendcolorb() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void ScrollViewOptions::clear_bgendcolorb() {
  bgendcolorb_ = 0;
  clear_has_bgendcolorb();
}
inline ::google::protobuf::int32 ScrollViewOptions::bgendcolorb() const {
  return bgendcolorb_;
}
inline void ScrollViewOptions::set_bgendcolorb(::google::protobuf::int32 value) {
  set_has_bgendcolorb();
  bgendcolorb_ = value;
}

// optional int32 colorType = 14;
inline bool ScrollViewOptions::has_colortype() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void ScrollViewOptions::set_has_colortype() {
  _has_bits_[0] |= 0x00002000u;
}
inline void ScrollViewOptions::clear_has_colortype() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void ScrollViewOptions::clear_colortype() {
  colortype_ = 0;
  clear_has_colortype();
}
inline ::google::protobuf::int32 ScrollViewOptions::colortype() const {
  return colortype_;
}
inline void ScrollViewOptions::set_colortype(::google::protobuf::int32 value) {
  set_has_colortype();
  colortype_ = value;
}

// optional int32 bgColorOpacity = 15;
inline bool ScrollViewOptions::has_bgcoloropacity() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void ScrollViewOptions::set_has_bgcoloropacity() {
  _has_bits_[0] |= 0x00004000u;
}
inline void ScrollViewOptions::clear_has_bgcoloropacity() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void ScrollViewOptions::clear_bgcoloropacity() {
  bgcoloropacity_ = 0;
  clear_has_bgcoloropacity();
}
inline ::google::protobuf::int32 ScrollViewOptions::bgcoloropacity() const {
  return bgcoloropacity_;
}
inline void ScrollViewOptions::set_bgcoloropacity(::google::protobuf::int32 value) {
  set_has_bgcoloropacity();
  bgcoloropacity_ = value;
}

// optional float vectorX = 16;
inline bool ScrollViewOptions::has_vectorx() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void ScrollViewOptions::set_has_vectorx() {
  _has_bits_[0] |= 0x00008000u;
}
inline void ScrollViewOptions::clear_has_vectorx() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void ScrollViewOptions::clear_vectorx() {
  vectorx_ = 0;
  clear_has_vectorx();
}
inline float ScrollViewOptions::vectorx() const {
  return vectorx_;
}
inline void ScrollViewOptions::set_vectorx(float value) {
  set_has_vectorx();
  vectorx_ = value;
}

// optional float vectorY = 17;
inline bool ScrollViewOptions::has_vectory() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void ScrollViewOptions::set_has_vectory() {
  _has_bits_[0] |= 0x00010000u;
}
inline void ScrollViewOptions::clear_has_vectory() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void ScrollViewOptions::clear_vectory() {
  vectory_ = 0;
  clear_has_vectory();
}
inline float ScrollViewOptions::vectory() const {
  return vectory_;
}
inline void ScrollViewOptions::set_vectory(float value) {
  set_has_vectory();
  vectory_ = value;
}

// optional float capInsetsX = 18;
inline bool ScrollViewOptions::has_capinsetsx() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void ScrollViewOptions::set_has_capinsetsx() {
  _has_bits_[0] |= 0x00020000u;
}
inline void ScrollViewOptions::clear_has_capinsetsx() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void ScrollViewOptions::clear_capinsetsx() {
  capinsetsx_ = 0;
  clear_has_capinsetsx();
}
inline float ScrollViewOptions::capinsetsx() const {
  return capinsetsx_;
}
inline void ScrollViewOptions::set_capinsetsx(float value) {
  set_has_capinsetsx();
  capinsetsx_ = value;
}

// optional float capInsetsY = 19;
inline bool ScrollViewOptions::has_capinsetsy() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void ScrollViewOptions::set_has_capinsetsy() {
  _has_bits_[0] |= 0x00040000u;
}
inline void ScrollViewOptions::clear_has_capinsetsy() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void ScrollViewOptions::clear_capinsetsy() {
  capinsetsy_ = 0;
  clear_has_capinsetsy();
}
inline float ScrollViewOptions::capinsetsy() const {
  return capinsetsy_;
}
inline void ScrollViewOptions::set_capinsetsy(float value) {
  set_has_capinsetsy();
  capinsetsy_ = value;
}

// optional float capInsetsWidth = 20;
inline bool ScrollViewOptions::has_capinsetswidth() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void ScrollViewOptions::set_has_capinsetswidth() {
  _has_bits_[0] |= 0x00080000u;
}
inline void ScrollViewOptions::clear_has_capinsetswidth() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void ScrollViewOptions::clear_capinsetswidth() {
  capinsetswidth_ = 0;
  clear_has_capinsetswidth();
}
inline float ScrollViewOptions::capinsetswidth() const {
  return capinsetswidth_;
}
inline void ScrollViewOptions::set_capinsetswidth(float value) {
  set_has_capinsetswidth();
  capinsetswidth_ = value;
}

// optional float capInsetsHeight = 21;
inline bool ScrollViewOptions::has_capinsetsheight() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void ScrollViewOptions::set_has_capinsetsheight() {
  _has_bits_[0] |= 0x00100000u;
}
inline void ScrollViewOptions::clear_has_capinsetsheight() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void ScrollViewOptions::clear_capinsetsheight() {
  capinsetsheight_ = 0;
  clear_has_capinsetsheight();
}
inline float ScrollViewOptions::capinsetsheight() const {
  return capinsetsheight_;
}
inline void ScrollViewOptions::set_capinsetsheight(float value) {
  set_has_capinsetsheight();
  capinsetsheight_ = value;
}

// optional bool backGroundScale9Enable = 22;
inline bool ScrollViewOptions::has_backgroundscale9enable() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void ScrollViewOptions::set_has_backgroundscale9enable() {
  _has_bits_[0] |= 0x00200000u;
}
inline void ScrollViewOptions::clear_has_backgroundscale9enable() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void ScrollViewOptions::clear_backgroundscale9enable() {
  backgroundscale9enable_ = false;
  clear_has_backgroundscale9enable();
}
inline bool ScrollViewOptions::backgroundscale9enable() const {
  return backgroundscale9enable_;
}
inline void ScrollViewOptions::set_backgroundscale9enable(bool value) {
  set_has_backgroundscale9enable();
  backgroundscale9enable_ = value;
}

// optional float innerWidth = 23;
inline bool ScrollViewOptions::has_innerwidth() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void ScrollViewOptions::set_has_innerwidth() {
  _has_bits_[0] |= 0x00400000u;
}
inline void ScrollViewOptions::clear_has_innerwidth() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void ScrollViewOptions::clear_innerwidth() {
  innerwidth_ = 0;
  clear_has_innerwidth();
}
inline float ScrollViewOptions::innerwidth() const {
  return innerwidth_;
}
inline void ScrollViewOptions::set_innerwidth(float value) {
  set_has_innerwidth();
  innerwidth_ = value;
}

// optional float innerHeight = 24;
inline bool ScrollViewOptions::has_innerheight() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void ScrollViewOptions::set_has_innerheight() {
  _has_bits_[0] |= 0x00800000u;
}
inline void ScrollViewOptions::clear_has_innerheight() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void ScrollViewOptions::clear_innerheight() {
  innerheight_ = 0;
  clear_has_innerheight();
}
inline float ScrollViewOptions::innerheight() const {
  return innerheight_;
}
inline void ScrollViewOptions::set_innerheight(float value) {
  set_has_innerheight();
  innerheight_ = value;
}

// optional int32 direction = 25;
inline bool ScrollViewOptions::has_direction() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void ScrollViewOptions::set_has_direction() {
  _has_bits_[0] |= 0x01000000u;
}
inline void ScrollViewOptions::clear_has_direction() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void ScrollViewOptions::clear_direction() {
  direction_ = 0;
  clear_has_direction();
}
inline ::google::protobuf::int32 ScrollViewOptions::direction() const {
  return direction_;
}
inline void ScrollViewOptions::set_direction(::google::protobuf::int32 value) {
  set_has_direction();
  direction_ = value;
}

// optional bool clipAble = 26;
inline bool ScrollViewOptions::has_clipable() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void ScrollViewOptions::set_has_clipable() {
  _has_bits_[0] |= 0x02000000u;
}
inline void ScrollViewOptions::clear_has_clipable() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void ScrollViewOptions::clear_clipable() {
  clipable_ = false;
  clear_has_clipable();
}
inline bool ScrollViewOptions::clipable() const {
  return clipable_;
}
inline void ScrollViewOptions::set_clipable(bool value) {
  set_has_clipable();
  clipable_ = value;
}

// optional bool bounceEnable = 27;
inline bool ScrollViewOptions::has_bounceenable() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void ScrollViewOptions::set_has_bounceenable() {
  _has_bits_[0] |= 0x04000000u;
}
inline void ScrollViewOptions::clear_has_bounceenable() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void ScrollViewOptions::clear_bounceenable() {
  bounceenable_ = false;
  clear_has_bounceenable();
}
inline bool ScrollViewOptions::bounceenable() const {
  return bounceenable_;
}
inline void ScrollViewOptions::set_bounceenable(bool value) {
  set_has_bounceenable();
  bounceenable_ = value;
}

// optional int32 layoutType = 28;
inline bool ScrollViewOptions::has_layouttype() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void ScrollViewOptions::set_has_layouttype() {
  _has_bits_[0] |= 0x08000000u;
}
inline void ScrollViewOptions::clear_has_layouttype() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void ScrollViewOptions::clear_layouttype() {
  layouttype_ = 0;
  clear_has_layouttype();
}
inline ::google::protobuf::int32 ScrollViewOptions::layouttype() const {
  return layouttype_;
}
inline void ScrollViewOptions::set_layouttype(::google::protobuf::int32 value) {
  set_has_layouttype();
  layouttype_ = value;
}

// optional float scale9Width = 29;
inline bool ScrollViewOptions::has_scale9width() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void ScrollViewOptions::set_has_scale9width() {
  _has_bits_[0] |= 0x10000000u;
}
inline void ScrollViewOptions::clear_has_scale9width() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void ScrollViewOptions::clear_scale9width() {
  scale9width_ = 0;
  clear_has_scale9width();
}
inline float ScrollViewOptions::scale9width() const {
  return scale9width_;
}
inline void ScrollViewOptions::set_scale9width(float value) {
  set_has_scale9width();
  scale9width_ = value;
}

// optional float scale9Height = 30;
inline bool ScrollViewOptions::has_scale9height() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void ScrollViewOptions::set_has_scale9height() {
  _has_bits_[0] |= 0x20000000u;
}
inline void ScrollViewOptions::clear_has_scale9height() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void ScrollViewOptions::clear_scale9height() {
  scale9height_ = 0;
  clear_has_scale9height();
}
inline float ScrollViewOptions::scale9height() const {
  return scale9height_;
}
inline void ScrollViewOptions::set_scale9height(float value) {
  set_has_scale9height();
  scale9height_ = value;
}

// -------------------------------------------------------------------

// SliderOptions

// optional string name = 1;
inline bool SliderOptions::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SliderOptions::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SliderOptions::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SliderOptions::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SliderOptions::name() const {
  return *name_;
}
inline void SliderOptions::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SliderOptions::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SliderOptions::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SliderOptions::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SliderOptions::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SliderOptions::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classname = 2;
inline bool SliderOptions::has_classname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SliderOptions::set_has_classname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SliderOptions::clear_has_classname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SliderOptions::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& SliderOptions::classname() const {
  return *classname_;
}
inline void SliderOptions::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void SliderOptions::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void SliderOptions::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SliderOptions::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* SliderOptions::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SliderOptions::set_allocated_classname(::std::string* classname) {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (classname) {
    set_has_classname();
    classname_ = classname;
  } else {
    clear_has_classname();
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string barFileName = 3;
inline bool SliderOptions::has_barfilename() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SliderOptions::set_has_barfilename() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SliderOptions::clear_has_barfilename() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SliderOptions::clear_barfilename() {
  if (barfilename_ != &::google::protobuf::internal::kEmptyString) {
    barfilename_->clear();
  }
  clear_has_barfilename();
}
inline const ::std::string& SliderOptions::barfilename() const {
  return *barfilename_;
}
inline void SliderOptions::set_barfilename(const ::std::string& value) {
  set_has_barfilename();
  if (barfilename_ == &::google::protobuf::internal::kEmptyString) {
    barfilename_ = new ::std::string;
  }
  barfilename_->assign(value);
}
inline void SliderOptions::set_barfilename(const char* value) {
  set_has_barfilename();
  if (barfilename_ == &::google::protobuf::internal::kEmptyString) {
    barfilename_ = new ::std::string;
  }
  barfilename_->assign(value);
}
inline void SliderOptions::set_barfilename(const char* value, size_t size) {
  set_has_barfilename();
  if (barfilename_ == &::google::protobuf::internal::kEmptyString) {
    barfilename_ = new ::std::string;
  }
  barfilename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SliderOptions::mutable_barfilename() {
  set_has_barfilename();
  if (barfilename_ == &::google::protobuf::internal::kEmptyString) {
    barfilename_ = new ::std::string;
  }
  return barfilename_;
}
inline ::std::string* SliderOptions::release_barfilename() {
  clear_has_barfilename();
  if (barfilename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = barfilename_;
    barfilename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SliderOptions::set_allocated_barfilename(::std::string* barfilename) {
  if (barfilename_ != &::google::protobuf::internal::kEmptyString) {
    delete barfilename_;
  }
  if (barfilename) {
    set_has_barfilename();
    barfilename_ = barfilename;
  } else {
    clear_has_barfilename();
    barfilename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ballNormal = 4;
inline bool SliderOptions::has_ballnormal() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SliderOptions::set_has_ballnormal() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SliderOptions::clear_has_ballnormal() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SliderOptions::clear_ballnormal() {
  if (ballnormal_ != &::google::protobuf::internal::kEmptyString) {
    ballnormal_->clear();
  }
  clear_has_ballnormal();
}
inline const ::std::string& SliderOptions::ballnormal() const {
  return *ballnormal_;
}
inline void SliderOptions::set_ballnormal(const ::std::string& value) {
  set_has_ballnormal();
  if (ballnormal_ == &::google::protobuf::internal::kEmptyString) {
    ballnormal_ = new ::std::string;
  }
  ballnormal_->assign(value);
}
inline void SliderOptions::set_ballnormal(const char* value) {
  set_has_ballnormal();
  if (ballnormal_ == &::google::protobuf::internal::kEmptyString) {
    ballnormal_ = new ::std::string;
  }
  ballnormal_->assign(value);
}
inline void SliderOptions::set_ballnormal(const char* value, size_t size) {
  set_has_ballnormal();
  if (ballnormal_ == &::google::protobuf::internal::kEmptyString) {
    ballnormal_ = new ::std::string;
  }
  ballnormal_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SliderOptions::mutable_ballnormal() {
  set_has_ballnormal();
  if (ballnormal_ == &::google::protobuf::internal::kEmptyString) {
    ballnormal_ = new ::std::string;
  }
  return ballnormal_;
}
inline ::std::string* SliderOptions::release_ballnormal() {
  clear_has_ballnormal();
  if (ballnormal_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ballnormal_;
    ballnormal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SliderOptions::set_allocated_ballnormal(::std::string* ballnormal) {
  if (ballnormal_ != &::google::protobuf::internal::kEmptyString) {
    delete ballnormal_;
  }
  if (ballnormal) {
    set_has_ballnormal();
    ballnormal_ = ballnormal;
  } else {
    clear_has_ballnormal();
    ballnormal_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ballPressed = 5;
inline bool SliderOptions::has_ballpressed() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SliderOptions::set_has_ballpressed() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SliderOptions::clear_has_ballpressed() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SliderOptions::clear_ballpressed() {
  if (ballpressed_ != &::google::protobuf::internal::kEmptyString) {
    ballpressed_->clear();
  }
  clear_has_ballpressed();
}
inline const ::std::string& SliderOptions::ballpressed() const {
  return *ballpressed_;
}
inline void SliderOptions::set_ballpressed(const ::std::string& value) {
  set_has_ballpressed();
  if (ballpressed_ == &::google::protobuf::internal::kEmptyString) {
    ballpressed_ = new ::std::string;
  }
  ballpressed_->assign(value);
}
inline void SliderOptions::set_ballpressed(const char* value) {
  set_has_ballpressed();
  if (ballpressed_ == &::google::protobuf::internal::kEmptyString) {
    ballpressed_ = new ::std::string;
  }
  ballpressed_->assign(value);
}
inline void SliderOptions::set_ballpressed(const char* value, size_t size) {
  set_has_ballpressed();
  if (ballpressed_ == &::google::protobuf::internal::kEmptyString) {
    ballpressed_ = new ::std::string;
  }
  ballpressed_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SliderOptions::mutable_ballpressed() {
  set_has_ballpressed();
  if (ballpressed_ == &::google::protobuf::internal::kEmptyString) {
    ballpressed_ = new ::std::string;
  }
  return ballpressed_;
}
inline ::std::string* SliderOptions::release_ballpressed() {
  clear_has_ballpressed();
  if (ballpressed_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = ballpressed_;
    ballpressed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SliderOptions::set_allocated_ballpressed(::std::string* ballpressed) {
  if (ballpressed_ != &::google::protobuf::internal::kEmptyString) {
    delete ballpressed_;
  }
  if (ballpressed) {
    set_has_ballpressed();
    ballpressed_ = ballpressed;
  } else {
    clear_has_ballpressed();
    ballpressed_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string ballDisabled = 6;
inline bool SliderOptions::has_balldisabled() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SliderOptions::set_has_balldisabled() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SliderOptions::clear_has_balldisabled() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SliderOptions::clear_balldisabled() {
  if (balldisabled_ != &::google::protobuf::internal::kEmptyString) {
    balldisabled_->clear();
  }
  clear_has_balldisabled();
}
inline const ::std::string& SliderOptions::balldisabled() const {
  return *balldisabled_;
}
inline void SliderOptions::set_balldisabled(const ::std::string& value) {
  set_has_balldisabled();
  if (balldisabled_ == &::google::protobuf::internal::kEmptyString) {
    balldisabled_ = new ::std::string;
  }
  balldisabled_->assign(value);
}
inline void SliderOptions::set_balldisabled(const char* value) {
  set_has_balldisabled();
  if (balldisabled_ == &::google::protobuf::internal::kEmptyString) {
    balldisabled_ = new ::std::string;
  }
  balldisabled_->assign(value);
}
inline void SliderOptions::set_balldisabled(const char* value, size_t size) {
  set_has_balldisabled();
  if (balldisabled_ == &::google::protobuf::internal::kEmptyString) {
    balldisabled_ = new ::std::string;
  }
  balldisabled_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SliderOptions::mutable_balldisabled() {
  set_has_balldisabled();
  if (balldisabled_ == &::google::protobuf::internal::kEmptyString) {
    balldisabled_ = new ::std::string;
  }
  return balldisabled_;
}
inline ::std::string* SliderOptions::release_balldisabled() {
  clear_has_balldisabled();
  if (balldisabled_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = balldisabled_;
    balldisabled_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SliderOptions::set_allocated_balldisabled(::std::string* balldisabled) {
  if (balldisabled_ != &::google::protobuf::internal::kEmptyString) {
    delete balldisabled_;
  }
  if (balldisabled) {
    set_has_balldisabled();
    balldisabled_ = balldisabled;
  } else {
    clear_has_balldisabled();
    balldisabled_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protocolbuffers.ResourceData barFileNameData = 7;
inline bool SliderOptions::has_barfilenamedata() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SliderOptions::set_has_barfilenamedata() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SliderOptions::clear_has_barfilenamedata() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SliderOptions::clear_barfilenamedata() {
  if (barfilenamedata_ != NULL) barfilenamedata_->::protocolbuffers::ResourceData::Clear();
  clear_has_barfilenamedata();
}
inline const ::protocolbuffers::ResourceData& SliderOptions::barfilenamedata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return barfilenamedata_ != NULL ? *barfilenamedata_ : *default_instance().barfilenamedata_;
#else
  return barfilenamedata_ != NULL ? *barfilenamedata_ : *default_instance_->barfilenamedata_;
#endif
}
inline ::protocolbuffers::ResourceData* SliderOptions::mutable_barfilenamedata() {
  set_has_barfilenamedata();
  if (barfilenamedata_ == NULL) barfilenamedata_ = new ::protocolbuffers::ResourceData;
  return barfilenamedata_;
}
inline ::protocolbuffers::ResourceData* SliderOptions::release_barfilenamedata() {
  clear_has_barfilenamedata();
  ::protocolbuffers::ResourceData* temp = barfilenamedata_;
  barfilenamedata_ = NULL;
  return temp;
}
inline void SliderOptions::set_allocated_barfilenamedata(::protocolbuffers::ResourceData* barfilenamedata) {
  delete barfilenamedata_;
  barfilenamedata_ = barfilenamedata;
  if (barfilenamedata) {
    set_has_barfilenamedata();
  } else {
    clear_has_barfilenamedata();
  }
}

// optional .protocolbuffers.ResourceData ballNormalData = 8;
inline bool SliderOptions::has_ballnormaldata() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SliderOptions::set_has_ballnormaldata() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SliderOptions::clear_has_ballnormaldata() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SliderOptions::clear_ballnormaldata() {
  if (ballnormaldata_ != NULL) ballnormaldata_->::protocolbuffers::ResourceData::Clear();
  clear_has_ballnormaldata();
}
inline const ::protocolbuffers::ResourceData& SliderOptions::ballnormaldata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ballnormaldata_ != NULL ? *ballnormaldata_ : *default_instance().ballnormaldata_;
#else
  return ballnormaldata_ != NULL ? *ballnormaldata_ : *default_instance_->ballnormaldata_;
#endif
}
inline ::protocolbuffers::ResourceData* SliderOptions::mutable_ballnormaldata() {
  set_has_ballnormaldata();
  if (ballnormaldata_ == NULL) ballnormaldata_ = new ::protocolbuffers::ResourceData;
  return ballnormaldata_;
}
inline ::protocolbuffers::ResourceData* SliderOptions::release_ballnormaldata() {
  clear_has_ballnormaldata();
  ::protocolbuffers::ResourceData* temp = ballnormaldata_;
  ballnormaldata_ = NULL;
  return temp;
}
inline void SliderOptions::set_allocated_ballnormaldata(::protocolbuffers::ResourceData* ballnormaldata) {
  delete ballnormaldata_;
  ballnormaldata_ = ballnormaldata;
  if (ballnormaldata) {
    set_has_ballnormaldata();
  } else {
    clear_has_ballnormaldata();
  }
}

// optional .protocolbuffers.ResourceData ballPressedData = 9;
inline bool SliderOptions::has_ballpresseddata() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SliderOptions::set_has_ballpresseddata() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SliderOptions::clear_has_ballpresseddata() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SliderOptions::clear_ballpresseddata() {
  if (ballpresseddata_ != NULL) ballpresseddata_->::protocolbuffers::ResourceData::Clear();
  clear_has_ballpresseddata();
}
inline const ::protocolbuffers::ResourceData& SliderOptions::ballpresseddata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return ballpresseddata_ != NULL ? *ballpresseddata_ : *default_instance().ballpresseddata_;
#else
  return ballpresseddata_ != NULL ? *ballpresseddata_ : *default_instance_->ballpresseddata_;
#endif
}
inline ::protocolbuffers::ResourceData* SliderOptions::mutable_ballpresseddata() {
  set_has_ballpresseddata();
  if (ballpresseddata_ == NULL) ballpresseddata_ = new ::protocolbuffers::ResourceData;
  return ballpresseddata_;
}
inline ::protocolbuffers::ResourceData* SliderOptions::release_ballpresseddata() {
  clear_has_ballpresseddata();
  ::protocolbuffers::ResourceData* temp = ballpresseddata_;
  ballpresseddata_ = NULL;
  return temp;
}
inline void SliderOptions::set_allocated_ballpresseddata(::protocolbuffers::ResourceData* ballpresseddata) {
  delete ballpresseddata_;
  ballpresseddata_ = ballpresseddata;
  if (ballpresseddata) {
    set_has_ballpresseddata();
  } else {
    clear_has_ballpresseddata();
  }
}

// optional .protocolbuffers.ResourceData ballDisabledData = 10;
inline bool SliderOptions::has_balldisableddata() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SliderOptions::set_has_balldisableddata() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SliderOptions::clear_has_balldisableddata() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SliderOptions::clear_balldisableddata() {
  if (balldisableddata_ != NULL) balldisableddata_->::protocolbuffers::ResourceData::Clear();
  clear_has_balldisableddata();
}
inline const ::protocolbuffers::ResourceData& SliderOptions::balldisableddata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return balldisableddata_ != NULL ? *balldisableddata_ : *default_instance().balldisableddata_;
#else
  return balldisableddata_ != NULL ? *balldisableddata_ : *default_instance_->balldisableddata_;
#endif
}
inline ::protocolbuffers::ResourceData* SliderOptions::mutable_balldisableddata() {
  set_has_balldisableddata();
  if (balldisableddata_ == NULL) balldisableddata_ = new ::protocolbuffers::ResourceData;
  return balldisableddata_;
}
inline ::protocolbuffers::ResourceData* SliderOptions::release_balldisableddata() {
  clear_has_balldisableddata();
  ::protocolbuffers::ResourceData* temp = balldisableddata_;
  balldisableddata_ = NULL;
  return temp;
}
inline void SliderOptions::set_allocated_balldisableddata(::protocolbuffers::ResourceData* balldisableddata) {
  delete balldisableddata_;
  balldisableddata_ = balldisableddata;
  if (balldisableddata) {
    set_has_balldisableddata();
  } else {
    clear_has_balldisableddata();
  }
}

// optional .protocolbuffers.ResourceData progressBarData = 11;
inline bool SliderOptions::has_progressbardata() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SliderOptions::set_has_progressbardata() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SliderOptions::clear_has_progressbardata() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SliderOptions::clear_progressbardata() {
  if (progressbardata_ != NULL) progressbardata_->::protocolbuffers::ResourceData::Clear();
  clear_has_progressbardata();
}
inline const ::protocolbuffers::ResourceData& SliderOptions::progressbardata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return progressbardata_ != NULL ? *progressbardata_ : *default_instance().progressbardata_;
#else
  return progressbardata_ != NULL ? *progressbardata_ : *default_instance_->progressbardata_;
#endif
}
inline ::protocolbuffers::ResourceData* SliderOptions::mutable_progressbardata() {
  set_has_progressbardata();
  if (progressbardata_ == NULL) progressbardata_ = new ::protocolbuffers::ResourceData;
  return progressbardata_;
}
inline ::protocolbuffers::ResourceData* SliderOptions::release_progressbardata() {
  clear_has_progressbardata();
  ::protocolbuffers::ResourceData* temp = progressbardata_;
  progressbardata_ = NULL;
  return temp;
}
inline void SliderOptions::set_allocated_progressbardata(::protocolbuffers::ResourceData* progressbardata) {
  delete progressbardata_;
  progressbardata_ = progressbardata;
  if (progressbardata) {
    set_has_progressbardata();
  } else {
    clear_has_progressbardata();
  }
}

// optional int32 percent = 12;
inline bool SliderOptions::has_percent() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SliderOptions::set_has_percent() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SliderOptions::clear_has_percent() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SliderOptions::clear_percent() {
  percent_ = 0;
  clear_has_percent();
}
inline ::google::protobuf::int32 SliderOptions::percent() const {
  return percent_;
}
inline void SliderOptions::set_percent(::google::protobuf::int32 value) {
  set_has_percent();
  percent_ = value;
}

// optional float capInsetsX = 13;
inline bool SliderOptions::has_capinsetsx() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SliderOptions::set_has_capinsetsx() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SliderOptions::clear_has_capinsetsx() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SliderOptions::clear_capinsetsx() {
  capinsetsx_ = 0;
  clear_has_capinsetsx();
}
inline float SliderOptions::capinsetsx() const {
  return capinsetsx_;
}
inline void SliderOptions::set_capinsetsx(float value) {
  set_has_capinsetsx();
  capinsetsx_ = value;
}

// optional float capInsetsY = 14;
inline bool SliderOptions::has_capinsetsy() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SliderOptions::set_has_capinsetsy() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SliderOptions::clear_has_capinsetsy() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SliderOptions::clear_capinsetsy() {
  capinsetsy_ = 0;
  clear_has_capinsetsy();
}
inline float SliderOptions::capinsetsy() const {
  return capinsetsy_;
}
inline void SliderOptions::set_capinsetsy(float value) {
  set_has_capinsetsy();
  capinsetsy_ = value;
}

// optional float capInsetsWidth = 15;
inline bool SliderOptions::has_capinsetswidth() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SliderOptions::set_has_capinsetswidth() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SliderOptions::clear_has_capinsetswidth() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SliderOptions::clear_capinsetswidth() {
  capinsetswidth_ = 0;
  clear_has_capinsetswidth();
}
inline float SliderOptions::capinsetswidth() const {
  return capinsetswidth_;
}
inline void SliderOptions::set_capinsetswidth(float value) {
  set_has_capinsetswidth();
  capinsetswidth_ = value;
}

// optional float capInsetsHeight = 16;
inline bool SliderOptions::has_capinsetsheight() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SliderOptions::set_has_capinsetsheight() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SliderOptions::clear_has_capinsetsheight() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SliderOptions::clear_capinsetsheight() {
  capinsetsheight_ = 0;
  clear_has_capinsetsheight();
}
inline float SliderOptions::capinsetsheight() const {
  return capinsetsheight_;
}
inline void SliderOptions::set_capinsetsheight(float value) {
  set_has_capinsetsheight();
  capinsetsheight_ = value;
}

// optional float barCapInsetsX = 17;
inline bool SliderOptions::has_barcapinsetsx() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SliderOptions::set_has_barcapinsetsx() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SliderOptions::clear_has_barcapinsetsx() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SliderOptions::clear_barcapinsetsx() {
  barcapinsetsx_ = 0;
  clear_has_barcapinsetsx();
}
inline float SliderOptions::barcapinsetsx() const {
  return barcapinsetsx_;
}
inline void SliderOptions::set_barcapinsetsx(float value) {
  set_has_barcapinsetsx();
  barcapinsetsx_ = value;
}

// optional float barCapInsetsY = 18;
inline bool SliderOptions::has_barcapinsetsy() const {
  return (_has_bits_[0] & 0x00020000u) != 0;
}
inline void SliderOptions::set_has_barcapinsetsy() {
  _has_bits_[0] |= 0x00020000u;
}
inline void SliderOptions::clear_has_barcapinsetsy() {
  _has_bits_[0] &= ~0x00020000u;
}
inline void SliderOptions::clear_barcapinsetsy() {
  barcapinsetsy_ = 0;
  clear_has_barcapinsetsy();
}
inline float SliderOptions::barcapinsetsy() const {
  return barcapinsetsy_;
}
inline void SliderOptions::set_barcapinsetsy(float value) {
  set_has_barcapinsetsy();
  barcapinsetsy_ = value;
}

// optional float barCapInsetsWidth = 19;
inline bool SliderOptions::has_barcapinsetswidth() const {
  return (_has_bits_[0] & 0x00040000u) != 0;
}
inline void SliderOptions::set_has_barcapinsetswidth() {
  _has_bits_[0] |= 0x00040000u;
}
inline void SliderOptions::clear_has_barcapinsetswidth() {
  _has_bits_[0] &= ~0x00040000u;
}
inline void SliderOptions::clear_barcapinsetswidth() {
  barcapinsetswidth_ = 0;
  clear_has_barcapinsetswidth();
}
inline float SliderOptions::barcapinsetswidth() const {
  return barcapinsetswidth_;
}
inline void SliderOptions::set_barcapinsetswidth(float value) {
  set_has_barcapinsetswidth();
  barcapinsetswidth_ = value;
}

// optional float barCapInsetsHeight = 20;
inline bool SliderOptions::has_barcapinsetsheight() const {
  return (_has_bits_[0] & 0x00080000u) != 0;
}
inline void SliderOptions::set_has_barcapinsetsheight() {
  _has_bits_[0] |= 0x00080000u;
}
inline void SliderOptions::clear_has_barcapinsetsheight() {
  _has_bits_[0] &= ~0x00080000u;
}
inline void SliderOptions::clear_barcapinsetsheight() {
  barcapinsetsheight_ = 0;
  clear_has_barcapinsetsheight();
}
inline float SliderOptions::barcapinsetsheight() const {
  return barcapinsetsheight_;
}
inline void SliderOptions::set_barcapinsetsheight(float value) {
  set_has_barcapinsetsheight();
  barcapinsetsheight_ = value;
}

// optional float progressBarCapInsetsX = 21;
inline bool SliderOptions::has_progressbarcapinsetsx() const {
  return (_has_bits_[0] & 0x00100000u) != 0;
}
inline void SliderOptions::set_has_progressbarcapinsetsx() {
  _has_bits_[0] |= 0x00100000u;
}
inline void SliderOptions::clear_has_progressbarcapinsetsx() {
  _has_bits_[0] &= ~0x00100000u;
}
inline void SliderOptions::clear_progressbarcapinsetsx() {
  progressbarcapinsetsx_ = 0;
  clear_has_progressbarcapinsetsx();
}
inline float SliderOptions::progressbarcapinsetsx() const {
  return progressbarcapinsetsx_;
}
inline void SliderOptions::set_progressbarcapinsetsx(float value) {
  set_has_progressbarcapinsetsx();
  progressbarcapinsetsx_ = value;
}

// optional float progressBarCapInsetsY = 22;
inline bool SliderOptions::has_progressbarcapinsetsy() const {
  return (_has_bits_[0] & 0x00200000u) != 0;
}
inline void SliderOptions::set_has_progressbarcapinsetsy() {
  _has_bits_[0] |= 0x00200000u;
}
inline void SliderOptions::clear_has_progressbarcapinsetsy() {
  _has_bits_[0] &= ~0x00200000u;
}
inline void SliderOptions::clear_progressbarcapinsetsy() {
  progressbarcapinsetsy_ = 0;
  clear_has_progressbarcapinsetsy();
}
inline float SliderOptions::progressbarcapinsetsy() const {
  return progressbarcapinsetsy_;
}
inline void SliderOptions::set_progressbarcapinsetsy(float value) {
  set_has_progressbarcapinsetsy();
  progressbarcapinsetsy_ = value;
}

// optional float progressBarCapInsetsWidth = 23;
inline bool SliderOptions::has_progressbarcapinsetswidth() const {
  return (_has_bits_[0] & 0x00400000u) != 0;
}
inline void SliderOptions::set_has_progressbarcapinsetswidth() {
  _has_bits_[0] |= 0x00400000u;
}
inline void SliderOptions::clear_has_progressbarcapinsetswidth() {
  _has_bits_[0] &= ~0x00400000u;
}
inline void SliderOptions::clear_progressbarcapinsetswidth() {
  progressbarcapinsetswidth_ = 0;
  clear_has_progressbarcapinsetswidth();
}
inline float SliderOptions::progressbarcapinsetswidth() const {
  return progressbarcapinsetswidth_;
}
inline void SliderOptions::set_progressbarcapinsetswidth(float value) {
  set_has_progressbarcapinsetswidth();
  progressbarcapinsetswidth_ = value;
}

// optional float progressBarCapInsetsHeight = 24;
inline bool SliderOptions::has_progressbarcapinsetsheight() const {
  return (_has_bits_[0] & 0x00800000u) != 0;
}
inline void SliderOptions::set_has_progressbarcapinsetsheight() {
  _has_bits_[0] |= 0x00800000u;
}
inline void SliderOptions::clear_has_progressbarcapinsetsheight() {
  _has_bits_[0] &= ~0x00800000u;
}
inline void SliderOptions::clear_progressbarcapinsetsheight() {
  progressbarcapinsetsheight_ = 0;
  clear_has_progressbarcapinsetsheight();
}
inline float SliderOptions::progressbarcapinsetsheight() const {
  return progressbarcapinsetsheight_;
}
inline void SliderOptions::set_progressbarcapinsetsheight(float value) {
  set_has_progressbarcapinsetsheight();
  progressbarcapinsetsheight_ = value;
}

// optional float scale9Width = 25;
inline bool SliderOptions::has_scale9width() const {
  return (_has_bits_[0] & 0x01000000u) != 0;
}
inline void SliderOptions::set_has_scale9width() {
  _has_bits_[0] |= 0x01000000u;
}
inline void SliderOptions::clear_has_scale9width() {
  _has_bits_[0] &= ~0x01000000u;
}
inline void SliderOptions::clear_scale9width() {
  scale9width_ = 0;
  clear_has_scale9width();
}
inline float SliderOptions::scale9width() const {
  return scale9width_;
}
inline void SliderOptions::set_scale9width(float value) {
  set_has_scale9width();
  scale9width_ = value;
}

// optional float scale9Height = 26;
inline bool SliderOptions::has_scale9height() const {
  return (_has_bits_[0] & 0x02000000u) != 0;
}
inline void SliderOptions::set_has_scale9height() {
  _has_bits_[0] |= 0x02000000u;
}
inline void SliderOptions::clear_has_scale9height() {
  _has_bits_[0] &= ~0x02000000u;
}
inline void SliderOptions::clear_scale9height() {
  scale9height_ = 0;
  clear_has_scale9height();
}
inline float SliderOptions::scale9height() const {
  return scale9height_;
}
inline void SliderOptions::set_scale9height(float value) {
  set_has_scale9height();
  scale9height_ = value;
}

// optional bool scale9Enable = 27;
inline bool SliderOptions::has_scale9enable() const {
  return (_has_bits_[0] & 0x04000000u) != 0;
}
inline void SliderOptions::set_has_scale9enable() {
  _has_bits_[0] |= 0x04000000u;
}
inline void SliderOptions::clear_has_scale9enable() {
  _has_bits_[0] &= ~0x04000000u;
}
inline void SliderOptions::clear_scale9enable() {
  scale9enable_ = false;
  clear_has_scale9enable();
}
inline bool SliderOptions::scale9enable() const {
  return scale9enable_;
}
inline void SliderOptions::set_scale9enable(bool value) {
  set_has_scale9enable();
  scale9enable_ = value;
}

// optional float slidBallAnchorPointX = 28;
inline bool SliderOptions::has_slidballanchorpointx() const {
  return (_has_bits_[0] & 0x08000000u) != 0;
}
inline void SliderOptions::set_has_slidballanchorpointx() {
  _has_bits_[0] |= 0x08000000u;
}
inline void SliderOptions::clear_has_slidballanchorpointx() {
  _has_bits_[0] &= ~0x08000000u;
}
inline void SliderOptions::clear_slidballanchorpointx() {
  slidballanchorpointx_ = 0;
  clear_has_slidballanchorpointx();
}
inline float SliderOptions::slidballanchorpointx() const {
  return slidballanchorpointx_;
}
inline void SliderOptions::set_slidballanchorpointx(float value) {
  set_has_slidballanchorpointx();
  slidballanchorpointx_ = value;
}

// optional float slidBallAnchorPointY = 29;
inline bool SliderOptions::has_slidballanchorpointy() const {
  return (_has_bits_[0] & 0x10000000u) != 0;
}
inline void SliderOptions::set_has_slidballanchorpointy() {
  _has_bits_[0] |= 0x10000000u;
}
inline void SliderOptions::clear_has_slidballanchorpointy() {
  _has_bits_[0] &= ~0x10000000u;
}
inline void SliderOptions::clear_slidballanchorpointy() {
  slidballanchorpointy_ = 0;
  clear_has_slidballanchorpointy();
}
inline float SliderOptions::slidballanchorpointy() const {
  return slidballanchorpointy_;
}
inline void SliderOptions::set_slidballanchorpointy(float value) {
  set_has_slidballanchorpointy();
  slidballanchorpointy_ = value;
}

// optional float length = 30;
inline bool SliderOptions::has_length() const {
  return (_has_bits_[0] & 0x20000000u) != 0;
}
inline void SliderOptions::set_has_length() {
  _has_bits_[0] |= 0x20000000u;
}
inline void SliderOptions::clear_has_length() {
  _has_bits_[0] &= ~0x20000000u;
}
inline void SliderOptions::clear_length() {
  length_ = 0;
  clear_has_length();
}
inline float SliderOptions::length() const {
  return length_;
}
inline void SliderOptions::set_length(float value) {
  set_has_length();
  length_ = value;
}

// optional bool displaystate = 31;
inline bool SliderOptions::has_displaystate() const {
  return (_has_bits_[0] & 0x40000000u) != 0;
}
inline void SliderOptions::set_has_displaystate() {
  _has_bits_[0] |= 0x40000000u;
}
inline void SliderOptions::clear_has_displaystate() {
  _has_bits_[0] &= ~0x40000000u;
}
inline void SliderOptions::clear_displaystate() {
  displaystate_ = false;
  clear_has_displaystate();
}
inline bool SliderOptions::displaystate() const {
  return displaystate_;
}
inline void SliderOptions::set_displaystate(bool value) {
  set_has_displaystate();
  displaystate_ = value;
}

// -------------------------------------------------------------------

// SpriteOptions

// optional string name = 1;
inline bool SpriteOptions::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void SpriteOptions::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void SpriteOptions::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void SpriteOptions::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& SpriteOptions::name() const {
  return *name_;
}
inline void SpriteOptions::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SpriteOptions::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void SpriteOptions::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpriteOptions::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* SpriteOptions::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpriteOptions::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classname = 2;
inline bool SpriteOptions::has_classname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void SpriteOptions::set_has_classname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void SpriteOptions::clear_has_classname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void SpriteOptions::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& SpriteOptions::classname() const {
  return *classname_;
}
inline void SpriteOptions::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void SpriteOptions::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void SpriteOptions::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpriteOptions::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* SpriteOptions::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpriteOptions::set_allocated_classname(::std::string* classname) {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (classname) {
    set_has_classname();
    classname_ = classname;
  } else {
    clear_has_classname();
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool touchAble = 3;
inline bool SpriteOptions::has_touchable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void SpriteOptions::set_has_touchable() {
  _has_bits_[0] |= 0x00000004u;
}
inline void SpriteOptions::clear_has_touchable() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void SpriteOptions::clear_touchable() {
  touchable_ = false;
  clear_has_touchable();
}
inline bool SpriteOptions::touchable() const {
  return touchable_;
}
inline void SpriteOptions::set_touchable(bool value) {
  set_has_touchable();
  touchable_ = value;
}

// optional int32 positionType = 4;
inline bool SpriteOptions::has_positiontype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void SpriteOptions::set_has_positiontype() {
  _has_bits_[0] |= 0x00000008u;
}
inline void SpriteOptions::clear_has_positiontype() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void SpriteOptions::clear_positiontype() {
  positiontype_ = 0;
  clear_has_positiontype();
}
inline ::google::protobuf::int32 SpriteOptions::positiontype() const {
  return positiontype_;
}
inline void SpriteOptions::set_positiontype(::google::protobuf::int32 value) {
  set_has_positiontype();
  positiontype_ = value;
}

// optional float positionPercentX = 5;
inline bool SpriteOptions::has_positionpercentx() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void SpriteOptions::set_has_positionpercentx() {
  _has_bits_[0] |= 0x00000010u;
}
inline void SpriteOptions::clear_has_positionpercentx() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void SpriteOptions::clear_positionpercentx() {
  positionpercentx_ = 0;
  clear_has_positionpercentx();
}
inline float SpriteOptions::positionpercentx() const {
  return positionpercentx_;
}
inline void SpriteOptions::set_positionpercentx(float value) {
  set_has_positionpercentx();
  positionpercentx_ = value;
}

// optional float positionPercentY = 6;
inline bool SpriteOptions::has_positionpercenty() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void SpriteOptions::set_has_positionpercenty() {
  _has_bits_[0] |= 0x00000020u;
}
inline void SpriteOptions::clear_has_positionpercenty() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void SpriteOptions::clear_positionpercenty() {
  positionpercenty_ = 0;
  clear_has_positionpercenty();
}
inline float SpriteOptions::positionpercenty() const {
  return positionpercenty_;
}
inline void SpriteOptions::set_positionpercenty(float value) {
  set_has_positionpercenty();
  positionpercenty_ = value;
}

// optional int32 sizeType = 7;
inline bool SpriteOptions::has_sizetype() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void SpriteOptions::set_has_sizetype() {
  _has_bits_[0] |= 0x00000040u;
}
inline void SpriteOptions::clear_has_sizetype() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void SpriteOptions::clear_sizetype() {
  sizetype_ = 0;
  clear_has_sizetype();
}
inline ::google::protobuf::int32 SpriteOptions::sizetype() const {
  return sizetype_;
}
inline void SpriteOptions::set_sizetype(::google::protobuf::int32 value) {
  set_has_sizetype();
  sizetype_ = value;
}

// optional float sizePercentX = 8;
inline bool SpriteOptions::has_sizepercentx() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void SpriteOptions::set_has_sizepercentx() {
  _has_bits_[0] |= 0x00000080u;
}
inline void SpriteOptions::clear_has_sizepercentx() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void SpriteOptions::clear_sizepercentx() {
  sizepercentx_ = 0;
  clear_has_sizepercentx();
}
inline float SpriteOptions::sizepercentx() const {
  return sizepercentx_;
}
inline void SpriteOptions::set_sizepercentx(float value) {
  set_has_sizepercentx();
  sizepercentx_ = value;
}

// optional float sizePercentY = 9;
inline bool SpriteOptions::has_sizepercenty() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void SpriteOptions::set_has_sizepercenty() {
  _has_bits_[0] |= 0x00000100u;
}
inline void SpriteOptions::clear_has_sizepercenty() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void SpriteOptions::clear_sizepercenty() {
  sizepercenty_ = 0;
  clear_has_sizepercenty();
}
inline float SpriteOptions::sizepercenty() const {
  return sizepercenty_;
}
inline void SpriteOptions::set_sizepercenty(float value) {
  set_has_sizepercenty();
  sizepercenty_ = value;
}

// optional bool useMergedTexture = 10;
inline bool SpriteOptions::has_usemergedtexture() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void SpriteOptions::set_has_usemergedtexture() {
  _has_bits_[0] |= 0x00000200u;
}
inline void SpriteOptions::clear_has_usemergedtexture() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void SpriteOptions::clear_usemergedtexture() {
  usemergedtexture_ = false;
  clear_has_usemergedtexture();
}
inline bool SpriteOptions::usemergedtexture() const {
  return usemergedtexture_;
}
inline void SpriteOptions::set_usemergedtexture(bool value) {
  set_has_usemergedtexture();
  usemergedtexture_ = value;
}

// optional bool ignoreSize = 11;
inline bool SpriteOptions::has_ignoresize() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void SpriteOptions::set_has_ignoresize() {
  _has_bits_[0] |= 0x00000400u;
}
inline void SpriteOptions::clear_has_ignoresize() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void SpriteOptions::clear_ignoresize() {
  ignoresize_ = false;
  clear_has_ignoresize();
}
inline bool SpriteOptions::ignoresize() const {
  return ignoresize_;
}
inline void SpriteOptions::set_ignoresize(bool value) {
  set_has_ignoresize();
  ignoresize_ = value;
}

// optional .protocolbuffers.LayoutParameter layoutParameter = 12;
inline bool SpriteOptions::has_layoutparameter() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void SpriteOptions::set_has_layoutparameter() {
  _has_bits_[0] |= 0x00000800u;
}
inline void SpriteOptions::clear_has_layoutparameter() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void SpriteOptions::clear_layoutparameter() {
  if (layoutparameter_ != NULL) layoutparameter_->::protocolbuffers::LayoutParameter::Clear();
  clear_has_layoutparameter();
}
inline const ::protocolbuffers::LayoutParameter& SpriteOptions::layoutparameter() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return layoutparameter_ != NULL ? *layoutparameter_ : *default_instance().layoutparameter_;
#else
  return layoutparameter_ != NULL ? *layoutparameter_ : *default_instance_->layoutparameter_;
#endif
}
inline ::protocolbuffers::LayoutParameter* SpriteOptions::mutable_layoutparameter() {
  set_has_layoutparameter();
  if (layoutparameter_ == NULL) layoutparameter_ = new ::protocolbuffers::LayoutParameter;
  return layoutparameter_;
}
inline ::protocolbuffers::LayoutParameter* SpriteOptions::release_layoutparameter() {
  clear_has_layoutparameter();
  ::protocolbuffers::LayoutParameter* temp = layoutparameter_;
  layoutparameter_ = NULL;
  return temp;
}
inline void SpriteOptions::set_allocated_layoutparameter(::protocolbuffers::LayoutParameter* layoutparameter) {
  delete layoutparameter_;
  layoutparameter_ = layoutparameter;
  if (layoutparameter) {
    set_has_layoutparameter();
  } else {
    clear_has_layoutparameter();
  }
}

// optional string customProperty = 13;
inline bool SpriteOptions::has_customproperty() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void SpriteOptions::set_has_customproperty() {
  _has_bits_[0] |= 0x00001000u;
}
inline void SpriteOptions::clear_has_customproperty() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void SpriteOptions::clear_customproperty() {
  if (customproperty_ != &::google::protobuf::internal::kEmptyString) {
    customproperty_->clear();
  }
  clear_has_customproperty();
}
inline const ::std::string& SpriteOptions::customproperty() const {
  return *customproperty_;
}
inline void SpriteOptions::set_customproperty(const ::std::string& value) {
  set_has_customproperty();
  if (customproperty_ == &::google::protobuf::internal::kEmptyString) {
    customproperty_ = new ::std::string;
  }
  customproperty_->assign(value);
}
inline void SpriteOptions::set_customproperty(const char* value) {
  set_has_customproperty();
  if (customproperty_ == &::google::protobuf::internal::kEmptyString) {
    customproperty_ = new ::std::string;
  }
  customproperty_->assign(value);
}
inline void SpriteOptions::set_customproperty(const char* value, size_t size) {
  set_has_customproperty();
  if (customproperty_ == &::google::protobuf::internal::kEmptyString) {
    customproperty_ = new ::std::string;
  }
  customproperty_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpriteOptions::mutable_customproperty() {
  set_has_customproperty();
  if (customproperty_ == &::google::protobuf::internal::kEmptyString) {
    customproperty_ = new ::std::string;
  }
  return customproperty_;
}
inline ::std::string* SpriteOptions::release_customproperty() {
  clear_has_customproperty();
  if (customproperty_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = customproperty_;
    customproperty_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpriteOptions::set_allocated_customproperty(::std::string* customproperty) {
  if (customproperty_ != &::google::protobuf::internal::kEmptyString) {
    delete customproperty_;
  }
  if (customproperty) {
    set_has_customproperty();
    customproperty_ = customproperty;
  } else {
    clear_has_customproperty();
    customproperty_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fileName = 14;
inline bool SpriteOptions::has_filename() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void SpriteOptions::set_has_filename() {
  _has_bits_[0] |= 0x00002000u;
}
inline void SpriteOptions::clear_has_filename() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void SpriteOptions::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& SpriteOptions::filename() const {
  return *filename_;
}
inline void SpriteOptions::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void SpriteOptions::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void SpriteOptions::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* SpriteOptions::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* SpriteOptions::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void SpriteOptions::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool flippedX = 15;
inline bool SpriteOptions::has_flippedx() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void SpriteOptions::set_has_flippedx() {
  _has_bits_[0] |= 0x00004000u;
}
inline void SpriteOptions::clear_has_flippedx() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void SpriteOptions::clear_flippedx() {
  flippedx_ = false;
  clear_has_flippedx();
}
inline bool SpriteOptions::flippedx() const {
  return flippedx_;
}
inline void SpriteOptions::set_flippedx(bool value) {
  set_has_flippedx();
  flippedx_ = value;
}

// optional bool flippedY = 16;
inline bool SpriteOptions::has_flippedy() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void SpriteOptions::set_has_flippedy() {
  _has_bits_[0] |= 0x00008000u;
}
inline void SpriteOptions::clear_has_flippedy() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void SpriteOptions::clear_flippedy() {
  flippedy_ = false;
  clear_has_flippedy();
}
inline bool SpriteOptions::flippedy() const {
  return flippedy_;
}
inline void SpriteOptions::set_flippedy(bool value) {
  set_has_flippedy();
  flippedy_ = value;
}

// optional .protocolbuffers.ResourceData fileNameData = 17;
inline bool SpriteOptions::has_filenamedata() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void SpriteOptions::set_has_filenamedata() {
  _has_bits_[0] |= 0x00010000u;
}
inline void SpriteOptions::clear_has_filenamedata() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void SpriteOptions::clear_filenamedata() {
  if (filenamedata_ != NULL) filenamedata_->::protocolbuffers::ResourceData::Clear();
  clear_has_filenamedata();
}
inline const ::protocolbuffers::ResourceData& SpriteOptions::filenamedata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return filenamedata_ != NULL ? *filenamedata_ : *default_instance().filenamedata_;
#else
  return filenamedata_ != NULL ? *filenamedata_ : *default_instance_->filenamedata_;
#endif
}
inline ::protocolbuffers::ResourceData* SpriteOptions::mutable_filenamedata() {
  set_has_filenamedata();
  if (filenamedata_ == NULL) filenamedata_ = new ::protocolbuffers::ResourceData;
  return filenamedata_;
}
inline ::protocolbuffers::ResourceData* SpriteOptions::release_filenamedata() {
  clear_has_filenamedata();
  ::protocolbuffers::ResourceData* temp = filenamedata_;
  filenamedata_ = NULL;
  return temp;
}
inline void SpriteOptions::set_allocated_filenamedata(::protocolbuffers::ResourceData* filenamedata) {
  delete filenamedata_;
  filenamedata_ = filenamedata;
  if (filenamedata) {
    set_has_filenamedata();
  } else {
    clear_has_filenamedata();
  }
}

// -------------------------------------------------------------------

// TextFieldOptions

// optional string name = 1;
inline bool TextFieldOptions::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TextFieldOptions::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TextFieldOptions::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TextFieldOptions::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TextFieldOptions::name() const {
  return *name_;
}
inline void TextFieldOptions::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TextFieldOptions::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TextFieldOptions::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextFieldOptions::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TextFieldOptions::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TextFieldOptions::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classname = 2;
inline bool TextFieldOptions::has_classname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TextFieldOptions::set_has_classname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TextFieldOptions::clear_has_classname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TextFieldOptions::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& TextFieldOptions::classname() const {
  return *classname_;
}
inline void TextFieldOptions::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void TextFieldOptions::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void TextFieldOptions::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextFieldOptions::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* TextFieldOptions::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TextFieldOptions::set_allocated_classname(::std::string* classname) {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (classname) {
    set_has_classname();
    classname_ = classname;
  } else {
    clear_has_classname();
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string fontName = 3;
inline bool TextFieldOptions::has_fontname() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TextFieldOptions::set_has_fontname() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TextFieldOptions::clear_has_fontname() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TextFieldOptions::clear_fontname() {
  if (fontname_ != &::google::protobuf::internal::kEmptyString) {
    fontname_->clear();
  }
  clear_has_fontname();
}
inline const ::std::string& TextFieldOptions::fontname() const {
  return *fontname_;
}
inline void TextFieldOptions::set_fontname(const ::std::string& value) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(value);
}
inline void TextFieldOptions::set_fontname(const char* value) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(value);
}
inline void TextFieldOptions::set_fontname(const char* value, size_t size) {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    fontname_ = new ::std::string;
  }
  fontname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextFieldOptions::mutable_fontname() {
  set_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    fontname_ = new ::std::string;
  }
  return fontname_;
}
inline ::std::string* TextFieldOptions::release_fontname() {
  clear_has_fontname();
  if (fontname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = fontname_;
    fontname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TextFieldOptions::set_allocated_fontname(::std::string* fontname) {
  if (fontname_ != &::google::protobuf::internal::kEmptyString) {
    delete fontname_;
  }
  if (fontname) {
    set_has_fontname();
    fontname_ = fontname;
  } else {
    clear_has_fontname();
    fontname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protocolbuffers.ResourceData fontFile = 4;
inline bool TextFieldOptions::has_fontfile() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TextFieldOptions::set_has_fontfile() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TextFieldOptions::clear_has_fontfile() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TextFieldOptions::clear_fontfile() {
  if (fontfile_ != NULL) fontfile_->::protocolbuffers::ResourceData::Clear();
  clear_has_fontfile();
}
inline const ::protocolbuffers::ResourceData& TextFieldOptions::fontfile() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fontfile_ != NULL ? *fontfile_ : *default_instance().fontfile_;
#else
  return fontfile_ != NULL ? *fontfile_ : *default_instance_->fontfile_;
#endif
}
inline ::protocolbuffers::ResourceData* TextFieldOptions::mutable_fontfile() {
  set_has_fontfile();
  if (fontfile_ == NULL) fontfile_ = new ::protocolbuffers::ResourceData;
  return fontfile_;
}
inline ::protocolbuffers::ResourceData* TextFieldOptions::release_fontfile() {
  clear_has_fontfile();
  ::protocolbuffers::ResourceData* temp = fontfile_;
  fontfile_ = NULL;
  return temp;
}
inline void TextFieldOptions::set_allocated_fontfile(::protocolbuffers::ResourceData* fontfile) {
  delete fontfile_;
  fontfile_ = fontfile;
  if (fontfile) {
    set_has_fontfile();
  } else {
    clear_has_fontfile();
  }
}

// optional int32 fontSize = 5;
inline bool TextFieldOptions::has_fontsize() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TextFieldOptions::set_has_fontsize() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TextFieldOptions::clear_has_fontsize() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TextFieldOptions::clear_fontsize() {
  fontsize_ = 0;
  clear_has_fontsize();
}
inline ::google::protobuf::int32 TextFieldOptions::fontsize() const {
  return fontsize_;
}
inline void TextFieldOptions::set_fontsize(::google::protobuf::int32 value) {
  set_has_fontsize();
  fontsize_ = value;
}

// optional string text = 6;
inline bool TextFieldOptions::has_text() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TextFieldOptions::set_has_text() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TextFieldOptions::clear_has_text() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TextFieldOptions::clear_text() {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    text_->clear();
  }
  clear_has_text();
}
inline const ::std::string& TextFieldOptions::text() const {
  return *text_;
}
inline void TextFieldOptions::set_text(const ::std::string& value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void TextFieldOptions::set_text(const char* value) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(value);
}
inline void TextFieldOptions::set_text(const char* value, size_t size) {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  text_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextFieldOptions::mutable_text() {
  set_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    text_ = new ::std::string;
  }
  return text_;
}
inline ::std::string* TextFieldOptions::release_text() {
  clear_has_text();
  if (text_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = text_;
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TextFieldOptions::set_allocated_text(::std::string* text) {
  if (text_ != &::google::protobuf::internal::kEmptyString) {
    delete text_;
  }
  if (text) {
    set_has_text();
    text_ = text;
  } else {
    clear_has_text();
    text_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string placeHolder = 7;
inline bool TextFieldOptions::has_placeholder() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TextFieldOptions::set_has_placeholder() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TextFieldOptions::clear_has_placeholder() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TextFieldOptions::clear_placeholder() {
  if (placeholder_ != &::google::protobuf::internal::kEmptyString) {
    placeholder_->clear();
  }
  clear_has_placeholder();
}
inline const ::std::string& TextFieldOptions::placeholder() const {
  return *placeholder_;
}
inline void TextFieldOptions::set_placeholder(const ::std::string& value) {
  set_has_placeholder();
  if (placeholder_ == &::google::protobuf::internal::kEmptyString) {
    placeholder_ = new ::std::string;
  }
  placeholder_->assign(value);
}
inline void TextFieldOptions::set_placeholder(const char* value) {
  set_has_placeholder();
  if (placeholder_ == &::google::protobuf::internal::kEmptyString) {
    placeholder_ = new ::std::string;
  }
  placeholder_->assign(value);
}
inline void TextFieldOptions::set_placeholder(const char* value, size_t size) {
  set_has_placeholder();
  if (placeholder_ == &::google::protobuf::internal::kEmptyString) {
    placeholder_ = new ::std::string;
  }
  placeholder_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextFieldOptions::mutable_placeholder() {
  set_has_placeholder();
  if (placeholder_ == &::google::protobuf::internal::kEmptyString) {
    placeholder_ = new ::std::string;
  }
  return placeholder_;
}
inline ::std::string* TextFieldOptions::release_placeholder() {
  clear_has_placeholder();
  if (placeholder_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = placeholder_;
    placeholder_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TextFieldOptions::set_allocated_placeholder(::std::string* placeholder) {
  if (placeholder_ != &::google::protobuf::internal::kEmptyString) {
    delete placeholder_;
  }
  if (placeholder) {
    set_has_placeholder();
    placeholder_ = placeholder;
  } else {
    clear_has_placeholder();
    placeholder_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool passwordEnable = 8;
inline bool TextFieldOptions::has_passwordenable() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TextFieldOptions::set_has_passwordenable() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TextFieldOptions::clear_has_passwordenable() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TextFieldOptions::clear_passwordenable() {
  passwordenable_ = false;
  clear_has_passwordenable();
}
inline bool TextFieldOptions::passwordenable() const {
  return passwordenable_;
}
inline void TextFieldOptions::set_passwordenable(bool value) {
  set_has_passwordenable();
  passwordenable_ = value;
}

// optional string passwordStyleText = 9;
inline bool TextFieldOptions::has_passwordstyletext() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TextFieldOptions::set_has_passwordstyletext() {
  _has_bits_[0] |= 0x00000100u;
}
inline void TextFieldOptions::clear_has_passwordstyletext() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void TextFieldOptions::clear_passwordstyletext() {
  if (passwordstyletext_ != &::google::protobuf::internal::kEmptyString) {
    passwordstyletext_->clear();
  }
  clear_has_passwordstyletext();
}
inline const ::std::string& TextFieldOptions::passwordstyletext() const {
  return *passwordstyletext_;
}
inline void TextFieldOptions::set_passwordstyletext(const ::std::string& value) {
  set_has_passwordstyletext();
  if (passwordstyletext_ == &::google::protobuf::internal::kEmptyString) {
    passwordstyletext_ = new ::std::string;
  }
  passwordstyletext_->assign(value);
}
inline void TextFieldOptions::set_passwordstyletext(const char* value) {
  set_has_passwordstyletext();
  if (passwordstyletext_ == &::google::protobuf::internal::kEmptyString) {
    passwordstyletext_ = new ::std::string;
  }
  passwordstyletext_->assign(value);
}
inline void TextFieldOptions::set_passwordstyletext(const char* value, size_t size) {
  set_has_passwordstyletext();
  if (passwordstyletext_ == &::google::protobuf::internal::kEmptyString) {
    passwordstyletext_ = new ::std::string;
  }
  passwordstyletext_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TextFieldOptions::mutable_passwordstyletext() {
  set_has_passwordstyletext();
  if (passwordstyletext_ == &::google::protobuf::internal::kEmptyString) {
    passwordstyletext_ = new ::std::string;
  }
  return passwordstyletext_;
}
inline ::std::string* TextFieldOptions::release_passwordstyletext() {
  clear_has_passwordstyletext();
  if (passwordstyletext_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = passwordstyletext_;
    passwordstyletext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TextFieldOptions::set_allocated_passwordstyletext(::std::string* passwordstyletext) {
  if (passwordstyletext_ != &::google::protobuf::internal::kEmptyString) {
    delete passwordstyletext_;
  }
  if (passwordstyletext) {
    set_has_passwordstyletext();
    passwordstyletext_ = passwordstyletext;
  } else {
    clear_has_passwordstyletext();
    passwordstyletext_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool maxLengthEnable = 10;
inline bool TextFieldOptions::has_maxlengthenable() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TextFieldOptions::set_has_maxlengthenable() {
  _has_bits_[0] |= 0x00000200u;
}
inline void TextFieldOptions::clear_has_maxlengthenable() {
  _has_bits_[0] &= ~0x00000200u;
}
inline void TextFieldOptions::clear_maxlengthenable() {
  maxlengthenable_ = false;
  clear_has_maxlengthenable();
}
inline bool TextFieldOptions::maxlengthenable() const {
  return maxlengthenable_;
}
inline void TextFieldOptions::set_maxlengthenable(bool value) {
  set_has_maxlengthenable();
  maxlengthenable_ = value;
}

// optional int32 maxLength = 11;
inline bool TextFieldOptions::has_maxlength() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TextFieldOptions::set_has_maxlength() {
  _has_bits_[0] |= 0x00000400u;
}
inline void TextFieldOptions::clear_has_maxlength() {
  _has_bits_[0] &= ~0x00000400u;
}
inline void TextFieldOptions::clear_maxlength() {
  maxlength_ = 0;
  clear_has_maxlength();
}
inline ::google::protobuf::int32 TextFieldOptions::maxlength() const {
  return maxlength_;
}
inline void TextFieldOptions::set_maxlength(::google::protobuf::int32 value) {
  set_has_maxlength();
  maxlength_ = value;
}

// optional float areaWidth = 12;
inline bool TextFieldOptions::has_areawidth() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TextFieldOptions::set_has_areawidth() {
  _has_bits_[0] |= 0x00000800u;
}
inline void TextFieldOptions::clear_has_areawidth() {
  _has_bits_[0] &= ~0x00000800u;
}
inline void TextFieldOptions::clear_areawidth() {
  areawidth_ = 0;
  clear_has_areawidth();
}
inline float TextFieldOptions::areawidth() const {
  return areawidth_;
}
inline void TextFieldOptions::set_areawidth(float value) {
  set_has_areawidth();
  areawidth_ = value;
}

// optional float areaHeight = 13;
inline bool TextFieldOptions::has_areaheight() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TextFieldOptions::set_has_areaheight() {
  _has_bits_[0] |= 0x00001000u;
}
inline void TextFieldOptions::clear_has_areaheight() {
  _has_bits_[0] &= ~0x00001000u;
}
inline void TextFieldOptions::clear_areaheight() {
  areaheight_ = 0;
  clear_has_areaheight();
}
inline float TextFieldOptions::areaheight() const {
  return areaheight_;
}
inline void TextFieldOptions::set_areaheight(float value) {
  set_has_areaheight();
  areaheight_ = value;
}

// optional float anchorPointX = 15;
inline bool TextFieldOptions::has_anchorpointx() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TextFieldOptions::set_has_anchorpointx() {
  _has_bits_[0] |= 0x00002000u;
}
inline void TextFieldOptions::clear_has_anchorpointx() {
  _has_bits_[0] &= ~0x00002000u;
}
inline void TextFieldOptions::clear_anchorpointx() {
  anchorpointx_ = 0;
  clear_has_anchorpointx();
}
inline float TextFieldOptions::anchorpointx() const {
  return anchorpointx_;
}
inline void TextFieldOptions::set_anchorpointx(float value) {
  set_has_anchorpointx();
  anchorpointx_ = value;
}

// optional float anchorPointY = 16;
inline bool TextFieldOptions::has_anchorpointy() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TextFieldOptions::set_has_anchorpointy() {
  _has_bits_[0] |= 0x00004000u;
}
inline void TextFieldOptions::clear_has_anchorpointy() {
  _has_bits_[0] &= ~0x00004000u;
}
inline void TextFieldOptions::clear_anchorpointy() {
  anchorpointy_ = 0;
  clear_has_anchorpointy();
}
inline float TextFieldOptions::anchorpointy() const {
  return anchorpointy_;
}
inline void TextFieldOptions::set_anchorpointy(float value) {
  set_has_anchorpointy();
  anchorpointy_ = value;
}

// optional .protocolbuffers.ResourceData fontResource = 14;
inline bool TextFieldOptions::has_fontresource() const {
  return (_has_bits_[0] & 0x00008000u) != 0;
}
inline void TextFieldOptions::set_has_fontresource() {
  _has_bits_[0] |= 0x00008000u;
}
inline void TextFieldOptions::clear_has_fontresource() {
  _has_bits_[0] &= ~0x00008000u;
}
inline void TextFieldOptions::clear_fontresource() {
  if (fontresource_ != NULL) fontresource_->::protocolbuffers::ResourceData::Clear();
  clear_has_fontresource();
}
inline const ::protocolbuffers::ResourceData& TextFieldOptions::fontresource() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return fontresource_ != NULL ? *fontresource_ : *default_instance().fontresource_;
#else
  return fontresource_ != NULL ? *fontresource_ : *default_instance_->fontresource_;
#endif
}
inline ::protocolbuffers::ResourceData* TextFieldOptions::mutable_fontresource() {
  set_has_fontresource();
  if (fontresource_ == NULL) fontresource_ = new ::protocolbuffers::ResourceData;
  return fontresource_;
}
inline ::protocolbuffers::ResourceData* TextFieldOptions::release_fontresource() {
  clear_has_fontresource();
  ::protocolbuffers::ResourceData* temp = fontresource_;
  fontresource_ = NULL;
  return temp;
}
inline void TextFieldOptions::set_allocated_fontresource(::protocolbuffers::ResourceData* fontresource) {
  delete fontresource_;
  fontresource_ = fontresource;
  if (fontresource) {
    set_has_fontresource();
  } else {
    clear_has_fontresource();
  }
}

// optional bool IsCustomSize = 17;
inline bool TextFieldOptions::has_iscustomsize() const {
  return (_has_bits_[0] & 0x00010000u) != 0;
}
inline void TextFieldOptions::set_has_iscustomsize() {
  _has_bits_[0] |= 0x00010000u;
}
inline void TextFieldOptions::clear_has_iscustomsize() {
  _has_bits_[0] &= ~0x00010000u;
}
inline void TextFieldOptions::clear_iscustomsize() {
  iscustomsize_ = false;
  clear_has_iscustomsize();
}
inline bool TextFieldOptions::iscustomsize() const {
  return iscustomsize_;
}
inline void TextFieldOptions::set_iscustomsize(bool value) {
  set_has_iscustomsize();
  iscustomsize_ = value;
}

// -------------------------------------------------------------------

// TMXTiledMapOptions

// optional string tmxFile = 1;
inline bool TMXTiledMapOptions::has_tmxfile() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TMXTiledMapOptions::set_has_tmxfile() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TMXTiledMapOptions::clear_has_tmxfile() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TMXTiledMapOptions::clear_tmxfile() {
  if (tmxfile_ != &::google::protobuf::internal::kEmptyString) {
    tmxfile_->clear();
  }
  clear_has_tmxfile();
}
inline const ::std::string& TMXTiledMapOptions::tmxfile() const {
  return *tmxfile_;
}
inline void TMXTiledMapOptions::set_tmxfile(const ::std::string& value) {
  set_has_tmxfile();
  if (tmxfile_ == &::google::protobuf::internal::kEmptyString) {
    tmxfile_ = new ::std::string;
  }
  tmxfile_->assign(value);
}
inline void TMXTiledMapOptions::set_tmxfile(const char* value) {
  set_has_tmxfile();
  if (tmxfile_ == &::google::protobuf::internal::kEmptyString) {
    tmxfile_ = new ::std::string;
  }
  tmxfile_->assign(value);
}
inline void TMXTiledMapOptions::set_tmxfile(const char* value, size_t size) {
  set_has_tmxfile();
  if (tmxfile_ == &::google::protobuf::internal::kEmptyString) {
    tmxfile_ = new ::std::string;
  }
  tmxfile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMXTiledMapOptions::mutable_tmxfile() {
  set_has_tmxfile();
  if (tmxfile_ == &::google::protobuf::internal::kEmptyString) {
    tmxfile_ = new ::std::string;
  }
  return tmxfile_;
}
inline ::std::string* TMXTiledMapOptions::release_tmxfile() {
  clear_has_tmxfile();
  if (tmxfile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tmxfile_;
    tmxfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMXTiledMapOptions::set_allocated_tmxfile(::std::string* tmxfile) {
  if (tmxfile_ != &::google::protobuf::internal::kEmptyString) {
    delete tmxfile_;
  }
  if (tmxfile) {
    set_has_tmxfile();
    tmxfile_ = tmxfile;
  } else {
    clear_has_tmxfile();
    tmxfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string tmxString = 2;
inline bool TMXTiledMapOptions::has_tmxstring() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TMXTiledMapOptions::set_has_tmxstring() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TMXTiledMapOptions::clear_has_tmxstring() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TMXTiledMapOptions::clear_tmxstring() {
  if (tmxstring_ != &::google::protobuf::internal::kEmptyString) {
    tmxstring_->clear();
  }
  clear_has_tmxstring();
}
inline const ::std::string& TMXTiledMapOptions::tmxstring() const {
  return *tmxstring_;
}
inline void TMXTiledMapOptions::set_tmxstring(const ::std::string& value) {
  set_has_tmxstring();
  if (tmxstring_ == &::google::protobuf::internal::kEmptyString) {
    tmxstring_ = new ::std::string;
  }
  tmxstring_->assign(value);
}
inline void TMXTiledMapOptions::set_tmxstring(const char* value) {
  set_has_tmxstring();
  if (tmxstring_ == &::google::protobuf::internal::kEmptyString) {
    tmxstring_ = new ::std::string;
  }
  tmxstring_->assign(value);
}
inline void TMXTiledMapOptions::set_tmxstring(const char* value, size_t size) {
  set_has_tmxstring();
  if (tmxstring_ == &::google::protobuf::internal::kEmptyString) {
    tmxstring_ = new ::std::string;
  }
  tmxstring_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMXTiledMapOptions::mutable_tmxstring() {
  set_has_tmxstring();
  if (tmxstring_ == &::google::protobuf::internal::kEmptyString) {
    tmxstring_ = new ::std::string;
  }
  return tmxstring_;
}
inline ::std::string* TMXTiledMapOptions::release_tmxstring() {
  clear_has_tmxstring();
  if (tmxstring_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = tmxstring_;
    tmxstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMXTiledMapOptions::set_allocated_tmxstring(::std::string* tmxstring) {
  if (tmxstring_ != &::google::protobuf::internal::kEmptyString) {
    delete tmxstring_;
  }
  if (tmxstring) {
    set_has_tmxstring();
    tmxstring_ = tmxstring;
  } else {
    clear_has_tmxstring();
    tmxstring_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string resourcePath = 3;
inline bool TMXTiledMapOptions::has_resourcepath() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TMXTiledMapOptions::set_has_resourcepath() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TMXTiledMapOptions::clear_has_resourcepath() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TMXTiledMapOptions::clear_resourcepath() {
  if (resourcepath_ != &::google::protobuf::internal::kEmptyString) {
    resourcepath_->clear();
  }
  clear_has_resourcepath();
}
inline const ::std::string& TMXTiledMapOptions::resourcepath() const {
  return *resourcepath_;
}
inline void TMXTiledMapOptions::set_resourcepath(const ::std::string& value) {
  set_has_resourcepath();
  if (resourcepath_ == &::google::protobuf::internal::kEmptyString) {
    resourcepath_ = new ::std::string;
  }
  resourcepath_->assign(value);
}
inline void TMXTiledMapOptions::set_resourcepath(const char* value) {
  set_has_resourcepath();
  if (resourcepath_ == &::google::protobuf::internal::kEmptyString) {
    resourcepath_ = new ::std::string;
  }
  resourcepath_->assign(value);
}
inline void TMXTiledMapOptions::set_resourcepath(const char* value, size_t size) {
  set_has_resourcepath();
  if (resourcepath_ == &::google::protobuf::internal::kEmptyString) {
    resourcepath_ = new ::std::string;
  }
  resourcepath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TMXTiledMapOptions::mutable_resourcepath() {
  set_has_resourcepath();
  if (resourcepath_ == &::google::protobuf::internal::kEmptyString) {
    resourcepath_ = new ::std::string;
  }
  return resourcepath_;
}
inline ::std::string* TMXTiledMapOptions::release_resourcepath() {
  clear_has_resourcepath();
  if (resourcepath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = resourcepath_;
    resourcepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TMXTiledMapOptions::set_allocated_resourcepath(::std::string* resourcepath) {
  if (resourcepath_ != &::google::protobuf::internal::kEmptyString) {
    delete resourcepath_;
  }
  if (resourcepath) {
    set_has_resourcepath();
    resourcepath_ = resourcepath;
  } else {
    clear_has_resourcepath();
    resourcepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protocolbuffers.ResourceData fileNameData = 4;
inline bool TMXTiledMapOptions::has_filenamedata() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TMXTiledMapOptions::set_has_filenamedata() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TMXTiledMapOptions::clear_has_filenamedata() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TMXTiledMapOptions::clear_filenamedata() {
  if (filenamedata_ != NULL) filenamedata_->::protocolbuffers::ResourceData::Clear();
  clear_has_filenamedata();
}
inline const ::protocolbuffers::ResourceData& TMXTiledMapOptions::filenamedata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return filenamedata_ != NULL ? *filenamedata_ : *default_instance().filenamedata_;
#else
  return filenamedata_ != NULL ? *filenamedata_ : *default_instance_->filenamedata_;
#endif
}
inline ::protocolbuffers::ResourceData* TMXTiledMapOptions::mutable_filenamedata() {
  set_has_filenamedata();
  if (filenamedata_ == NULL) filenamedata_ = new ::protocolbuffers::ResourceData;
  return filenamedata_;
}
inline ::protocolbuffers::ResourceData* TMXTiledMapOptions::release_filenamedata() {
  clear_has_filenamedata();
  ::protocolbuffers::ResourceData* temp = filenamedata_;
  filenamedata_ = NULL;
  return temp;
}
inline void TMXTiledMapOptions::set_allocated_filenamedata(::protocolbuffers::ResourceData* filenamedata) {
  delete filenamedata_;
  filenamedata_ = filenamedata;
  if (filenamedata) {
    set_has_filenamedata();
  } else {
    clear_has_filenamedata();
  }
}

// -------------------------------------------------------------------

// ParticleSystemOptions

// optional string plistFile = 1;
inline bool ParticleSystemOptions::has_plistfile() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ParticleSystemOptions::set_has_plistfile() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ParticleSystemOptions::clear_has_plistfile() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ParticleSystemOptions::clear_plistfile() {
  if (plistfile_ != &::google::protobuf::internal::kEmptyString) {
    plistfile_->clear();
  }
  clear_has_plistfile();
}
inline const ::std::string& ParticleSystemOptions::plistfile() const {
  return *plistfile_;
}
inline void ParticleSystemOptions::set_plistfile(const ::std::string& value) {
  set_has_plistfile();
  if (plistfile_ == &::google::protobuf::internal::kEmptyString) {
    plistfile_ = new ::std::string;
  }
  plistfile_->assign(value);
}
inline void ParticleSystemOptions::set_plistfile(const char* value) {
  set_has_plistfile();
  if (plistfile_ == &::google::protobuf::internal::kEmptyString) {
    plistfile_ = new ::std::string;
  }
  plistfile_->assign(value);
}
inline void ParticleSystemOptions::set_plistfile(const char* value, size_t size) {
  set_has_plistfile();
  if (plistfile_ == &::google::protobuf::internal::kEmptyString) {
    plistfile_ = new ::std::string;
  }
  plistfile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ParticleSystemOptions::mutable_plistfile() {
  set_has_plistfile();
  if (plistfile_ == &::google::protobuf::internal::kEmptyString) {
    plistfile_ = new ::std::string;
  }
  return plistfile_;
}
inline ::std::string* ParticleSystemOptions::release_plistfile() {
  clear_has_plistfile();
  if (plistfile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = plistfile_;
    plistfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ParticleSystemOptions::set_allocated_plistfile(::std::string* plistfile) {
  if (plistfile_ != &::google::protobuf::internal::kEmptyString) {
    delete plistfile_;
  }
  if (plistfile) {
    set_has_plistfile();
    plistfile_ = plistfile;
  } else {
    clear_has_plistfile();
    plistfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 totalParticles = 2;
inline bool ParticleSystemOptions::has_totalparticles() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ParticleSystemOptions::set_has_totalparticles() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ParticleSystemOptions::clear_has_totalparticles() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ParticleSystemOptions::clear_totalparticles() {
  totalparticles_ = 0;
  clear_has_totalparticles();
}
inline ::google::protobuf::int32 ParticleSystemOptions::totalparticles() const {
  return totalparticles_;
}
inline void ParticleSystemOptions::set_totalparticles(::google::protobuf::int32 value) {
  set_has_totalparticles();
  totalparticles_ = value;
}

// optional .protocolbuffers.ResourceData fileNameData = 3;
inline bool ParticleSystemOptions::has_filenamedata() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ParticleSystemOptions::set_has_filenamedata() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ParticleSystemOptions::clear_has_filenamedata() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ParticleSystemOptions::clear_filenamedata() {
  if (filenamedata_ != NULL) filenamedata_->::protocolbuffers::ResourceData::Clear();
  clear_has_filenamedata();
}
inline const ::protocolbuffers::ResourceData& ParticleSystemOptions::filenamedata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return filenamedata_ != NULL ? *filenamedata_ : *default_instance().filenamedata_;
#else
  return filenamedata_ != NULL ? *filenamedata_ : *default_instance_->filenamedata_;
#endif
}
inline ::protocolbuffers::ResourceData* ParticleSystemOptions::mutable_filenamedata() {
  set_has_filenamedata();
  if (filenamedata_ == NULL) filenamedata_ = new ::protocolbuffers::ResourceData;
  return filenamedata_;
}
inline ::protocolbuffers::ResourceData* ParticleSystemOptions::release_filenamedata() {
  clear_has_filenamedata();
  ::protocolbuffers::ResourceData* temp = filenamedata_;
  filenamedata_ = NULL;
  return temp;
}
inline void ParticleSystemOptions::set_allocated_filenamedata(::protocolbuffers::ResourceData* filenamedata) {
  delete filenamedata_;
  filenamedata_ = filenamedata;
  if (filenamedata) {
    set_has_filenamedata();
  } else {
    clear_has_filenamedata();
  }
}

// -------------------------------------------------------------------

// ProjectNodeOptions

// optional string fileName = 1;
inline bool ProjectNodeOptions::has_filename() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ProjectNodeOptions::set_has_filename() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ProjectNodeOptions::clear_has_filename() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ProjectNodeOptions::clear_filename() {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    filename_->clear();
  }
  clear_has_filename();
}
inline const ::std::string& ProjectNodeOptions::filename() const {
  return *filename_;
}
inline void ProjectNodeOptions::set_filename(const ::std::string& value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void ProjectNodeOptions::set_filename(const char* value) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(value);
}
inline void ProjectNodeOptions::set_filename(const char* value, size_t size) {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  filename_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ProjectNodeOptions::mutable_filename() {
  set_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    filename_ = new ::std::string;
  }
  return filename_;
}
inline ::std::string* ProjectNodeOptions::release_filename() {
  clear_has_filename();
  if (filename_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filename_;
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ProjectNodeOptions::set_allocated_filename(::std::string* filename) {
  if (filename_ != &::google::protobuf::internal::kEmptyString) {
    delete filename_;
  }
  if (filename) {
    set_has_filename();
    filename_ = filename;
  } else {
    clear_has_filename();
    filename_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// ComponentOptions

// optional string type = 1;
inline bool ComponentOptions::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ComponentOptions::set_has_type() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ComponentOptions::clear_has_type() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ComponentOptions::clear_type() {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    type_->clear();
  }
  clear_has_type();
}
inline const ::std::string& ComponentOptions::type() const {
  return *type_;
}
inline void ComponentOptions::set_type(const ::std::string& value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void ComponentOptions::set_type(const char* value) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(value);
}
inline void ComponentOptions::set_type(const char* value, size_t size) {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  type_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComponentOptions::mutable_type() {
  set_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    type_ = new ::std::string;
  }
  return type_;
}
inline ::std::string* ComponentOptions::release_type() {
  clear_has_type();
  if (type_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = type_;
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ComponentOptions::set_allocated_type(::std::string* type) {
  if (type_ != &::google::protobuf::internal::kEmptyString) {
    delete type_;
  }
  if (type) {
    set_has_type();
    type_ = type;
  } else {
    clear_has_type();
    type_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional .protocolbuffers.ComAudioOptions comAudioOptions = 2;
inline bool ComponentOptions::has_comaudiooptions() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ComponentOptions::set_has_comaudiooptions() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ComponentOptions::clear_has_comaudiooptions() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ComponentOptions::clear_comaudiooptions() {
  if (comaudiooptions_ != NULL) comaudiooptions_->::protocolbuffers::ComAudioOptions::Clear();
  clear_has_comaudiooptions();
}
inline const ::protocolbuffers::ComAudioOptions& ComponentOptions::comaudiooptions() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return comaudiooptions_ != NULL ? *comaudiooptions_ : *default_instance().comaudiooptions_;
#else
  return comaudiooptions_ != NULL ? *comaudiooptions_ : *default_instance_->comaudiooptions_;
#endif
}
inline ::protocolbuffers::ComAudioOptions* ComponentOptions::mutable_comaudiooptions() {
  set_has_comaudiooptions();
  if (comaudiooptions_ == NULL) comaudiooptions_ = new ::protocolbuffers::ComAudioOptions;
  return comaudiooptions_;
}
inline ::protocolbuffers::ComAudioOptions* ComponentOptions::release_comaudiooptions() {
  clear_has_comaudiooptions();
  ::protocolbuffers::ComAudioOptions* temp = comaudiooptions_;
  comaudiooptions_ = NULL;
  return temp;
}
inline void ComponentOptions::set_allocated_comaudiooptions(::protocolbuffers::ComAudioOptions* comaudiooptions) {
  delete comaudiooptions_;
  comaudiooptions_ = comaudiooptions;
  if (comaudiooptions) {
    set_has_comaudiooptions();
  } else {
    clear_has_comaudiooptions();
  }
}

// -------------------------------------------------------------------

// ComAudioOptions

// optional string name = 1;
inline bool ComAudioOptions::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ComAudioOptions::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void ComAudioOptions::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void ComAudioOptions::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& ComAudioOptions::name() const {
  return *name_;
}
inline void ComAudioOptions::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ComAudioOptions::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void ComAudioOptions::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* ComAudioOptions::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* ComAudioOptions::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void ComAudioOptions::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional bool enabled = 2;
inline bool ComAudioOptions::has_enabled() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ComAudioOptions::set_has_enabled() {
  _has_bits_[0] |= 0x00000002u;
}
inline void ComAudioOptions::clear_has_enabled() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void ComAudioOptions::clear_enabled() {
  enabled_ = false;
  clear_has_enabled();
}
inline bool ComAudioOptions::enabled() const {
  return enabled_;
}
inline void ComAudioOptions::set_enabled(bool value) {
  set_has_enabled();
  enabled_ = value;
}

// optional bool loop = 3;
inline bool ComAudioOptions::has_loop() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ComAudioOptions::set_has_loop() {
  _has_bits_[0] |= 0x00000004u;
}
inline void ComAudioOptions::clear_has_loop() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void ComAudioOptions::clear_loop() {
  loop_ = false;
  clear_has_loop();
}
inline bool ComAudioOptions::loop() const {
  return loop_;
}
inline void ComAudioOptions::set_loop(bool value) {
  set_has_loop();
  loop_ = value;
}

// optional int32 volume = 4;
inline bool ComAudioOptions::has_volume() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ComAudioOptions::set_has_volume() {
  _has_bits_[0] |= 0x00000008u;
}
inline void ComAudioOptions::clear_has_volume() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void ComAudioOptions::clear_volume() {
  volume_ = 0;
  clear_has_volume();
}
inline ::google::protobuf::int32 ComAudioOptions::volume() const {
  return volume_;
}
inline void ComAudioOptions::set_volume(::google::protobuf::int32 value) {
  set_has_volume();
  volume_ = value;
}

// optional .protocolbuffers.ResourceData fileNameData = 5;
inline bool ComAudioOptions::has_filenamedata() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ComAudioOptions::set_has_filenamedata() {
  _has_bits_[0] |= 0x00000010u;
}
inline void ComAudioOptions::clear_has_filenamedata() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void ComAudioOptions::clear_filenamedata() {
  if (filenamedata_ != NULL) filenamedata_->::protocolbuffers::ResourceData::Clear();
  clear_has_filenamedata();
}
inline const ::protocolbuffers::ResourceData& ComAudioOptions::filenamedata() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return filenamedata_ != NULL ? *filenamedata_ : *default_instance().filenamedata_;
#else
  return filenamedata_ != NULL ? *filenamedata_ : *default_instance_->filenamedata_;
#endif
}
inline ::protocolbuffers::ResourceData* ComAudioOptions::mutable_filenamedata() {
  set_has_filenamedata();
  if (filenamedata_ == NULL) filenamedata_ = new ::protocolbuffers::ResourceData;
  return filenamedata_;
}
inline ::protocolbuffers::ResourceData* ComAudioOptions::release_filenamedata() {
  clear_has_filenamedata();
  ::protocolbuffers::ResourceData* temp = filenamedata_;
  filenamedata_ = NULL;
  return temp;
}
inline void ComAudioOptions::set_allocated_filenamedata(::protocolbuffers::ResourceData* filenamedata) {
  delete filenamedata_;
  filenamedata_ = filenamedata;
  if (filenamedata) {
    set_has_filenamedata();
  } else {
    clear_has_filenamedata();
  }
}

// -------------------------------------------------------------------

// NodeAction

// optional string name = 1;
inline bool NodeAction::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NodeAction::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void NodeAction::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void NodeAction::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& NodeAction::name() const {
  return *name_;
}
inline void NodeAction::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NodeAction::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void NodeAction::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeAction::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* NodeAction::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeAction::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classname = 2;
inline bool NodeAction::has_classname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void NodeAction::set_has_classname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void NodeAction::clear_has_classname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void NodeAction::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& NodeAction::classname() const {
  return *classname_;
}
inline void NodeAction::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void NodeAction::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void NodeAction::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* NodeAction::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* NodeAction::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void NodeAction::set_allocated_classname(::std::string* classname) {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (classname) {
    set_has_classname();
    classname_ = classname;
  } else {
    clear_has_classname();
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 duration = 3;
inline bool NodeAction::has_duration() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void NodeAction::set_has_duration() {
  _has_bits_[0] |= 0x00000004u;
}
inline void NodeAction::clear_has_duration() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void NodeAction::clear_duration() {
  duration_ = 0;
  clear_has_duration();
}
inline ::google::protobuf::int32 NodeAction::duration() const {
  return duration_;
}
inline void NodeAction::set_duration(::google::protobuf::int32 value) {
  set_has_duration();
  duration_ = value;
}

// optional float speed = 4;
inline bool NodeAction::has_speed() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void NodeAction::set_has_speed() {
  _has_bits_[0] |= 0x00000008u;
}
inline void NodeAction::clear_has_speed() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void NodeAction::clear_speed() {
  speed_ = 0;
  clear_has_speed();
}
inline float NodeAction::speed() const {
  return speed_;
}
inline void NodeAction::set_speed(float value) {
  set_has_speed();
  speed_ = value;
}

// repeated .protocolbuffers.TimeLine timelines = 5;
inline int NodeAction::timelines_size() const {
  return timelines_.size();
}
inline void NodeAction::clear_timelines() {
  timelines_.Clear();
}
inline const ::protocolbuffers::TimeLine& NodeAction::timelines(int index) const {
  return timelines_.Get(index);
}
inline ::protocolbuffers::TimeLine* NodeAction::mutable_timelines(int index) {
  return timelines_.Mutable(index);
}
inline ::protocolbuffers::TimeLine* NodeAction::add_timelines() {
  return timelines_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocolbuffers::TimeLine >&
NodeAction::timelines() const {
  return timelines_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocolbuffers::TimeLine >*
NodeAction::mutable_timelines() {
  return &timelines_;
}

// -------------------------------------------------------------------

// TimeLine

// optional string name = 1;
inline bool TimeLine::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeLine::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeLine::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeLine::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TimeLine::name() const {
  return *name_;
}
inline void TimeLine::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TimeLine::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TimeLine::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimeLine::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TimeLine::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimeLine::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classname = 2;
inline bool TimeLine::has_classname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeLine::set_has_classname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeLine::clear_has_classname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeLine::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& TimeLine::classname() const {
  return *classname_;
}
inline void TimeLine::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void TimeLine::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void TimeLine::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimeLine::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* TimeLine::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimeLine::set_allocated_classname(::std::string* classname) {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (classname) {
    set_has_classname();
    classname_ = classname;
  } else {
    clear_has_classname();
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string frameType = 3;
inline bool TimeLine::has_frametype() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimeLine::set_has_frametype() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimeLine::clear_has_frametype() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimeLine::clear_frametype() {
  if (frametype_ != &::google::protobuf::internal::kEmptyString) {
    frametype_->clear();
  }
  clear_has_frametype();
}
inline const ::std::string& TimeLine::frametype() const {
  return *frametype_;
}
inline void TimeLine::set_frametype(const ::std::string& value) {
  set_has_frametype();
  if (frametype_ == &::google::protobuf::internal::kEmptyString) {
    frametype_ = new ::std::string;
  }
  frametype_->assign(value);
}
inline void TimeLine::set_frametype(const char* value) {
  set_has_frametype();
  if (frametype_ == &::google::protobuf::internal::kEmptyString) {
    frametype_ = new ::std::string;
  }
  frametype_->assign(value);
}
inline void TimeLine::set_frametype(const char* value, size_t size) {
  set_has_frametype();
  if (frametype_ == &::google::protobuf::internal::kEmptyString) {
    frametype_ = new ::std::string;
  }
  frametype_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimeLine::mutable_frametype() {
  set_has_frametype();
  if (frametype_ == &::google::protobuf::internal::kEmptyString) {
    frametype_ = new ::std::string;
  }
  return frametype_;
}
inline ::std::string* TimeLine::release_frametype() {
  clear_has_frametype();
  if (frametype_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = frametype_;
    frametype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimeLine::set_allocated_frametype(::std::string* frametype) {
  if (frametype_ != &::google::protobuf::internal::kEmptyString) {
    delete frametype_;
  }
  if (frametype) {
    set_has_frametype();
    frametype_ = frametype;
  } else {
    clear_has_frametype();
    frametype_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 actionTag = 4;
inline bool TimeLine::has_actiontag() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TimeLine::set_has_actiontag() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TimeLine::clear_has_actiontag() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TimeLine::clear_actiontag() {
  actiontag_ = 0;
  clear_has_actiontag();
}
inline ::google::protobuf::int32 TimeLine::actiontag() const {
  return actiontag_;
}
inline void TimeLine::set_actiontag(::google::protobuf::int32 value) {
  set_has_actiontag();
  actiontag_ = value;
}

// repeated .protocolbuffers.Frame frames = 5;
inline int TimeLine::frames_size() const {
  return frames_.size();
}
inline void TimeLine::clear_frames() {
  frames_.Clear();
}
inline const ::protocolbuffers::Frame& TimeLine::frames(int index) const {
  return frames_.Get(index);
}
inline ::protocolbuffers::Frame* TimeLine::mutable_frames(int index) {
  return frames_.Mutable(index);
}
inline ::protocolbuffers::Frame* TimeLine::add_frames() {
  return frames_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::protocolbuffers::Frame >&
TimeLine::frames() const {
  return frames_;
}
inline ::google::protobuf::RepeatedPtrField< ::protocolbuffers::Frame >*
TimeLine::mutable_frames() {
  return &frames_;
}

// -------------------------------------------------------------------

// Frame

// optional .protocolbuffers.TimeLineBoolFrame visibleFrame = 5;
inline bool Frame::has_visibleframe() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Frame::set_has_visibleframe() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Frame::clear_has_visibleframe() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Frame::clear_visibleframe() {
  if (visibleframe_ != NULL) visibleframe_->::protocolbuffers::TimeLineBoolFrame::Clear();
  clear_has_visibleframe();
}
inline const ::protocolbuffers::TimeLineBoolFrame& Frame::visibleframe() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return visibleframe_ != NULL ? *visibleframe_ : *default_instance().visibleframe_;
#else
  return visibleframe_ != NULL ? *visibleframe_ : *default_instance_->visibleframe_;
#endif
}
inline ::protocolbuffers::TimeLineBoolFrame* Frame::mutable_visibleframe() {
  set_has_visibleframe();
  if (visibleframe_ == NULL) visibleframe_ = new ::protocolbuffers::TimeLineBoolFrame;
  return visibleframe_;
}
inline ::protocolbuffers::TimeLineBoolFrame* Frame::release_visibleframe() {
  clear_has_visibleframe();
  ::protocolbuffers::TimeLineBoolFrame* temp = visibleframe_;
  visibleframe_ = NULL;
  return temp;
}
inline void Frame::set_allocated_visibleframe(::protocolbuffers::TimeLineBoolFrame* visibleframe) {
  delete visibleframe_;
  visibleframe_ = visibleframe;
  if (visibleframe) {
    set_has_visibleframe();
  } else {
    clear_has_visibleframe();
  }
}

// optional .protocolbuffers.TimeLineIntFrame zOrderFrame = 6;
inline bool Frame::has_zorderframe() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Frame::set_has_zorderframe() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Frame::clear_has_zorderframe() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Frame::clear_zorderframe() {
  if (zorderframe_ != NULL) zorderframe_->::protocolbuffers::TimeLineIntFrame::Clear();
  clear_has_zorderframe();
}
inline const ::protocolbuffers::TimeLineIntFrame& Frame::zorderframe() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return zorderframe_ != NULL ? *zorderframe_ : *default_instance().zorderframe_;
#else
  return zorderframe_ != NULL ? *zorderframe_ : *default_instance_->zorderframe_;
#endif
}
inline ::protocolbuffers::TimeLineIntFrame* Frame::mutable_zorderframe() {
  set_has_zorderframe();
  if (zorderframe_ == NULL) zorderframe_ = new ::protocolbuffers::TimeLineIntFrame;
  return zorderframe_;
}
inline ::protocolbuffers::TimeLineIntFrame* Frame::release_zorderframe() {
  clear_has_zorderframe();
  ::protocolbuffers::TimeLineIntFrame* temp = zorderframe_;
  zorderframe_ = NULL;
  return temp;
}
inline void Frame::set_allocated_zorderframe(::protocolbuffers::TimeLineIntFrame* zorderframe) {
  delete zorderframe_;
  zorderframe_ = zorderframe;
  if (zorderframe) {
    set_has_zorderframe();
  } else {
    clear_has_zorderframe();
  }
}

// optional .protocolbuffers.TimeLinePointFrame rotationSkewFrame = 7;
inline bool Frame::has_rotationskewframe() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Frame::set_has_rotationskewframe() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Frame::clear_has_rotationskewframe() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Frame::clear_rotationskewframe() {
  if (rotationskewframe_ != NULL) rotationskewframe_->::protocolbuffers::TimeLinePointFrame::Clear();
  clear_has_rotationskewframe();
}
inline const ::protocolbuffers::TimeLinePointFrame& Frame::rotationskewframe() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return rotationskewframe_ != NULL ? *rotationskewframe_ : *default_instance().rotationskewframe_;
#else
  return rotationskewframe_ != NULL ? *rotationskewframe_ : *default_instance_->rotationskewframe_;
#endif
}
inline ::protocolbuffers::TimeLinePointFrame* Frame::mutable_rotationskewframe() {
  set_has_rotationskewframe();
  if (rotationskewframe_ == NULL) rotationskewframe_ = new ::protocolbuffers::TimeLinePointFrame;
  return rotationskewframe_;
}
inline ::protocolbuffers::TimeLinePointFrame* Frame::release_rotationskewframe() {
  clear_has_rotationskewframe();
  ::protocolbuffers::TimeLinePointFrame* temp = rotationskewframe_;
  rotationskewframe_ = NULL;
  return temp;
}
inline void Frame::set_allocated_rotationskewframe(::protocolbuffers::TimeLinePointFrame* rotationskewframe) {
  delete rotationskewframe_;
  rotationskewframe_ = rotationskewframe;
  if (rotationskewframe) {
    set_has_rotationskewframe();
  } else {
    clear_has_rotationskewframe();
  }
}

// optional .protocolbuffers.TimeLineStringFrame eventFrame = 8;
inline bool Frame::has_eventframe() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void Frame::set_has_eventframe() {
  _has_bits_[0] |= 0x00000008u;
}
inline void Frame::clear_has_eventframe() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void Frame::clear_eventframe() {
  if (eventframe_ != NULL) eventframe_->::protocolbuffers::TimeLineStringFrame::Clear();
  clear_has_eventframe();
}
inline const ::protocolbuffers::TimeLineStringFrame& Frame::eventframe() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return eventframe_ != NULL ? *eventframe_ : *default_instance().eventframe_;
#else
  return eventframe_ != NULL ? *eventframe_ : *default_instance_->eventframe_;
#endif
}
inline ::protocolbuffers::TimeLineStringFrame* Frame::mutable_eventframe() {
  set_has_eventframe();
  if (eventframe_ == NULL) eventframe_ = new ::protocolbuffers::TimeLineStringFrame;
  return eventframe_;
}
inline ::protocolbuffers::TimeLineStringFrame* Frame::release_eventframe() {
  clear_has_eventframe();
  ::protocolbuffers::TimeLineStringFrame* temp = eventframe_;
  eventframe_ = NULL;
  return temp;
}
inline void Frame::set_allocated_eventframe(::protocolbuffers::TimeLineStringFrame* eventframe) {
  delete eventframe_;
  eventframe_ = eventframe;
  if (eventframe) {
    set_has_eventframe();
  } else {
    clear_has_eventframe();
  }
}

// optional .protocolbuffers.TimeLinePointFrame anchorPointFrame = 9;
inline bool Frame::has_anchorpointframe() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void Frame::set_has_anchorpointframe() {
  _has_bits_[0] |= 0x00000010u;
}
inline void Frame::clear_has_anchorpointframe() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void Frame::clear_anchorpointframe() {
  if (anchorpointframe_ != NULL) anchorpointframe_->::protocolbuffers::TimeLinePointFrame::Clear();
  clear_has_anchorpointframe();
}
inline const ::protocolbuffers::TimeLinePointFrame& Frame::anchorpointframe() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return anchorpointframe_ != NULL ? *anchorpointframe_ : *default_instance().anchorpointframe_;
#else
  return anchorpointframe_ != NULL ? *anchorpointframe_ : *default_instance_->anchorpointframe_;
#endif
}
inline ::protocolbuffers::TimeLinePointFrame* Frame::mutable_anchorpointframe() {
  set_has_anchorpointframe();
  if (anchorpointframe_ == NULL) anchorpointframe_ = new ::protocolbuffers::TimeLinePointFrame;
  return anchorpointframe_;
}
inline ::protocolbuffers::TimeLinePointFrame* Frame::release_anchorpointframe() {
  clear_has_anchorpointframe();
  ::protocolbuffers::TimeLinePointFrame* temp = anchorpointframe_;
  anchorpointframe_ = NULL;
  return temp;
}
inline void Frame::set_allocated_anchorpointframe(::protocolbuffers::TimeLinePointFrame* anchorpointframe) {
  delete anchorpointframe_;
  anchorpointframe_ = anchorpointframe;
  if (anchorpointframe) {
    set_has_anchorpointframe();
  } else {
    clear_has_anchorpointframe();
  }
}

// optional .protocolbuffers.TimeLinePointFrame positionFrame = 10;
inline bool Frame::has_positionframe() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void Frame::set_has_positionframe() {
  _has_bits_[0] |= 0x00000020u;
}
inline void Frame::clear_has_positionframe() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void Frame::clear_positionframe() {
  if (positionframe_ != NULL) positionframe_->::protocolbuffers::TimeLinePointFrame::Clear();
  clear_has_positionframe();
}
inline const ::protocolbuffers::TimeLinePointFrame& Frame::positionframe() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return positionframe_ != NULL ? *positionframe_ : *default_instance().positionframe_;
#else
  return positionframe_ != NULL ? *positionframe_ : *default_instance_->positionframe_;
#endif
}
inline ::protocolbuffers::TimeLinePointFrame* Frame::mutable_positionframe() {
  set_has_positionframe();
  if (positionframe_ == NULL) positionframe_ = new ::protocolbuffers::TimeLinePointFrame;
  return positionframe_;
}
inline ::protocolbuffers::TimeLinePointFrame* Frame::release_positionframe() {
  clear_has_positionframe();
  ::protocolbuffers::TimeLinePointFrame* temp = positionframe_;
  positionframe_ = NULL;
  return temp;
}
inline void Frame::set_allocated_positionframe(::protocolbuffers::TimeLinePointFrame* positionframe) {
  delete positionframe_;
  positionframe_ = positionframe;
  if (positionframe) {
    set_has_positionframe();
  } else {
    clear_has_positionframe();
  }
}

// optional .protocolbuffers.TimeLinePointFrame scaleFrame = 11;
inline bool Frame::has_scaleframe() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void Frame::set_has_scaleframe() {
  _has_bits_[0] |= 0x00000040u;
}
inline void Frame::clear_has_scaleframe() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void Frame::clear_scaleframe() {
  if (scaleframe_ != NULL) scaleframe_->::protocolbuffers::TimeLinePointFrame::Clear();
  clear_has_scaleframe();
}
inline const ::protocolbuffers::TimeLinePointFrame& Frame::scaleframe() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return scaleframe_ != NULL ? *scaleframe_ : *default_instance().scaleframe_;
#else
  return scaleframe_ != NULL ? *scaleframe_ : *default_instance_->scaleframe_;
#endif
}
inline ::protocolbuffers::TimeLinePointFrame* Frame::mutable_scaleframe() {
  set_has_scaleframe();
  if (scaleframe_ == NULL) scaleframe_ = new ::protocolbuffers::TimeLinePointFrame;
  return scaleframe_;
}
inline ::protocolbuffers::TimeLinePointFrame* Frame::release_scaleframe() {
  clear_has_scaleframe();
  ::protocolbuffers::TimeLinePointFrame* temp = scaleframe_;
  scaleframe_ = NULL;
  return temp;
}
inline void Frame::set_allocated_scaleframe(::protocolbuffers::TimeLinePointFrame* scaleframe) {
  delete scaleframe_;
  scaleframe_ = scaleframe;
  if (scaleframe) {
    set_has_scaleframe();
  } else {
    clear_has_scaleframe();
  }
}

// optional .protocolbuffers.TimeLineColorFrame colorFrame = 12;
inline bool Frame::has_colorframe() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void Frame::set_has_colorframe() {
  _has_bits_[0] |= 0x00000080u;
}
inline void Frame::clear_has_colorframe() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void Frame::clear_colorframe() {
  if (colorframe_ != NULL) colorframe_->::protocolbuffers::TimeLineColorFrame::Clear();
  clear_has_colorframe();
}
inline const ::protocolbuffers::TimeLineColorFrame& Frame::colorframe() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return colorframe_ != NULL ? *colorframe_ : *default_instance().colorframe_;
#else
  return colorframe_ != NULL ? *colorframe_ : *default_instance_->colorframe_;
#endif
}
inline ::protocolbuffers::TimeLineColorFrame* Frame::mutable_colorframe() {
  set_has_colorframe();
  if (colorframe_ == NULL) colorframe_ = new ::protocolbuffers::TimeLineColorFrame;
  return colorframe_;
}
inline ::protocolbuffers::TimeLineColorFrame* Frame::release_colorframe() {
  clear_has_colorframe();
  ::protocolbuffers::TimeLineColorFrame* temp = colorframe_;
  colorframe_ = NULL;
  return temp;
}
inline void Frame::set_allocated_colorframe(::protocolbuffers::TimeLineColorFrame* colorframe) {
  delete colorframe_;
  colorframe_ = colorframe;
  if (colorframe) {
    set_has_colorframe();
  } else {
    clear_has_colorframe();
  }
}

// optional .protocolbuffers.TimeLineTextureFrame textureFrame = 13;
inline bool Frame::has_textureframe() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void Frame::set_has_textureframe() {
  _has_bits_[0] |= 0x00000100u;
}
inline void Frame::clear_has_textureframe() {
  _has_bits_[0] &= ~0x00000100u;
}
inline void Frame::clear_textureframe() {
  if (textureframe_ != NULL) textureframe_->::protocolbuffers::TimeLineTextureFrame::Clear();
  clear_has_textureframe();
}
inline const ::protocolbuffers::TimeLineTextureFrame& Frame::textureframe() const {
#ifdef GOOGLE_PROTOBUF_NO_STATIC_INITIALIZER
  return textureframe_ != NULL ? *textureframe_ : *default_instance().textureframe_;
#else
  return textureframe_ != NULL ? *textureframe_ : *default_instance_->textureframe_;
#endif
}
inline ::protocolbuffers::TimeLineTextureFrame* Frame::mutable_textureframe() {
  set_has_textureframe();
  if (textureframe_ == NULL) textureframe_ = new ::protocolbuffers::TimeLineTextureFrame;
  return textureframe_;
}
inline ::protocolbuffers::TimeLineTextureFrame* Frame::release_textureframe() {
  clear_has_textureframe();
  ::protocolbuffers::TimeLineTextureFrame* temp = textureframe_;
  textureframe_ = NULL;
  return temp;
}
inline void Frame::set_allocated_textureframe(::protocolbuffers::TimeLineTextureFrame* textureframe) {
  delete textureframe_;
  textureframe_ = textureframe;
  if (textureframe) {
    set_has_textureframe();
  } else {
    clear_has_textureframe();
  }
}

// -------------------------------------------------------------------

// TimeLineBoolFrame

// optional string name = 1;
inline bool TimeLineBoolFrame::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeLineBoolFrame::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeLineBoolFrame::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeLineBoolFrame::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TimeLineBoolFrame::name() const {
  return *name_;
}
inline void TimeLineBoolFrame::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TimeLineBoolFrame::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TimeLineBoolFrame::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimeLineBoolFrame::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TimeLineBoolFrame::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimeLineBoolFrame::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classname = 2;
inline bool TimeLineBoolFrame::has_classname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeLineBoolFrame::set_has_classname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeLineBoolFrame::clear_has_classname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeLineBoolFrame::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& TimeLineBoolFrame::classname() const {
  return *classname_;
}
inline void TimeLineBoolFrame::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void TimeLineBoolFrame::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void TimeLineBoolFrame::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimeLineBoolFrame::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* TimeLineBoolFrame::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimeLineBoolFrame::set_allocated_classname(::std::string* classname) {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (classname) {
    set_has_classname();
    classname_ = classname;
  } else {
    clear_has_classname();
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 frameIndex = 3;
inline bool TimeLineBoolFrame::has_frameindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimeLineBoolFrame::set_has_frameindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimeLineBoolFrame::clear_has_frameindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimeLineBoolFrame::clear_frameindex() {
  frameindex_ = 0;
  clear_has_frameindex();
}
inline ::google::protobuf::int32 TimeLineBoolFrame::frameindex() const {
  return frameindex_;
}
inline void TimeLineBoolFrame::set_frameindex(::google::protobuf::int32 value) {
  set_has_frameindex();
  frameindex_ = value;
}

// optional bool tween = 4;
inline bool TimeLineBoolFrame::has_tween() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TimeLineBoolFrame::set_has_tween() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TimeLineBoolFrame::clear_has_tween() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TimeLineBoolFrame::clear_tween() {
  tween_ = false;
  clear_has_tween();
}
inline bool TimeLineBoolFrame::tween() const {
  return tween_;
}
inline void TimeLineBoolFrame::set_tween(bool value) {
  set_has_tween();
  tween_ = value;
}

// optional bool value = 5;
inline bool TimeLineBoolFrame::has_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TimeLineBoolFrame::set_has_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TimeLineBoolFrame::clear_has_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TimeLineBoolFrame::clear_value() {
  value_ = false;
  clear_has_value();
}
inline bool TimeLineBoolFrame::value() const {
  return value_;
}
inline void TimeLineBoolFrame::set_value(bool value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// TimeLineIntFrame

// optional string name = 1;
inline bool TimeLineIntFrame::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeLineIntFrame::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeLineIntFrame::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeLineIntFrame::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TimeLineIntFrame::name() const {
  return *name_;
}
inline void TimeLineIntFrame::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TimeLineIntFrame::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TimeLineIntFrame::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimeLineIntFrame::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TimeLineIntFrame::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimeLineIntFrame::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classname = 2;
inline bool TimeLineIntFrame::has_classname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeLineIntFrame::set_has_classname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeLineIntFrame::clear_has_classname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeLineIntFrame::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& TimeLineIntFrame::classname() const {
  return *classname_;
}
inline void TimeLineIntFrame::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void TimeLineIntFrame::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void TimeLineIntFrame::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimeLineIntFrame::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* TimeLineIntFrame::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimeLineIntFrame::set_allocated_classname(::std::string* classname) {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (classname) {
    set_has_classname();
    classname_ = classname;
  } else {
    clear_has_classname();
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 frameIndex = 3;
inline bool TimeLineIntFrame::has_frameindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimeLineIntFrame::set_has_frameindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimeLineIntFrame::clear_has_frameindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimeLineIntFrame::clear_frameindex() {
  frameindex_ = 0;
  clear_has_frameindex();
}
inline ::google::protobuf::int32 TimeLineIntFrame::frameindex() const {
  return frameindex_;
}
inline void TimeLineIntFrame::set_frameindex(::google::protobuf::int32 value) {
  set_has_frameindex();
  frameindex_ = value;
}

// optional bool tween = 4;
inline bool TimeLineIntFrame::has_tween() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TimeLineIntFrame::set_has_tween() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TimeLineIntFrame::clear_has_tween() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TimeLineIntFrame::clear_tween() {
  tween_ = false;
  clear_has_tween();
}
inline bool TimeLineIntFrame::tween() const {
  return tween_;
}
inline void TimeLineIntFrame::set_tween(bool value) {
  set_has_tween();
  tween_ = value;
}

// optional int32 value = 5;
inline bool TimeLineIntFrame::has_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TimeLineIntFrame::set_has_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TimeLineIntFrame::clear_has_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TimeLineIntFrame::clear_value() {
  value_ = 0;
  clear_has_value();
}
inline ::google::protobuf::int32 TimeLineIntFrame::value() const {
  return value_;
}
inline void TimeLineIntFrame::set_value(::google::protobuf::int32 value) {
  set_has_value();
  value_ = value;
}

// -------------------------------------------------------------------

// TimeLineStringFrame

// optional string name = 1;
inline bool TimeLineStringFrame::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeLineStringFrame::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeLineStringFrame::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeLineStringFrame::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TimeLineStringFrame::name() const {
  return *name_;
}
inline void TimeLineStringFrame::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TimeLineStringFrame::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TimeLineStringFrame::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimeLineStringFrame::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TimeLineStringFrame::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimeLineStringFrame::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classname = 2;
inline bool TimeLineStringFrame::has_classname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeLineStringFrame::set_has_classname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeLineStringFrame::clear_has_classname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeLineStringFrame::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& TimeLineStringFrame::classname() const {
  return *classname_;
}
inline void TimeLineStringFrame::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void TimeLineStringFrame::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void TimeLineStringFrame::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimeLineStringFrame::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* TimeLineStringFrame::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimeLineStringFrame::set_allocated_classname(::std::string* classname) {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (classname) {
    set_has_classname();
    classname_ = classname;
  } else {
    clear_has_classname();
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 frameIndex = 3;
inline bool TimeLineStringFrame::has_frameindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimeLineStringFrame::set_has_frameindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimeLineStringFrame::clear_has_frameindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimeLineStringFrame::clear_frameindex() {
  frameindex_ = 0;
  clear_has_frameindex();
}
inline ::google::protobuf::int32 TimeLineStringFrame::frameindex() const {
  return frameindex_;
}
inline void TimeLineStringFrame::set_frameindex(::google::protobuf::int32 value) {
  set_has_frameindex();
  frameindex_ = value;
}

// optional bool tween = 4;
inline bool TimeLineStringFrame::has_tween() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TimeLineStringFrame::set_has_tween() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TimeLineStringFrame::clear_has_tween() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TimeLineStringFrame::clear_tween() {
  tween_ = false;
  clear_has_tween();
}
inline bool TimeLineStringFrame::tween() const {
  return tween_;
}
inline void TimeLineStringFrame::set_tween(bool value) {
  set_has_tween();
  tween_ = value;
}

// optional string value = 5;
inline bool TimeLineStringFrame::has_value() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TimeLineStringFrame::set_has_value() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TimeLineStringFrame::clear_has_value() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TimeLineStringFrame::clear_value() {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    value_->clear();
  }
  clear_has_value();
}
inline const ::std::string& TimeLineStringFrame::value() const {
  return *value_;
}
inline void TimeLineStringFrame::set_value(const ::std::string& value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void TimeLineStringFrame::set_value(const char* value) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(value);
}
inline void TimeLineStringFrame::set_value(const char* value, size_t size) {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  value_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimeLineStringFrame::mutable_value() {
  set_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    value_ = new ::std::string;
  }
  return value_;
}
inline ::std::string* TimeLineStringFrame::release_value() {
  clear_has_value();
  if (value_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = value_;
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimeLineStringFrame::set_allocated_value(::std::string* value) {
  if (value_ != &::google::protobuf::internal::kEmptyString) {
    delete value_;
  }
  if (value) {
    set_has_value();
    value_ = value;
  } else {
    clear_has_value();
    value_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// -------------------------------------------------------------------

// TimeLinePointFrame

// optional string name = 1;
inline bool TimeLinePointFrame::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeLinePointFrame::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeLinePointFrame::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeLinePointFrame::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TimeLinePointFrame::name() const {
  return *name_;
}
inline void TimeLinePointFrame::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TimeLinePointFrame::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TimeLinePointFrame::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimeLinePointFrame::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TimeLinePointFrame::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimeLinePointFrame::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classname = 2;
inline bool TimeLinePointFrame::has_classname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeLinePointFrame::set_has_classname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeLinePointFrame::clear_has_classname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeLinePointFrame::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& TimeLinePointFrame::classname() const {
  return *classname_;
}
inline void TimeLinePointFrame::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void TimeLinePointFrame::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void TimeLinePointFrame::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimeLinePointFrame::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* TimeLinePointFrame::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimeLinePointFrame::set_allocated_classname(::std::string* classname) {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (classname) {
    set_has_classname();
    classname_ = classname;
  } else {
    clear_has_classname();
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 frameIndex = 3;
inline bool TimeLinePointFrame::has_frameindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimeLinePointFrame::set_has_frameindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimeLinePointFrame::clear_has_frameindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimeLinePointFrame::clear_frameindex() {
  frameindex_ = 0;
  clear_has_frameindex();
}
inline ::google::protobuf::int32 TimeLinePointFrame::frameindex() const {
  return frameindex_;
}
inline void TimeLinePointFrame::set_frameindex(::google::protobuf::int32 value) {
  set_has_frameindex();
  frameindex_ = value;
}

// optional bool tween = 4;
inline bool TimeLinePointFrame::has_tween() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TimeLinePointFrame::set_has_tween() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TimeLinePointFrame::clear_has_tween() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TimeLinePointFrame::clear_tween() {
  tween_ = false;
  clear_has_tween();
}
inline bool TimeLinePointFrame::tween() const {
  return tween_;
}
inline void TimeLinePointFrame::set_tween(bool value) {
  set_has_tween();
  tween_ = value;
}

// optional float x = 5;
inline bool TimeLinePointFrame::has_x() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TimeLinePointFrame::set_has_x() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TimeLinePointFrame::clear_has_x() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TimeLinePointFrame::clear_x() {
  x_ = 0;
  clear_has_x();
}
inline float TimeLinePointFrame::x() const {
  return x_;
}
inline void TimeLinePointFrame::set_x(float value) {
  set_has_x();
  x_ = value;
}

// optional float y = 6;
inline bool TimeLinePointFrame::has_y() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TimeLinePointFrame::set_has_y() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TimeLinePointFrame::clear_has_y() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TimeLinePointFrame::clear_y() {
  y_ = 0;
  clear_has_y();
}
inline float TimeLinePointFrame::y() const {
  return y_;
}
inline void TimeLinePointFrame::set_y(float value) {
  set_has_y();
  y_ = value;
}

// -------------------------------------------------------------------

// TimeLineColorFrame

// optional string name = 1;
inline bool TimeLineColorFrame::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeLineColorFrame::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeLineColorFrame::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeLineColorFrame::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TimeLineColorFrame::name() const {
  return *name_;
}
inline void TimeLineColorFrame::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TimeLineColorFrame::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TimeLineColorFrame::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimeLineColorFrame::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TimeLineColorFrame::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimeLineColorFrame::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classname = 2;
inline bool TimeLineColorFrame::has_classname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeLineColorFrame::set_has_classname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeLineColorFrame::clear_has_classname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeLineColorFrame::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& TimeLineColorFrame::classname() const {
  return *classname_;
}
inline void TimeLineColorFrame::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void TimeLineColorFrame::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void TimeLineColorFrame::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimeLineColorFrame::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* TimeLineColorFrame::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimeLineColorFrame::set_allocated_classname(::std::string* classname) {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (classname) {
    set_has_classname();
    classname_ = classname;
  } else {
    clear_has_classname();
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 frameIndex = 3;
inline bool TimeLineColorFrame::has_frameindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimeLineColorFrame::set_has_frameindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimeLineColorFrame::clear_has_frameindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimeLineColorFrame::clear_frameindex() {
  frameindex_ = 0;
  clear_has_frameindex();
}
inline ::google::protobuf::int32 TimeLineColorFrame::frameindex() const {
  return frameindex_;
}
inline void TimeLineColorFrame::set_frameindex(::google::protobuf::int32 value) {
  set_has_frameindex();
  frameindex_ = value;
}

// optional bool tween = 4;
inline bool TimeLineColorFrame::has_tween() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TimeLineColorFrame::set_has_tween() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TimeLineColorFrame::clear_has_tween() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TimeLineColorFrame::clear_tween() {
  tween_ = false;
  clear_has_tween();
}
inline bool TimeLineColorFrame::tween() const {
  return tween_;
}
inline void TimeLineColorFrame::set_tween(bool value) {
  set_has_tween();
  tween_ = value;
}

// optional int32 alpha = 5;
inline bool TimeLineColorFrame::has_alpha() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TimeLineColorFrame::set_has_alpha() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TimeLineColorFrame::clear_has_alpha() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TimeLineColorFrame::clear_alpha() {
  alpha_ = 0;
  clear_has_alpha();
}
inline ::google::protobuf::int32 TimeLineColorFrame::alpha() const {
  return alpha_;
}
inline void TimeLineColorFrame::set_alpha(::google::protobuf::int32 value) {
  set_has_alpha();
  alpha_ = value;
}

// optional int32 red = 6;
inline bool TimeLineColorFrame::has_red() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TimeLineColorFrame::set_has_red() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TimeLineColorFrame::clear_has_red() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TimeLineColorFrame::clear_red() {
  red_ = 0;
  clear_has_red();
}
inline ::google::protobuf::int32 TimeLineColorFrame::red() const {
  return red_;
}
inline void TimeLineColorFrame::set_red(::google::protobuf::int32 value) {
  set_has_red();
  red_ = value;
}

// optional int32 green = 7;
inline bool TimeLineColorFrame::has_green() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TimeLineColorFrame::set_has_green() {
  _has_bits_[0] |= 0x00000040u;
}
inline void TimeLineColorFrame::clear_has_green() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void TimeLineColorFrame::clear_green() {
  green_ = 0;
  clear_has_green();
}
inline ::google::protobuf::int32 TimeLineColorFrame::green() const {
  return green_;
}
inline void TimeLineColorFrame::set_green(::google::protobuf::int32 value) {
  set_has_green();
  green_ = value;
}

// optional int32 blue = 8;
inline bool TimeLineColorFrame::has_blue() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TimeLineColorFrame::set_has_blue() {
  _has_bits_[0] |= 0x00000080u;
}
inline void TimeLineColorFrame::clear_has_blue() {
  _has_bits_[0] &= ~0x00000080u;
}
inline void TimeLineColorFrame::clear_blue() {
  blue_ = 0;
  clear_has_blue();
}
inline ::google::protobuf::int32 TimeLineColorFrame::blue() const {
  return blue_;
}
inline void TimeLineColorFrame::set_blue(::google::protobuf::int32 value) {
  set_has_blue();
  blue_ = value;
}

// -------------------------------------------------------------------

// TimeLineTextureFrame

// optional string name = 1;
inline bool TimeLineTextureFrame::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TimeLineTextureFrame::set_has_name() {
  _has_bits_[0] |= 0x00000001u;
}
inline void TimeLineTextureFrame::clear_has_name() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void TimeLineTextureFrame::clear_name() {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    name_->clear();
  }
  clear_has_name();
}
inline const ::std::string& TimeLineTextureFrame::name() const {
  return *name_;
}
inline void TimeLineTextureFrame::set_name(const ::std::string& value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TimeLineTextureFrame::set_name(const char* value) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(value);
}
inline void TimeLineTextureFrame::set_name(const char* value, size_t size) {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  name_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimeLineTextureFrame::mutable_name() {
  set_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    name_ = new ::std::string;
  }
  return name_;
}
inline ::std::string* TimeLineTextureFrame::release_name() {
  clear_has_name();
  if (name_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = name_;
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimeLineTextureFrame::set_allocated_name(::std::string* name) {
  if (name_ != &::google::protobuf::internal::kEmptyString) {
    delete name_;
  }
  if (name) {
    set_has_name();
    name_ = name;
  } else {
    clear_has_name();
    name_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string classname = 2;
inline bool TimeLineTextureFrame::has_classname() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TimeLineTextureFrame::set_has_classname() {
  _has_bits_[0] |= 0x00000002u;
}
inline void TimeLineTextureFrame::clear_has_classname() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void TimeLineTextureFrame::clear_classname() {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    classname_->clear();
  }
  clear_has_classname();
}
inline const ::std::string& TimeLineTextureFrame::classname() const {
  return *classname_;
}
inline void TimeLineTextureFrame::set_classname(const ::std::string& value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void TimeLineTextureFrame::set_classname(const char* value) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(value);
}
inline void TimeLineTextureFrame::set_classname(const char* value, size_t size) {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  classname_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimeLineTextureFrame::mutable_classname() {
  set_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    classname_ = new ::std::string;
  }
  return classname_;
}
inline ::std::string* TimeLineTextureFrame::release_classname() {
  clear_has_classname();
  if (classname_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = classname_;
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimeLineTextureFrame::set_allocated_classname(::std::string* classname) {
  if (classname_ != &::google::protobuf::internal::kEmptyString) {
    delete classname_;
  }
  if (classname) {
    set_has_classname();
    classname_ = classname;
  } else {
    clear_has_classname();
    classname_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional int32 frameIndex = 3;
inline bool TimeLineTextureFrame::has_frameindex() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TimeLineTextureFrame::set_has_frameindex() {
  _has_bits_[0] |= 0x00000004u;
}
inline void TimeLineTextureFrame::clear_has_frameindex() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void TimeLineTextureFrame::clear_frameindex() {
  frameindex_ = 0;
  clear_has_frameindex();
}
inline ::google::protobuf::int32 TimeLineTextureFrame::frameindex() const {
  return frameindex_;
}
inline void TimeLineTextureFrame::set_frameindex(::google::protobuf::int32 value) {
  set_has_frameindex();
  frameindex_ = value;
}

// optional bool tween = 4;
inline bool TimeLineTextureFrame::has_tween() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TimeLineTextureFrame::set_has_tween() {
  _has_bits_[0] |= 0x00000008u;
}
inline void TimeLineTextureFrame::clear_has_tween() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void TimeLineTextureFrame::clear_tween() {
  tween_ = false;
  clear_has_tween();
}
inline bool TimeLineTextureFrame::tween() const {
  return tween_;
}
inline void TimeLineTextureFrame::set_tween(bool value) {
  set_has_tween();
  tween_ = value;
}

// optional string filePath = 5;
inline bool TimeLineTextureFrame::has_filepath() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TimeLineTextureFrame::set_has_filepath() {
  _has_bits_[0] |= 0x00000010u;
}
inline void TimeLineTextureFrame::clear_has_filepath() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void TimeLineTextureFrame::clear_filepath() {
  if (filepath_ != &::google::protobuf::internal::kEmptyString) {
    filepath_->clear();
  }
  clear_has_filepath();
}
inline const ::std::string& TimeLineTextureFrame::filepath() const {
  return *filepath_;
}
inline void TimeLineTextureFrame::set_filepath(const ::std::string& value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
}
inline void TimeLineTextureFrame::set_filepath(const char* value) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(value);
}
inline void TimeLineTextureFrame::set_filepath(const char* value, size_t size) {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  filepath_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimeLineTextureFrame::mutable_filepath() {
  set_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    filepath_ = new ::std::string;
  }
  return filepath_;
}
inline ::std::string* TimeLineTextureFrame::release_filepath() {
  clear_has_filepath();
  if (filepath_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = filepath_;
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimeLineTextureFrame::set_allocated_filepath(::std::string* filepath) {
  if (filepath_ != &::google::protobuf::internal::kEmptyString) {
    delete filepath_;
  }
  if (filepath) {
    set_has_filepath();
    filepath_ = filepath;
  } else {
    clear_has_filepath();
    filepath_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}

// optional string plistFile = 6;
inline bool TimeLineTextureFrame::has_plistfile() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TimeLineTextureFrame::set_has_plistfile() {
  _has_bits_[0] |= 0x00000020u;
}
inline void TimeLineTextureFrame::clear_has_plistfile() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void TimeLineTextureFrame::clear_plistfile() {
  if (plistfile_ != &::google::protobuf::internal::kEmptyString) {
    plistfile_->clear();
  }
  clear_has_plistfile();
}
inline const ::std::string& TimeLineTextureFrame::plistfile() const {
  return *plistfile_;
}
inline void TimeLineTextureFrame::set_plistfile(const ::std::string& value) {
  set_has_plistfile();
  if (plistfile_ == &::google::protobuf::internal::kEmptyString) {
    plistfile_ = new ::std::string;
  }
  plistfile_->assign(value);
}
inline void TimeLineTextureFrame::set_plistfile(const char* value) {
  set_has_plistfile();
  if (plistfile_ == &::google::protobuf::internal::kEmptyString) {
    plistfile_ = new ::std::string;
  }
  plistfile_->assign(value);
}
inline void TimeLineTextureFrame::set_plistfile(const char* value, size_t size) {
  set_has_plistfile();
  if (plistfile_ == &::google::protobuf::internal::kEmptyString) {
    plistfile_ = new ::std::string;
  }
  plistfile_->assign(reinterpret_cast<const char*>(value), size);
}
inline ::std::string* TimeLineTextureFrame::mutable_plistfile() {
  set_has_plistfile();
  if (plistfile_ == &::google::protobuf::internal::kEmptyString) {
    plistfile_ = new ::std::string;
  }
  return plistfile_;
}
inline ::std::string* TimeLineTextureFrame::release_plistfile() {
  clear_has_plistfile();
  if (plistfile_ == &::google::protobuf::internal::kEmptyString) {
    return NULL;
  } else {
    ::std::string* temp = plistfile_;
    plistfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
    return temp;
  }
}
inline void TimeLineTextureFrame::set_allocated_plistfile(::std::string* plistfile) {
  if (plistfile_ != &::google::protobuf::internal::kEmptyString) {
    delete plistfile_;
  }
  if (plistfile) {
    set_has_plistfile();
    plistfile_ = plistfile;
  } else {
    clear_has_plistfile();
    plistfile_ = const_cast< ::std::string*>(&::google::protobuf::internal::kEmptyString);
  }
}


// @@protoc_insertion_point(namespace_scope)

}  // namespace protocolbuffers

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_CSParseBinary_2eproto__INCLUDED

// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_CSPARSE3DBINARY_FLATBUFFERS_H_
#define FLATBUFFERS_GENERATED_CSPARSE3DBINARY_FLATBUFFERS_H_

#include "flatbuffers/flatbuffers.h"

#include "editor-support/cocostudio/CSParseBinary_generated.h"

namespace flatbuffers {

struct Node3DOption;

struct Sprite3DOptions;

struct Particle3DOptions;

struct UserCameraOptions;

struct GameNode3DOption;

struct Light3DOption;

struct Vector2;

struct Vector3;

MANUALLY_ALIGNED_STRUCT(4) Vector2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vector2() { memset(this, 0, sizeof(Vector2)); }
  Vector2(const Vector2 &_o) { memcpy(this, &_o, sizeof(Vector2)); }
  Vector2(float _x, float _y)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
};
STRUCT_END(Vector2, 8);

MANUALLY_ALIGNED_STRUCT(4) Vector3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vector3() { memset(this, 0, sizeof(Vector3)); }
  Vector3(const Vector3 &_o) { memcpy(this, &_o, sizeof(Vector3)); }
  Vector3(float _x, float _y, float _z)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)), z_(flatbuffers::EndianScalar(_z)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  float z() const { return flatbuffers::EndianScalar(z_); }
};
STRUCT_END(Vector3, 12);

struct Node3DOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODEOPTIONS = 4,
    VT_POSITION3D = 6,
    VT_ROTATION3D = 8,
    VT_SCALE3D = 10,
    VT_CAMERAMASK = 12
  };
  const flatbuffers::WidgetOptions *nodeOptions() const { return GetPointer<const flatbuffers::WidgetOptions *>(VT_NODEOPTIONS); }
  const Vector3 *position3D() const { return GetStruct<const Vector3 *>(VT_POSITION3D); }
  const Vector3 *rotation3D() const { return GetStruct<const Vector3 *>(VT_ROTATION3D); }
  const Vector3 *scale3D() const { return GetStruct<const Vector3 *>(VT_SCALE3D); }
  int32_t cameramask() const { return GetField<int32_t>(VT_CAMERAMASK, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODEOPTIONS) &&
           verifier.VerifyTable(nodeOptions()) &&
           VerifyField<Vector3>(verifier, VT_POSITION3D) &&
           VerifyField<Vector3>(verifier, VT_ROTATION3D) &&
           VerifyField<Vector3>(verifier, VT_SCALE3D) &&
           VerifyField<int32_t>(verifier, VT_CAMERAMASK) &&
           verifier.EndTable();
  }
};

struct Node3DOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_nodeOptions(flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions) { fbb_.AddOffset(Node3DOption::VT_NODEOPTIONS, nodeOptions); }
  void add_position3D(const Vector3 *position3D) { fbb_.AddStruct(Node3DOption::VT_POSITION3D, position3D); }
  void add_rotation3D(const Vector3 *rotation3D) { fbb_.AddStruct(Node3DOption::VT_ROTATION3D, rotation3D); }
  void add_scale3D(const Vector3 *scale3D) { fbb_.AddStruct(Node3DOption::VT_SCALE3D, scale3D); }
  void add_cameramask(int32_t cameramask) { fbb_.AddElement<int32_t>(Node3DOption::VT_CAMERAMASK, cameramask, 0); }
  Node3DOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  Node3DOptionBuilder &operator=(const Node3DOptionBuilder &);
  flatbuffers::Offset<Node3DOption> Finish() {
    auto o = flatbuffers::Offset<Node3DOption>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<Node3DOption> CreateNode3DOption(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::WidgetOptions> nodeOptions = 0,
    const Vector3 *position3D = 0,
    const Vector3 *rotation3D = 0,
    const Vector3 *scale3D = 0,
    int32_t cameramask = 0) {
  Node3DOptionBuilder builder_(_fbb);
  builder_.add_cameramask(cameramask);
  builder_.add_scale3D(scale3D);
  builder_.add_rotation3D(rotation3D);
  builder_.add_position3D(position3D);
  builder_.add_nodeOptions(nodeOptions);
  return builder_.Finish();
}

struct Sprite3DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE3DOPTION = 4,
    VT_FILEDATA = 6,
    VT_RUNACTION = 8,
    VT_ISFLIPPED = 10,
    VT_LIGHTFLAG = 12
  };
  const Node3DOption *node3DOption() const { return GetPointer<const Node3DOption *>(VT_NODE3DOPTION); }
  const flatbuffers::ResourceData *fileData() const { return GetPointer<const flatbuffers::ResourceData *>(VT_FILEDATA); }
  bool runAction() const { return GetField<uint8_t>(VT_RUNACTION, 0) != 0; }
  bool isFlipped() const { return GetField<uint8_t>(VT_ISFLIPPED, 0) != 0; }
  int32_t lightFlag() const { return GetField<int32_t>(VT_LIGHTFLAG, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE3DOPTION) &&
           verifier.VerifyTable(node3DOption()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FILEDATA) &&
           verifier.VerifyTable(fileData()) &&
           VerifyField<uint8_t>(verifier, VT_RUNACTION) &&
           VerifyField<uint8_t>(verifier, VT_ISFLIPPED) &&
           VerifyField<int32_t>(verifier, VT_LIGHTFLAG) &&
           verifier.EndTable();
  }
};

struct Sprite3DOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node3DOption(flatbuffers::Offset<Node3DOption> node3DOption) { fbb_.AddOffset(Sprite3DOptions::VT_NODE3DOPTION, node3DOption); }
  void add_fileData(flatbuffers::Offset<flatbuffers::ResourceData> fileData) { fbb_.AddOffset(Sprite3DOptions::VT_FILEDATA, fileData); }
  void add_runAction(bool runAction) { fbb_.AddElement<uint8_t>(Sprite3DOptions::VT_RUNACTION, static_cast<uint8_t>(runAction), 0); }
  void add_isFlipped(bool isFlipped) { fbb_.AddElement<uint8_t>(Sprite3DOptions::VT_ISFLIPPED, static_cast<uint8_t>(isFlipped), 0); }
  void add_lightFlag(int32_t lightFlag) { fbb_.AddElement<int32_t>(Sprite3DOptions::VT_LIGHTFLAG, lightFlag, 0); }
  Sprite3DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  Sprite3DOptionsBuilder &operator=(const Sprite3DOptionsBuilder &);
  flatbuffers::Offset<Sprite3DOptions> Finish() {
    auto o = flatbuffers::Offset<Sprite3DOptions>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<Sprite3DOptions> CreateSprite3DOptions(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node3DOption> node3DOption = 0,
    flatbuffers::Offset<flatbuffers::ResourceData> fileData = 0,
    bool runAction = false,
    bool isFlipped = false,
    int32_t lightFlag = 0) {
  Sprite3DOptionsBuilder builder_(_fbb);
  builder_.add_lightFlag(lightFlag);
  builder_.add_fileData(fileData);
  builder_.add_node3DOption(node3DOption);
  builder_.add_isFlipped(isFlipped);
  builder_.add_runAction(runAction);
  return builder_.Finish();
}

struct Particle3DOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE3DOPTION = 4,
    VT_FILEDATA = 6
  };
  const Node3DOption *node3DOption() const { return GetPointer<const Node3DOption *>(VT_NODE3DOPTION); }
  const flatbuffers::ResourceData *fileData() const { return GetPointer<const flatbuffers::ResourceData *>(VT_FILEDATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE3DOPTION) &&
           verifier.VerifyTable(node3DOption()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FILEDATA) &&
           verifier.VerifyTable(fileData()) &&
           verifier.EndTable();
  }
};

struct Particle3DOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node3DOption(flatbuffers::Offset<Node3DOption> node3DOption) { fbb_.AddOffset(Particle3DOptions::VT_NODE3DOPTION, node3DOption); }
  void add_fileData(flatbuffers::Offset<flatbuffers::ResourceData> fileData) { fbb_.AddOffset(Particle3DOptions::VT_FILEDATA, fileData); }
  Particle3DOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  Particle3DOptionsBuilder &operator=(const Particle3DOptionsBuilder &);
  flatbuffers::Offset<Particle3DOptions> Finish() {
    auto o = flatbuffers::Offset<Particle3DOptions>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<Particle3DOptions> CreateParticle3DOptions(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node3DOption> node3DOption = 0,
    flatbuffers::Offset<flatbuffers::ResourceData> fileData = 0) {
  Particle3DOptionsBuilder builder_(_fbb);
  builder_.add_fileData(fileData);
  builder_.add_node3DOption(node3DOption);
  return builder_.Finish();
}

struct UserCameraOptions FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE3DOPTION = 4,
    VT_FOV = 6,
    VT_NEARCLIP = 8,
    VT_FARCLIP = 10,
    VT_CAMERAFLAG = 12,
    VT_SKYBOXENABLED = 14,
    VT_LEFTFILEDATA = 16,
    VT_RIGHTFILEDATA = 18,
    VT_UPFILEDATA = 20,
    VT_DOWNFILEDATA = 22,
    VT_FORWARDFILEDATA = 24,
    VT_BACKFILEDATA = 26
  };
  const Node3DOption *node3DOption() const { return GetPointer<const Node3DOption *>(VT_NODE3DOPTION); }
  float fov() const { return GetField<float>(VT_FOV, 60.0f); }
  float nearClip() const { return GetField<float>(VT_NEARCLIP, 1.0f); }
  float farClip() const { return GetField<float>(VT_FARCLIP, 1000.0f); }
  int32_t cameraFlag() const { return GetField<int32_t>(VT_CAMERAFLAG, 0); }
  bool skyBoxEnabled() const { return GetField<uint8_t>(VT_SKYBOXENABLED, 0) != 0; }
  const flatbuffers::ResourceData *leftFileData() const { return GetPointer<const flatbuffers::ResourceData *>(VT_LEFTFILEDATA); }
  const flatbuffers::ResourceData *rightFileData() const { return GetPointer<const flatbuffers::ResourceData *>(VT_RIGHTFILEDATA); }
  const flatbuffers::ResourceData *upFileData() const { return GetPointer<const flatbuffers::ResourceData *>(VT_UPFILEDATA); }
  const flatbuffers::ResourceData *downFileData() const { return GetPointer<const flatbuffers::ResourceData *>(VT_DOWNFILEDATA); }
  const flatbuffers::ResourceData *forwardFileData() const { return GetPointer<const flatbuffers::ResourceData *>(VT_FORWARDFILEDATA); }
  const flatbuffers::ResourceData *backFileData() const { return GetPointer<const flatbuffers::ResourceData *>(VT_BACKFILEDATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE3DOPTION) &&
           verifier.VerifyTable(node3DOption()) &&
           VerifyField<float>(verifier, VT_FOV) &&
           VerifyField<float>(verifier, VT_NEARCLIP) &&
           VerifyField<float>(verifier, VT_FARCLIP) &&
           VerifyField<int32_t>(verifier, VT_CAMERAFLAG) &&
           VerifyField<uint8_t>(verifier, VT_SKYBOXENABLED) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LEFTFILEDATA) &&
           verifier.VerifyTable(leftFileData()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_RIGHTFILEDATA) &&
           verifier.VerifyTable(rightFileData()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UPFILEDATA) &&
           verifier.VerifyTable(upFileData()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DOWNFILEDATA) &&
           verifier.VerifyTable(downFileData()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FORWARDFILEDATA) &&
           verifier.VerifyTable(forwardFileData()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BACKFILEDATA) &&
           verifier.VerifyTable(backFileData()) &&
           verifier.EndTable();
  }
};

struct UserCameraOptionsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node3DOption(flatbuffers::Offset<Node3DOption> node3DOption) { fbb_.AddOffset(UserCameraOptions::VT_NODE3DOPTION, node3DOption); }
  void add_fov(float fov) { fbb_.AddElement<float>(UserCameraOptions::VT_FOV, fov, 60.0f); }
  void add_nearClip(float nearClip) { fbb_.AddElement<float>(UserCameraOptions::VT_NEARCLIP, nearClip, 1.0f); }
  void add_farClip(float farClip) { fbb_.AddElement<float>(UserCameraOptions::VT_FARCLIP, farClip, 1000.0f); }
  void add_cameraFlag(int32_t cameraFlag) { fbb_.AddElement<int32_t>(UserCameraOptions::VT_CAMERAFLAG, cameraFlag, 0); }
  void add_skyBoxEnabled(bool skyBoxEnabled) { fbb_.AddElement<uint8_t>(UserCameraOptions::VT_SKYBOXENABLED, static_cast<uint8_t>(skyBoxEnabled), 0); }
  void add_leftFileData(flatbuffers::Offset<flatbuffers::ResourceData> leftFileData) { fbb_.AddOffset(UserCameraOptions::VT_LEFTFILEDATA, leftFileData); }
  void add_rightFileData(flatbuffers::Offset<flatbuffers::ResourceData> rightFileData) { fbb_.AddOffset(UserCameraOptions::VT_RIGHTFILEDATA, rightFileData); }
  void add_upFileData(flatbuffers::Offset<flatbuffers::ResourceData> upFileData) { fbb_.AddOffset(UserCameraOptions::VT_UPFILEDATA, upFileData); }
  void add_downFileData(flatbuffers::Offset<flatbuffers::ResourceData> downFileData) { fbb_.AddOffset(UserCameraOptions::VT_DOWNFILEDATA, downFileData); }
  void add_forwardFileData(flatbuffers::Offset<flatbuffers::ResourceData> forwardFileData) { fbb_.AddOffset(UserCameraOptions::VT_FORWARDFILEDATA, forwardFileData); }
  void add_backFileData(flatbuffers::Offset<flatbuffers::ResourceData> backFileData) { fbb_.AddOffset(UserCameraOptions::VT_BACKFILEDATA, backFileData); }
  UserCameraOptionsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  UserCameraOptionsBuilder &operator=(const UserCameraOptionsBuilder &);
  flatbuffers::Offset<UserCameraOptions> Finish() {
    auto o = flatbuffers::Offset<UserCameraOptions>(fbb_.EndTable(start_, 12));
    return o;
  }
};

inline flatbuffers::Offset<UserCameraOptions> CreateUserCameraOptions(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node3DOption> node3DOption = 0,
    float fov = 60.0f,
    float nearClip = 1.0f,
    float farClip = 1000.0f,
    int32_t cameraFlag = 0,
    bool skyBoxEnabled = false,
    flatbuffers::Offset<flatbuffers::ResourceData> leftFileData = 0,
    flatbuffers::Offset<flatbuffers::ResourceData> rightFileData = 0,
    flatbuffers::Offset<flatbuffers::ResourceData> upFileData = 0,
    flatbuffers::Offset<flatbuffers::ResourceData> downFileData = 0,
    flatbuffers::Offset<flatbuffers::ResourceData> forwardFileData = 0,
    flatbuffers::Offset<flatbuffers::ResourceData> backFileData = 0) {
  UserCameraOptionsBuilder builder_(_fbb);
  builder_.add_backFileData(backFileData);
  builder_.add_forwardFileData(forwardFileData);
  builder_.add_downFileData(downFileData);
  builder_.add_upFileData(upFileData);
  builder_.add_rightFileData(rightFileData);
  builder_.add_leftFileData(leftFileData);
  builder_.add_cameraFlag(cameraFlag);
  builder_.add_farClip(farClip);
  builder_.add_nearClip(nearClip);
  builder_.add_fov(fov);
  builder_.add_node3DOption(node3DOption);
  builder_.add_skyBoxEnabled(skyBoxEnabled);
  return builder_.Finish();
}

struct GameNode3DOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_SKYBOXMASK = 6,
    VT_SKYBOXENABLED = 8,
    VT_LEFTFILEDATA = 10,
    VT_RIGHTFILEDATA = 12,
    VT_UPFILEDATA = 14,
    VT_DOWNFILEDATA = 16,
    VT_FORWARDFILEDATA = 18,
    VT_BACKFILEDATA = 20,
    VT_FRAMEEVENT = 22,
    VT_CUSTOMPROPERTY = 24,
    VT_USEDEFAULTLIGHT = 26
  };
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  int32_t skyBoxMask() const { return GetField<int32_t>(VT_SKYBOXMASK, 0); }
  bool skyBoxEnabled() const { return GetField<uint8_t>(VT_SKYBOXENABLED, 0) != 0; }
  const flatbuffers::ResourceData *leftFileData() const { return GetPointer<const flatbuffers::ResourceData *>(VT_LEFTFILEDATA); }
  const flatbuffers::ResourceData *rightFileData() const { return GetPointer<const flatbuffers::ResourceData *>(VT_RIGHTFILEDATA); }
  const flatbuffers::ResourceData *upFileData() const { return GetPointer<const flatbuffers::ResourceData *>(VT_UPFILEDATA); }
  const flatbuffers::ResourceData *downFileData() const { return GetPointer<const flatbuffers::ResourceData *>(VT_DOWNFILEDATA); }
  const flatbuffers::ResourceData *forwardFileData() const { return GetPointer<const flatbuffers::ResourceData *>(VT_FORWARDFILEDATA); }
  const flatbuffers::ResourceData *backFileData() const { return GetPointer<const flatbuffers::ResourceData *>(VT_BACKFILEDATA); }
  const flatbuffers::String *frameEvent() const { return GetPointer<const flatbuffers::String *>(VT_FRAMEEVENT); }
  const flatbuffers::String *customProperty() const { return GetPointer<const flatbuffers::String *>(VT_CUSTOMPROPERTY); }
  bool useDefaultLight() const { return GetField<uint8_t>(VT_USEDEFAULTLIGHT, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<int32_t>(verifier, VT_SKYBOXMASK) &&
           VerifyField<uint8_t>(verifier, VT_SKYBOXENABLED) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LEFTFILEDATA) &&
           verifier.VerifyTable(leftFileData()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_RIGHTFILEDATA) &&
           verifier.VerifyTable(rightFileData()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_UPFILEDATA) &&
           verifier.VerifyTable(upFileData()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DOWNFILEDATA) &&
           verifier.VerifyTable(downFileData()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FORWARDFILEDATA) &&
           verifier.VerifyTable(forwardFileData()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BACKFILEDATA) &&
           verifier.VerifyTable(backFileData()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FRAMEEVENT) &&
           verifier.Verify(frameEvent()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CUSTOMPROPERTY) &&
           verifier.Verify(customProperty()) &&
           VerifyField<uint8_t>(verifier, VT_USEDEFAULTLIGHT) &&
           verifier.EndTable();
  }
};

struct GameNode3DOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(GameNode3DOption::VT_NAME, name); }
  void add_skyBoxMask(int32_t skyBoxMask) { fbb_.AddElement<int32_t>(GameNode3DOption::VT_SKYBOXMASK, skyBoxMask, 0); }
  void add_skyBoxEnabled(bool skyBoxEnabled) { fbb_.AddElement<uint8_t>(GameNode3DOption::VT_SKYBOXENABLED, static_cast<uint8_t>(skyBoxEnabled), 0); }
  void add_leftFileData(flatbuffers::Offset<flatbuffers::ResourceData> leftFileData) { fbb_.AddOffset(GameNode3DOption::VT_LEFTFILEDATA, leftFileData); }
  void add_rightFileData(flatbuffers::Offset<flatbuffers::ResourceData> rightFileData) { fbb_.AddOffset(GameNode3DOption::VT_RIGHTFILEDATA, rightFileData); }
  void add_upFileData(flatbuffers::Offset<flatbuffers::ResourceData> upFileData) { fbb_.AddOffset(GameNode3DOption::VT_UPFILEDATA, upFileData); }
  void add_downFileData(flatbuffers::Offset<flatbuffers::ResourceData> downFileData) { fbb_.AddOffset(GameNode3DOption::VT_DOWNFILEDATA, downFileData); }
  void add_forwardFileData(flatbuffers::Offset<flatbuffers::ResourceData> forwardFileData) { fbb_.AddOffset(GameNode3DOption::VT_FORWARDFILEDATA, forwardFileData); }
  void add_backFileData(flatbuffers::Offset<flatbuffers::ResourceData> backFileData) { fbb_.AddOffset(GameNode3DOption::VT_BACKFILEDATA, backFileData); }
  void add_frameEvent(flatbuffers::Offset<flatbuffers::String> frameEvent) { fbb_.AddOffset(GameNode3DOption::VT_FRAMEEVENT, frameEvent); }
  void add_customProperty(flatbuffers::Offset<flatbuffers::String> customProperty) { fbb_.AddOffset(GameNode3DOption::VT_CUSTOMPROPERTY, customProperty); }
  void add_useDefaultLight(bool useDefaultLight) { fbb_.AddElement<uint8_t>(GameNode3DOption::VT_USEDEFAULTLIGHT, static_cast<uint8_t>(useDefaultLight), 0); }
  GameNode3DOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  GameNode3DOptionBuilder &operator=(const GameNode3DOptionBuilder &);
  flatbuffers::Offset<GameNode3DOption> Finish() {
    auto o = flatbuffers::Offset<GameNode3DOption>(fbb_.EndTable(start_, 12));
    return o;
  }
};

inline flatbuffers::Offset<GameNode3DOption> CreateGameNode3DOption(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    int32_t skyBoxMask = 0,
    bool skyBoxEnabled = false,
    flatbuffers::Offset<flatbuffers::ResourceData> leftFileData = 0,
    flatbuffers::Offset<flatbuffers::ResourceData> rightFileData = 0,
    flatbuffers::Offset<flatbuffers::ResourceData> upFileData = 0,
    flatbuffers::Offset<flatbuffers::ResourceData> downFileData = 0,
    flatbuffers::Offset<flatbuffers::ResourceData> forwardFileData = 0,
    flatbuffers::Offset<flatbuffers::ResourceData> backFileData = 0,
    flatbuffers::Offset<flatbuffers::String> frameEvent = 0,
    flatbuffers::Offset<flatbuffers::String> customProperty = 0,
    bool useDefaultLight = false) {
  GameNode3DOptionBuilder builder_(_fbb);
  builder_.add_customProperty(customProperty);
  builder_.add_frameEvent(frameEvent);
  builder_.add_backFileData(backFileData);
  builder_.add_forwardFileData(forwardFileData);
  builder_.add_downFileData(downFileData);
  builder_.add_upFileData(upFileData);
  builder_.add_rightFileData(rightFileData);
  builder_.add_leftFileData(leftFileData);
  builder_.add_skyBoxMask(skyBoxMask);
  builder_.add_name(name);
  builder_.add_useDefaultLight(useDefaultLight);
  builder_.add_skyBoxEnabled(skyBoxEnabled);
  return builder_.Finish();
}

inline flatbuffers::Offset<GameNode3DOption> CreateGameNode3DOptionDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    int32_t skyBoxMask = 0,
    bool skyBoxEnabled = false,
    flatbuffers::Offset<flatbuffers::ResourceData> leftFileData = 0,
    flatbuffers::Offset<flatbuffers::ResourceData> rightFileData = 0,
    flatbuffers::Offset<flatbuffers::ResourceData> upFileData = 0,
    flatbuffers::Offset<flatbuffers::ResourceData> downFileData = 0,
    flatbuffers::Offset<flatbuffers::ResourceData> forwardFileData = 0,
    flatbuffers::Offset<flatbuffers::ResourceData> backFileData = 0,
    const char *frameEvent = nullptr,
    const char *customProperty = nullptr,
    bool useDefaultLight = false) {
  return CreateGameNode3DOption(_fbb, name ? _fbb.CreateString(name) : 0, skyBoxMask, skyBoxEnabled, leftFileData, rightFileData, upFileData, downFileData, forwardFileData, backFileData, frameEvent ? _fbb.CreateString(frameEvent) : 0, customProperty ? _fbb.CreateString(customProperty) : 0, useDefaultLight);
}

struct Light3DOption FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE3DOPTION = 4,
    VT_ENABLED = 6,
    VT_TYPE = 8,
    VT_FLAG = 10,
    VT_INTENSITY = 12,
    VT_RANGE = 14,
    VT_OUTERANGLE = 16
  };
  const Node3DOption *node3DOption() const { return GetPointer<const Node3DOption *>(VT_NODE3DOPTION); }
  bool enabled() const { return GetField<uint8_t>(VT_ENABLED, 0) != 0; }
  int32_t type() const { return GetField<int32_t>(VT_TYPE, 0); }
  int32_t flag() const { return GetField<int32_t>(VT_FLAG, 0); }
  float intensity() const { return GetField<float>(VT_INTENSITY, 0.0f); }
  float range() const { return GetField<float>(VT_RANGE, 0.0f); }
  float outerAngle() const { return GetField<float>(VT_OUTERANGLE, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE3DOPTION) &&
           verifier.VerifyTable(node3DOption()) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED) &&
           VerifyField<int32_t>(verifier, VT_TYPE) &&
           VerifyField<int32_t>(verifier, VT_FLAG) &&
           VerifyField<float>(verifier, VT_INTENSITY) &&
           VerifyField<float>(verifier, VT_RANGE) &&
           VerifyField<float>(verifier, VT_OUTERANGLE) &&
           verifier.EndTable();
  }
};

struct Light3DOptionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node3DOption(flatbuffers::Offset<Node3DOption> node3DOption) { fbb_.AddOffset(Light3DOption::VT_NODE3DOPTION, node3DOption); }
  void add_enabled(bool enabled) { fbb_.AddElement<uint8_t>(Light3DOption::VT_ENABLED, static_cast<uint8_t>(enabled), 0); }
  void add_type(int32_t type) { fbb_.AddElement<int32_t>(Light3DOption::VT_TYPE, type, 0); }
  void add_flag(int32_t flag) { fbb_.AddElement<int32_t>(Light3DOption::VT_FLAG, flag, 0); }
  void add_intensity(float intensity) { fbb_.AddElement<float>(Light3DOption::VT_INTENSITY, intensity, 0.0f); }
  void add_range(float range) { fbb_.AddElement<float>(Light3DOption::VT_RANGE, range, 0.0f); }
  void add_outerAngle(float outerAngle) { fbb_.AddElement<float>(Light3DOption::VT_OUTERANGLE, outerAngle, 0.0f); }
  Light3DOptionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  Light3DOptionBuilder &operator=(const Light3DOptionBuilder &);
  flatbuffers::Offset<Light3DOption> Finish() {
    auto o = flatbuffers::Offset<Light3DOption>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<Light3DOption> CreateLight3DOption(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node3DOption> node3DOption = 0,
    bool enabled = false,
    int32_t type = 0,
    int32_t flag = 0,
    float intensity = 0.0f,
    float range = 0.0f,
    float outerAngle = 0.0f) {
  Light3DOptionBuilder builder_(_fbb);
  builder_.add_outerAngle(outerAngle);
  builder_.add_range(range);
  builder_.add_intensity(intensity);
  builder_.add_flag(flag);
  builder_.add_type(type);
  builder_.add_node3DOption(node3DOption);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

inline const flatbuffers::Node3DOption *GetNode3DOption(const void *buf) {
  return flatbuffers::GetRoot<flatbuffers::Node3DOption>(buf);
}

inline bool VerifyNode3DOptionBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<flatbuffers::Node3DOption>(nullptr);
}

inline void FinishNode3DOptionBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<flatbuffers::Node3DOption> root) {
  fbb.Finish(root);
}

}  // namespace flatbuffers

#endif  // FLATBUFFERS_GENERATED_CSPARSE3DBINARY_FLATBUFFERS_H_

// automatically generated by the FlatBuffers compiler, do not modify

#ifndef FLATBUFFERS_GENERATED_CREATORREADER_CREATOR_BUFFERS_H_
#define FLATBUFFERS_GENERATED_CREATORREADER_CREATOR_BUFFERS_H_

#include "flatbuffers/flatbuffers.h"

namespace creator {
namespace buffers {

struct SceneGraph;

struct CollisionLine;

struct NodeTree;

struct SpriteFrame;

struct CreatorScene;

struct Node;

struct Sprite;

struct Label;

struct RichText;

struct Particle;

struct TileMap;

struct Scene;

struct Button;

struct ProgressBar;

struct ScrollView;

struct EditBox;

struct VideoPlayer;

struct WebView;

struct Slider;

struct Toggle;

struct ToggleGroup;

struct Mask;

struct PageViewIndicator;

struct PageViewPage;

struct PageViewBackground;

struct PageView;

struct MotionStreak;

struct SpineSkeleton;

struct AnimationRef;

struct Collider;

struct DragonBones;

struct AnimationClip;

struct AnimCurveData;

struct AnimProps;

struct AnimEvents;

struct AnimPropRotation;

struct AnimPropPosition;

struct AnimPropPositionX;

struct AnimPropPositionY;

struct AnimPropScaleX;

struct AnimPropScaleY;

struct AnimPropWidth;

struct AnimPropHeight;

struct AnimPropColor;

struct AnimPropOpacity;

struct AnimPropAnchorX;

struct AnimPropAnchorY;

struct AnimPropSkewX;

struct AnimPropSkewY;

struct Vec2;

struct Vec3;

struct Size;

struct Rect;

struct ColorRGB;

struct ColorRGBA;

struct LabelOutline;

enum FontType {
  FontType_System = 0,
  FontType_BMFont = 1,
  FontType_TTF = 2,
  FontType_MIN = FontType_System,
  FontType_MAX = FontType_TTF
};

inline const char **EnumNamesFontType() {
  static const char *names[] = { "System", "BMFont", "TTF", nullptr };
  return names;
}

inline const char *EnumNameFontType(FontType e) { return EnumNamesFontType()[static_cast<int>(e)]; }

enum VerticalAlignment {
  VerticalAlignment_Top = 0,
  VerticalAlignment_Center = 1,
  VerticalAlignment_Bottom = 2,
  VerticalAlignment_MIN = VerticalAlignment_Top,
  VerticalAlignment_MAX = VerticalAlignment_Bottom
};

inline const char **EnumNamesVerticalAlignment() {
  static const char *names[] = { "Top", "Center", "Bottom", nullptr };
  return names;
}

inline const char *EnumNameVerticalAlignment(VerticalAlignment e) { return EnumNamesVerticalAlignment()[static_cast<int>(e)]; }

enum HorizontalAlignment {
  HorizontalAlignment_Left = 0,
  HorizontalAlignment_Center = 1,
  HorizontalAlignment_Right = 2,
  HorizontalAlignment_MIN = HorizontalAlignment_Left,
  HorizontalAlignment_MAX = HorizontalAlignment_Right
};

inline const char **EnumNamesHorizontalAlignment() {
  static const char *names[] = { "Left", "Center", "Right", nullptr };
  return names;
}

inline const char *EnumNameHorizontalAlignment(HorizontalAlignment e) { return EnumNamesHorizontalAlignment()[static_cast<int>(e)]; }

enum SpriteType {
  SpriteType_Simple = 0,
  SpriteType_Sliced = 1,
  SpriteType_Tiled = 2,
  SpriteType_Filled = 3,
  SpriteType_MIN = SpriteType_Simple,
  SpriteType_MAX = SpriteType_Filled
};

inline const char **EnumNamesSpriteType() {
  static const char *names[] = { "Simple", "Sliced", "Tiled", "Filled", nullptr };
  return names;
}

inline const char *EnumNameSpriteType(SpriteType e) { return EnumNamesSpriteType()[static_cast<int>(e)]; }

enum SpriteSizeMode {
  SpriteSizeMode_Custom = 0,
  SpriteSizeMode_Trimmed = 1,
  SpriteSizeMode_Raw = 2,
  SpriteSizeMode_MIN = SpriteSizeMode_Custom,
  SpriteSizeMode_MAX = SpriteSizeMode_Raw
};

inline const char **EnumNamesSpriteSizeMode() {
  static const char *names[] = { "Custom", "Trimmed", "Raw", nullptr };
  return names;
}

inline const char *EnumNameSpriteSizeMode(SpriteSizeMode e) { return EnumNamesSpriteSizeMode()[static_cast<int>(e)]; }

enum ScrollViewDirection {
  ScrollViewDirection_None = 0,
  ScrollViewDirection_Vertical = 1,
  ScrollViewDirection_Horizontal = 2,
  ScrollViewDirection_Both = 3,
  ScrollViewDirection_MIN = ScrollViewDirection_None,
  ScrollViewDirection_MAX = ScrollViewDirection_Both
};

inline const char **EnumNamesScrollViewDirection() {
  static const char *names[] = { "None", "Vertical", "Horizontal", "Both", nullptr };
  return names;
}

inline const char *EnumNameScrollViewDirection(ScrollViewDirection e) { return EnumNamesScrollViewDirection()[static_cast<int>(e)]; }

enum EditBoxReturnType {
  EditBoxReturnType_Default = 0,
  EditBoxReturnType_Done = 1,
  EditBoxReturnType_Send = 2,
  EditBoxReturnType_Search = 3,
  EditBoxReturnType_Go = 4,
  EditBoxReturnType_MIN = EditBoxReturnType_Default,
  EditBoxReturnType_MAX = EditBoxReturnType_Go
};

inline const char **EnumNamesEditBoxReturnType() {
  static const char *names[] = { "Default", "Done", "Send", "Search", "Go", nullptr };
  return names;
}

inline const char *EnumNameEditBoxReturnType(EditBoxReturnType e) { return EnumNamesEditBoxReturnType()[static_cast<int>(e)]; }

enum EditBoxInputFlag {
  EditBoxInputFlag_Password = 0,
  EditBoxInputFlag_Sensitive = 1,
  EditBoxInputFlag_InitialCapsWord = 2,
  EditBoxInputFlag_InitialCapsSentence = 3,
  EditBoxInputFlag_InitialCapsAllCharacters = 4,
  EditBoxInputFlag_LowercaseAllCharacters = 5,
  EditBoxInputFlag_MIN = EditBoxInputFlag_Password,
  EditBoxInputFlag_MAX = EditBoxInputFlag_LowercaseAllCharacters
};

inline const char **EnumNamesEditBoxInputFlag() {
  static const char *names[] = { "Password", "Sensitive", "InitialCapsWord", "InitialCapsSentence", "InitialCapsAllCharacters", "LowercaseAllCharacters", nullptr };
  return names;
}

inline const char *EnumNameEditBoxInputFlag(EditBoxInputFlag e) { return EnumNamesEditBoxInputFlag()[static_cast<int>(e)]; }

enum EditBoxInputMode {
  EditBoxInputMode_Any = 0,
  EditBoxInputMode_EmailAddress = 1,
  EditBoxInputMode_Numeric = 2,
  EditBoxInputMode_PhoneNumber = 3,
  EditBoxInputMode_URL = 4,
  EditBoxInputMode_Decime = 5,
  EditBoxInputMode_SingleLine = 6,
  EditBoxInputMode_MIN = EditBoxInputMode_Any,
  EditBoxInputMode_MAX = EditBoxInputMode_SingleLine
};

inline const char **EnumNamesEditBoxInputMode() {
  static const char *names[] = { "Any", "EmailAddress", "Numeric", "PhoneNumber", "URL", "Decime", "SingleLine", nullptr };
  return names;
}

inline const char *EnumNameEditBoxInputMode(EditBoxInputMode e) { return EnumNamesEditBoxInputMode()[static_cast<int>(e)]; }

enum LabelOverflowType {
  LabelOverflowType_None = 0,
  LabelOverflowType_Clamp = 1,
  LabelOverflowType_Shrink = 2,
  LabelOverflowType_ResizeHeight = 3,
  LabelOverflowType_Toggle = 4,
  LabelOverflowType_MIN = LabelOverflowType_None,
  LabelOverflowType_MAX = LabelOverflowType_Toggle
};

inline const char **EnumNamesLabelOverflowType() {
  static const char *names[] = { "None", "Clamp", "Shrink", "ResizeHeight", "Toggle", nullptr };
  return names;
}

inline const char *EnumNameLabelOverflowType(LabelOverflowType e) { return EnumNamesLabelOverflowType()[static_cast<int>(e)]; }

enum MaskType {
  MaskType_Rect = 0,
  MaskType_Ellipse = 1,
  MaskType_ImageStencil = 2,
  MaskType_MIN = MaskType_Rect,
  MaskType_MAX = MaskType_ImageStencil
};

inline const char **EnumNamesMaskType() {
  static const char *names[] = { "Rect", "Ellipse", "ImageStencil", nullptr };
  return names;
}

inline const char *EnumNameMaskType(MaskType e) { return EnumNamesMaskType()[static_cast<int>(e)]; }

enum ColliderType {
  ColliderType_BoxCollider = 0,
  ColliderType_PolygonCollider = 1,
  ColliderType_CircleCollider = 2,
  ColliderType_MIN = ColliderType_BoxCollider,
  ColliderType_MAX = ColliderType_CircleCollider
};

inline const char **EnumNamesColliderType() {
  static const char *names[] = { "BoxCollider", "PolygonCollider", "CircleCollider", nullptr };
  return names;
}

inline const char *EnumNameColliderType(ColliderType e) { return EnumNamesColliderType()[static_cast<int>(e)]; }

enum AnyNode {
  AnyNode_NONE = 0,
  AnyNode_Scene = 1,
  AnyNode_Sprite = 2,
  AnyNode_Label = 3,
  AnyNode_Particle = 4,
  AnyNode_TileMap = 5,
  AnyNode_Node = 6,
  AnyNode_Button = 7,
  AnyNode_ProgressBar = 8,
  AnyNode_ScrollView = 9,
  AnyNode_CreatorScene = 10,
  AnyNode_EditBox = 11,
  AnyNode_RichText = 12,
  AnyNode_SpineSkeleton = 13,
  AnyNode_VideoPlayer = 14,
  AnyNode_WebView = 15,
  AnyNode_Slider = 16,
  AnyNode_Toggle = 17,
  AnyNode_ToggleGroup = 18,
  AnyNode_PageView = 19,
  AnyNode_Mask = 20,
  AnyNode_DragonBones = 21,
  AnyNode_MotionStreak = 22,
  AnyNode_MIN = AnyNode_NONE,
  AnyNode_MAX = AnyNode_MotionStreak
};

inline const char **EnumNamesAnyNode() {
  static const char *names[] = { "NONE", "Scene", "Sprite", "Label", "Particle", "TileMap", "Node", "Button", "ProgressBar", "ScrollView", "CreatorScene", "EditBox", "RichText", "SpineSkeleton", "VideoPlayer", "WebView", "Slider", "Toggle", "ToggleGroup", "PageView", "Mask", "DragonBones", "MotionStreak", nullptr };
  return names;
}

inline const char *EnumNameAnyNode(AnyNode e) { return EnumNamesAnyNode()[static_cast<int>(e)]; }

template<typename T> struct AnyNodeTraits {
  static const AnyNode enum_value = AnyNode_NONE;
};

template<> struct AnyNodeTraits<Scene> {
  static const AnyNode enum_value = AnyNode_Scene;
};

template<> struct AnyNodeTraits<Sprite> {
  static const AnyNode enum_value = AnyNode_Sprite;
};

template<> struct AnyNodeTraits<Label> {
  static const AnyNode enum_value = AnyNode_Label;
};

template<> struct AnyNodeTraits<Particle> {
  static const AnyNode enum_value = AnyNode_Particle;
};

template<> struct AnyNodeTraits<TileMap> {
  static const AnyNode enum_value = AnyNode_TileMap;
};

template<> struct AnyNodeTraits<Node> {
  static const AnyNode enum_value = AnyNode_Node;
};

template<> struct AnyNodeTraits<Button> {
  static const AnyNode enum_value = AnyNode_Button;
};

template<> struct AnyNodeTraits<ProgressBar> {
  static const AnyNode enum_value = AnyNode_ProgressBar;
};

template<> struct AnyNodeTraits<ScrollView> {
  static const AnyNode enum_value = AnyNode_ScrollView;
};

template<> struct AnyNodeTraits<CreatorScene> {
  static const AnyNode enum_value = AnyNode_CreatorScene;
};

template<> struct AnyNodeTraits<EditBox> {
  static const AnyNode enum_value = AnyNode_EditBox;
};

template<> struct AnyNodeTraits<RichText> {
  static const AnyNode enum_value = AnyNode_RichText;
};

template<> struct AnyNodeTraits<SpineSkeleton> {
  static const AnyNode enum_value = AnyNode_SpineSkeleton;
};

template<> struct AnyNodeTraits<VideoPlayer> {
  static const AnyNode enum_value = AnyNode_VideoPlayer;
};

template<> struct AnyNodeTraits<WebView> {
  static const AnyNode enum_value = AnyNode_WebView;
};

template<> struct AnyNodeTraits<Slider> {
  static const AnyNode enum_value = AnyNode_Slider;
};

template<> struct AnyNodeTraits<Toggle> {
  static const AnyNode enum_value = AnyNode_Toggle;
};

template<> struct AnyNodeTraits<ToggleGroup> {
  static const AnyNode enum_value = AnyNode_ToggleGroup;
};

template<> struct AnyNodeTraits<PageView> {
  static const AnyNode enum_value = AnyNode_PageView;
};

template<> struct AnyNodeTraits<Mask> {
  static const AnyNode enum_value = AnyNode_Mask;
};

template<> struct AnyNodeTraits<DragonBones> {
  static const AnyNode enum_value = AnyNode_DragonBones;
};

template<> struct AnyNodeTraits<MotionStreak> {
  static const AnyNode enum_value = AnyNode_MotionStreak;
};

inline bool VerifyAnyNode(flatbuffers::Verifier &verifier, const void *union_obj, AnyNode type);

enum AnimWrapMode {
  AnimWrapMode_Default = 0,
  AnimWrapMode_Normal = 1,
  AnimWrapMode_Loop = 2,
  AnimWrapMode_PingPong = 3,
  AnimWrapMode_Reverse = 4,
  AnimWrapMode_LoopReverse = 5,
  AnimWrapMode_PingPongReverse = 6,
  AnimWrapMode_MIN = AnimWrapMode_Default,
  AnimWrapMode_MAX = AnimWrapMode_PingPongReverse
};

inline const char **EnumNamesAnimWrapMode() {
  static const char *names[] = { "Default", "Normal", "Loop", "PingPong", "Reverse", "LoopReverse", "PingPongReverse", nullptr };
  return names;
}

inline const char *EnumNameAnimWrapMode(AnimWrapMode e) { return EnumNamesAnimWrapMode()[static_cast<int>(e)]; }

MANUALLY_ALIGNED_STRUCT(4) Vec2 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;

 public:
  Vec2() { memset(this, 0, sizeof(Vec2)); }
  Vec2(const Vec2 &_o) { memcpy(this, &_o, sizeof(Vec2)); }
  Vec2(float _x, float _y)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
};
STRUCT_END(Vec2, 8);

MANUALLY_ALIGNED_STRUCT(4) Vec3 FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float z_;

 public:
  Vec3() { memset(this, 0, sizeof(Vec3)); }
  Vec3(const Vec3 &_o) { memcpy(this, &_o, sizeof(Vec3)); }
  Vec3(float _x, float _y, float _z)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)), z_(flatbuffers::EndianScalar(_z)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  float z() const { return flatbuffers::EndianScalar(z_); }
};
STRUCT_END(Vec3, 12);

MANUALLY_ALIGNED_STRUCT(4) Size FLATBUFFERS_FINAL_CLASS {
 private:
  float w_;
  float h_;

 public:
  Size() { memset(this, 0, sizeof(Size)); }
  Size(const Size &_o) { memcpy(this, &_o, sizeof(Size)); }
  Size(float _w, float _h)
    : w_(flatbuffers::EndianScalar(_w)), h_(flatbuffers::EndianScalar(_h)) { }

  float w() const { return flatbuffers::EndianScalar(w_); }
  float h() const { return flatbuffers::EndianScalar(h_); }
};
STRUCT_END(Size, 8);

MANUALLY_ALIGNED_STRUCT(4) Rect FLATBUFFERS_FINAL_CLASS {
 private:
  float x_;
  float y_;
  float w_;
  float h_;

 public:
  Rect() { memset(this, 0, sizeof(Rect)); }
  Rect(const Rect &_o) { memcpy(this, &_o, sizeof(Rect)); }
  Rect(float _x, float _y, float _w, float _h)
    : x_(flatbuffers::EndianScalar(_x)), y_(flatbuffers::EndianScalar(_y)), w_(flatbuffers::EndianScalar(_w)), h_(flatbuffers::EndianScalar(_h)) { }

  float x() const { return flatbuffers::EndianScalar(x_); }
  float y() const { return flatbuffers::EndianScalar(y_); }
  float w() const { return flatbuffers::EndianScalar(w_); }
  float h() const { return flatbuffers::EndianScalar(h_); }
};
STRUCT_END(Rect, 16);

MANUALLY_ALIGNED_STRUCT(1) ColorRGB FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t r_;
  uint8_t g_;
  uint8_t b_;

 public:
  ColorRGB() { memset(this, 0, sizeof(ColorRGB)); }
  ColorRGB(const ColorRGB &_o) { memcpy(this, &_o, sizeof(ColorRGB)); }
  ColorRGB(uint8_t _r, uint8_t _g, uint8_t _b)
    : r_(flatbuffers::EndianScalar(_r)), g_(flatbuffers::EndianScalar(_g)), b_(flatbuffers::EndianScalar(_b)) { }

  uint8_t r() const { return flatbuffers::EndianScalar(r_); }
  uint8_t g() const { return flatbuffers::EndianScalar(g_); }
  uint8_t b() const { return flatbuffers::EndianScalar(b_); }
};
STRUCT_END(ColorRGB, 3);

MANUALLY_ALIGNED_STRUCT(1) ColorRGBA FLATBUFFERS_FINAL_CLASS {
 private:
  uint8_t r_;
  uint8_t g_;
  uint8_t b_;
  uint8_t a_;

 public:
  ColorRGBA() { memset(this, 0, sizeof(ColorRGBA)); }
  ColorRGBA(const ColorRGBA &_o) { memcpy(this, &_o, sizeof(ColorRGBA)); }
  ColorRGBA(uint8_t _r, uint8_t _g, uint8_t _b, uint8_t _a)
    : r_(flatbuffers::EndianScalar(_r)), g_(flatbuffers::EndianScalar(_g)), b_(flatbuffers::EndianScalar(_b)), a_(flatbuffers::EndianScalar(_a)) { }

  uint8_t r() const { return flatbuffers::EndianScalar(r_); }
  uint8_t g() const { return flatbuffers::EndianScalar(g_); }
  uint8_t b() const { return flatbuffers::EndianScalar(b_); }
  uint8_t a() const { return flatbuffers::EndianScalar(a_); }
};
STRUCT_END(ColorRGBA, 4);

struct SceneGraph FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VERSION = 4,
    VT_ROOT = 6,
    VT_DESIGNRESOLUTION = 8,
    VT_RESOLUTIONFITWIDTH = 10,
    VT_RESOLUTIONFITHEIGHT = 12,
    VT_SPRITEFRAMES = 14,
    VT_COLLISIONMATRIX = 16
  };
  const flatbuffers::String *version() const { return GetPointer<const flatbuffers::String *>(VT_VERSION); }
  const NodeTree *root() const { return GetPointer<const NodeTree *>(VT_ROOT); }
  const Size *designResolution() const { return GetStruct<const Size *>(VT_DESIGNRESOLUTION); }
  bool resolutionFitWidth() const { return GetField<uint8_t>(VT_RESOLUTIONFITWIDTH, 0) != 0; }
  bool resolutionFitHeight() const { return GetField<uint8_t>(VT_RESOLUTIONFITHEIGHT, 0) != 0; }
  const flatbuffers::Vector<flatbuffers::Offset<SpriteFrame>> *spriteFrames() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<SpriteFrame>> *>(VT_SPRITEFRAMES); }
  const flatbuffers::Vector<flatbuffers::Offset<CollisionLine>> *collisionMatrix() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<CollisionLine>> *>(VT_COLLISIONMATRIX); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VERSION) &&
           verifier.Verify(version()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ROOT) &&
           verifier.VerifyTable(root()) &&
           VerifyField<Size>(verifier, VT_DESIGNRESOLUTION) &&
           VerifyField<uint8_t>(verifier, VT_RESOLUTIONFITWIDTH) &&
           VerifyField<uint8_t>(verifier, VT_RESOLUTIONFITHEIGHT) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SPRITEFRAMES) &&
           verifier.Verify(spriteFrames()) &&
           verifier.VerifyVectorOfTables(spriteFrames()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_COLLISIONMATRIX) &&
           verifier.Verify(collisionMatrix()) &&
           verifier.VerifyVectorOfTables(collisionMatrix()) &&
           verifier.EndTable();
  }
};

struct SceneGraphBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_version(flatbuffers::Offset<flatbuffers::String> version) { fbb_.AddOffset(SceneGraph::VT_VERSION, version); }
  void add_root(flatbuffers::Offset<NodeTree> root) { fbb_.AddOffset(SceneGraph::VT_ROOT, root); }
  void add_designResolution(const Size *designResolution) { fbb_.AddStruct(SceneGraph::VT_DESIGNRESOLUTION, designResolution); }
  void add_resolutionFitWidth(bool resolutionFitWidth) { fbb_.AddElement<uint8_t>(SceneGraph::VT_RESOLUTIONFITWIDTH, static_cast<uint8_t>(resolutionFitWidth), 0); }
  void add_resolutionFitHeight(bool resolutionFitHeight) { fbb_.AddElement<uint8_t>(SceneGraph::VT_RESOLUTIONFITHEIGHT, static_cast<uint8_t>(resolutionFitHeight), 0); }
  void add_spriteFrames(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SpriteFrame>>> spriteFrames) { fbb_.AddOffset(SceneGraph::VT_SPRITEFRAMES, spriteFrames); }
  void add_collisionMatrix(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CollisionLine>>> collisionMatrix) { fbb_.AddOffset(SceneGraph::VT_COLLISIONMATRIX, collisionMatrix); }
  SceneGraphBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SceneGraphBuilder &operator=(const SceneGraphBuilder &);
  flatbuffers::Offset<SceneGraph> Finish() {
    auto o = flatbuffers::Offset<SceneGraph>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<SceneGraph> CreateSceneGraph(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> version = 0,
    flatbuffers::Offset<NodeTree> root = 0,
    const Size *designResolution = 0,
    bool resolutionFitWidth = false,
    bool resolutionFitHeight = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<SpriteFrame>>> spriteFrames = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<CollisionLine>>> collisionMatrix = 0) {
  SceneGraphBuilder builder_(_fbb);
  builder_.add_collisionMatrix(collisionMatrix);
  builder_.add_spriteFrames(spriteFrames);
  builder_.add_designResolution(designResolution);
  builder_.add_root(root);
  builder_.add_version(version);
  builder_.add_resolutionFitHeight(resolutionFitHeight);
  builder_.add_resolutionFitWidth(resolutionFitWidth);
  return builder_.Finish();
}

inline flatbuffers::Offset<SceneGraph> CreateSceneGraphDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *version = nullptr,
    flatbuffers::Offset<NodeTree> root = 0,
    const Size *designResolution = 0,
    bool resolutionFitWidth = false,
    bool resolutionFitHeight = false,
    const std::vector<flatbuffers::Offset<SpriteFrame>> *spriteFrames = nullptr,
    const std::vector<flatbuffers::Offset<CollisionLine>> *collisionMatrix = nullptr) {
  return CreateSceneGraph(_fbb, version ? _fbb.CreateString(version) : 0, root, designResolution, resolutionFitWidth, resolutionFitHeight, spriteFrames ? _fbb.CreateVector<flatbuffers::Offset<SpriteFrame>>(*spriteFrames) : 0, collisionMatrix ? _fbb.CreateVector<flatbuffers::Offset<CollisionLine>>(*collisionMatrix) : 0);
}

struct CollisionLine FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_VALUE = 4
  };
  const flatbuffers::Vector<uint8_t> *value() const { return GetPointer<const flatbuffers::Vector<uint8_t> *>(VT_VALUE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_VALUE) &&
           verifier.Verify(value()) &&
           verifier.EndTable();
  }
};

struct CollisionLineBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_value(flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value) { fbb_.AddOffset(CollisionLine::VT_VALUE, value); }
  CollisionLineBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  CollisionLineBuilder &operator=(const CollisionLineBuilder &);
  flatbuffers::Offset<CollisionLine> Finish() {
    auto o = flatbuffers::Offset<CollisionLine>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<CollisionLine> CreateCollisionLine(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<uint8_t>> value = 0) {
  CollisionLineBuilder builder_(_fbb);
  builder_.add_value(value);
  return builder_.Finish();
}

inline flatbuffers::Offset<CollisionLine> CreateCollisionLineDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<uint8_t> *value = nullptr) {
  return CreateCollisionLine(_fbb, value ? _fbb.CreateVector<uint8_t>(*value) : 0);
}

struct NodeTree FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CHILDREN = 4,
    VT_OBJECT_TYPE = 6,
    VT_OBJECT = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<NodeTree>> *children() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<NodeTree>> *>(VT_CHILDREN); }
  AnyNode object_type() const { return static_cast<AnyNode>(GetField<uint8_t>(VT_OBJECT_TYPE, 0)); }
  const void *object() const { return GetPointer<const void *>(VT_OBJECT); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CHILDREN) &&
           verifier.Verify(children()) &&
           verifier.VerifyVectorOfTables(children()) &&
           VerifyField<uint8_t>(verifier, VT_OBJECT_TYPE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_OBJECT) &&
           VerifyAnyNode(verifier, object(), object_type()) &&
           verifier.EndTable();
  }
};

struct NodeTreeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_children(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeTree>>> children) { fbb_.AddOffset(NodeTree::VT_CHILDREN, children); }
  void add_object_type(AnyNode object_type) { fbb_.AddElement<uint8_t>(NodeTree::VT_OBJECT_TYPE, static_cast<uint8_t>(object_type), 0); }
  void add_object(flatbuffers::Offset<void> object) { fbb_.AddOffset(NodeTree::VT_OBJECT, object); }
  NodeTreeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  NodeTreeBuilder &operator=(const NodeTreeBuilder &);
  flatbuffers::Offset<NodeTree> Finish() {
    auto o = flatbuffers::Offset<NodeTree>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<NodeTree> CreateNodeTree(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<NodeTree>>> children = 0,
    AnyNode object_type = AnyNode_NONE,
    flatbuffers::Offset<void> object = 0) {
  NodeTreeBuilder builder_(_fbb);
  builder_.add_object(object);
  builder_.add_children(children);
  builder_.add_object_type(object_type);
  return builder_.Finish();
}

inline flatbuffers::Offset<NodeTree> CreateNodeTreeDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<NodeTree>> *children = nullptr,
    AnyNode object_type = AnyNode_NONE,
    flatbuffers::Offset<void> object = 0) {
  return CreateNodeTree(_fbb, children ? _fbb.CreateVector<flatbuffers::Offset<NodeTree>>(*children) : 0, object_type, object);
}

struct SpriteFrame FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_TEXTUREPATH = 6,
    VT_RECT = 8,
    VT_OFFSET = 10,
    VT_ROTATED = 12,
    VT_ORIGINALSIZE = 14,
    VT_CENTERRECT = 16
  };
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  const flatbuffers::String *texturePath() const { return GetPointer<const flatbuffers::String *>(VT_TEXTUREPATH); }
  const Rect *rect() const { return GetStruct<const Rect *>(VT_RECT); }
  const Vec2 *offset() const { return GetStruct<const Vec2 *>(VT_OFFSET); }
  bool rotated() const { return GetField<uint8_t>(VT_ROTATED, 0) != 0; }
  const Size *originalSize() const { return GetStruct<const Size *>(VT_ORIGINALSIZE); }
  const Rect *centerRect() const { return GetStruct<const Rect *>(VT_CENTERRECT); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TEXTUREPATH) &&
           verifier.Verify(texturePath()) &&
           VerifyField<Rect>(verifier, VT_RECT) &&
           VerifyField<Vec2>(verifier, VT_OFFSET) &&
           VerifyField<uint8_t>(verifier, VT_ROTATED) &&
           VerifyField<Size>(verifier, VT_ORIGINALSIZE) &&
           VerifyField<Rect>(verifier, VT_CENTERRECT) &&
           verifier.EndTable();
  }
};

struct SpriteFrameBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(SpriteFrame::VT_NAME, name); }
  void add_texturePath(flatbuffers::Offset<flatbuffers::String> texturePath) { fbb_.AddOffset(SpriteFrame::VT_TEXTUREPATH, texturePath); }
  void add_rect(const Rect *rect) { fbb_.AddStruct(SpriteFrame::VT_RECT, rect); }
  void add_offset(const Vec2 *offset) { fbb_.AddStruct(SpriteFrame::VT_OFFSET, offset); }
  void add_rotated(bool rotated) { fbb_.AddElement<uint8_t>(SpriteFrame::VT_ROTATED, static_cast<uint8_t>(rotated), 0); }
  void add_originalSize(const Size *originalSize) { fbb_.AddStruct(SpriteFrame::VT_ORIGINALSIZE, originalSize); }
  void add_centerRect(const Rect *centerRect) { fbb_.AddStruct(SpriteFrame::VT_CENTERRECT, centerRect); }
  SpriteFrameBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SpriteFrameBuilder &operator=(const SpriteFrameBuilder &);
  flatbuffers::Offset<SpriteFrame> Finish() {
    auto o = flatbuffers::Offset<SpriteFrame>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<SpriteFrame> CreateSpriteFrame(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    flatbuffers::Offset<flatbuffers::String> texturePath = 0,
    const Rect *rect = 0,
    const Vec2 *offset = 0,
    bool rotated = false,
    const Size *originalSize = 0,
    const Rect *centerRect = 0) {
  SpriteFrameBuilder builder_(_fbb);
  builder_.add_centerRect(centerRect);
  builder_.add_originalSize(originalSize);
  builder_.add_offset(offset);
  builder_.add_rect(rect);
  builder_.add_texturePath(texturePath);
  builder_.add_name(name);
  builder_.add_rotated(rotated);
  return builder_.Finish();
}

inline flatbuffers::Offset<SpriteFrame> CreateSpriteFrameDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    const char *texturePath = nullptr,
    const Rect *rect = 0,
    const Vec2 *offset = 0,
    bool rotated = false,
    const Size *originalSize = 0,
    const Rect *centerRect = 0) {
  return CreateSpriteFrame(_fbb, name ? _fbb.CreateString(name) : 0, texturePath ? _fbb.CreateString(texturePath) : 0, rect, offset, rotated, originalSize, centerRect);
}

struct CreatorScene FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FILENAME = 4
  };
  const flatbuffers::String *filename() const { return GetPointer<const flatbuffers::String *>(VT_FILENAME); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FILENAME) &&
           verifier.Verify(filename()) &&
           verifier.EndTable();
  }
};

struct CreatorSceneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_filename(flatbuffers::Offset<flatbuffers::String> filename) { fbb_.AddOffset(CreatorScene::VT_FILENAME, filename); }
  CreatorSceneBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  CreatorSceneBuilder &operator=(const CreatorSceneBuilder &);
  flatbuffers::Offset<CreatorScene> Finish() {
    auto o = flatbuffers::Offset<CreatorScene>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<CreatorScene> CreateCreatorScene(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> filename = 0) {
  CreatorSceneBuilder builder_(_fbb);
  builder_.add_filename(filename);
  return builder_.Finish();
}

inline flatbuffers::Offset<CreatorScene> CreateCreatorSceneDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *filename = nullptr) {
  return CreateCreatorScene(_fbb, filename ? _fbb.CreateString(filename) : 0);
}

struct Node FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CONTENTSIZE = 4,
    VT_ENABLED = 6,
    VT_NAME = 8,
    VT_ANCHORPOINT = 10,
    VT_CASCADEOPACITYENABLED = 12,
    VT_COLOR = 14,
    VT_GLOBALZORDER = 16,
    VT_LOCALZORDER = 18,
    VT_OPACITY = 20,
    VT_OPACITYMODIFYRGB = 22,
    VT_POSITION = 24,
    VT_ROTATIONSKEWX = 26,
    VT_ROTATIONSKEWY = 28,
    VT_SCALEX = 30,
    VT_SCALEY = 32,
    VT_SKEWX = 34,
    VT_SKEWY = 36,
    VT_TAG = 38,
    VT_ANIM = 40,
    VT_COLLIDERS = 42,
    VT_GROUPINDEX = 44
  };
  const Size *contentSize() const { return GetStruct<const Size *>(VT_CONTENTSIZE); }
  bool enabled() const { return GetField<uint8_t>(VT_ENABLED, 1) != 0; }
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  const Vec2 *anchorPoint() const { return GetStruct<const Vec2 *>(VT_ANCHORPOINT); }
  bool cascadeOpacityEnabled() const { return GetField<uint8_t>(VT_CASCADEOPACITYENABLED, 1) != 0; }
  const ColorRGB *color() const { return GetStruct<const ColorRGB *>(VT_COLOR); }
  float globalZOrder() const { return GetField<float>(VT_GLOBALZORDER, 0.0f); }
  int32_t localZOrder() const { return GetField<int32_t>(VT_LOCALZORDER, 0); }
  uint8_t opacity() const { return GetField<uint8_t>(VT_OPACITY, 255); }
  bool opacityModifyRGB() const { return GetField<uint8_t>(VT_OPACITYMODIFYRGB, 1) != 0; }
  const Vec2 *position() const { return GetStruct<const Vec2 *>(VT_POSITION); }
  float rotationSkewX() const { return GetField<float>(VT_ROTATIONSKEWX, 0.0f); }
  float rotationSkewY() const { return GetField<float>(VT_ROTATIONSKEWY, 0.0f); }
  float scaleX() const { return GetField<float>(VT_SCALEX, 1.0f); }
  float scaleY() const { return GetField<float>(VT_SCALEY, 1.0f); }
  float skewX() const { return GetField<float>(VT_SKEWX, 0.0f); }
  float skewY() const { return GetField<float>(VT_SKEWY, 0.0f); }
  int32_t tag() const { return GetField<int32_t>(VT_TAG, 0); }
  const AnimationRef *anim() const { return GetPointer<const AnimationRef *>(VT_ANIM); }
  const flatbuffers::Vector<flatbuffers::Offset<Collider>> *colliders() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Collider>> *>(VT_COLLIDERS); }
  int32_t groupIndex() const { return GetField<int32_t>(VT_GROUPINDEX, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Size>(verifier, VT_CONTENTSIZE) &&
           VerifyField<uint8_t>(verifier, VT_ENABLED) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<Vec2>(verifier, VT_ANCHORPOINT) &&
           VerifyField<uint8_t>(verifier, VT_CASCADEOPACITYENABLED) &&
           VerifyField<ColorRGB>(verifier, VT_COLOR) &&
           VerifyField<float>(verifier, VT_GLOBALZORDER) &&
           VerifyField<int32_t>(verifier, VT_LOCALZORDER) &&
           VerifyField<uint8_t>(verifier, VT_OPACITY) &&
           VerifyField<uint8_t>(verifier, VT_OPACITYMODIFYRGB) &&
           VerifyField<Vec2>(verifier, VT_POSITION) &&
           VerifyField<float>(verifier, VT_ROTATIONSKEWX) &&
           VerifyField<float>(verifier, VT_ROTATIONSKEWY) &&
           VerifyField<float>(verifier, VT_SCALEX) &&
           VerifyField<float>(verifier, VT_SCALEY) &&
           VerifyField<float>(verifier, VT_SKEWX) &&
           VerifyField<float>(verifier, VT_SKEWY) &&
           VerifyField<int32_t>(verifier, VT_TAG) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ANIM) &&
           verifier.VerifyTable(anim()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_COLLIDERS) &&
           verifier.Verify(colliders()) &&
           verifier.VerifyVectorOfTables(colliders()) &&
           VerifyField<int32_t>(verifier, VT_GROUPINDEX) &&
           verifier.EndTable();
  }
};

struct NodeBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_contentSize(const Size *contentSize) { fbb_.AddStruct(Node::VT_CONTENTSIZE, contentSize); }
  void add_enabled(bool enabled) { fbb_.AddElement<uint8_t>(Node::VT_ENABLED, static_cast<uint8_t>(enabled), 1); }
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(Node::VT_NAME, name); }
  void add_anchorPoint(const Vec2 *anchorPoint) { fbb_.AddStruct(Node::VT_ANCHORPOINT, anchorPoint); }
  void add_cascadeOpacityEnabled(bool cascadeOpacityEnabled) { fbb_.AddElement<uint8_t>(Node::VT_CASCADEOPACITYENABLED, static_cast<uint8_t>(cascadeOpacityEnabled), 1); }
  void add_color(const ColorRGB *color) { fbb_.AddStruct(Node::VT_COLOR, color); }
  void add_globalZOrder(float globalZOrder) { fbb_.AddElement<float>(Node::VT_GLOBALZORDER, globalZOrder, 0.0f); }
  void add_localZOrder(int32_t localZOrder) { fbb_.AddElement<int32_t>(Node::VT_LOCALZORDER, localZOrder, 0); }
  void add_opacity(uint8_t opacity) { fbb_.AddElement<uint8_t>(Node::VT_OPACITY, opacity, 255); }
  void add_opacityModifyRGB(bool opacityModifyRGB) { fbb_.AddElement<uint8_t>(Node::VT_OPACITYMODIFYRGB, static_cast<uint8_t>(opacityModifyRGB), 1); }
  void add_position(const Vec2 *position) { fbb_.AddStruct(Node::VT_POSITION, position); }
  void add_rotationSkewX(float rotationSkewX) { fbb_.AddElement<float>(Node::VT_ROTATIONSKEWX, rotationSkewX, 0.0f); }
  void add_rotationSkewY(float rotationSkewY) { fbb_.AddElement<float>(Node::VT_ROTATIONSKEWY, rotationSkewY, 0.0f); }
  void add_scaleX(float scaleX) { fbb_.AddElement<float>(Node::VT_SCALEX, scaleX, 1.0f); }
  void add_scaleY(float scaleY) { fbb_.AddElement<float>(Node::VT_SCALEY, scaleY, 1.0f); }
  void add_skewX(float skewX) { fbb_.AddElement<float>(Node::VT_SKEWX, skewX, 0.0f); }
  void add_skewY(float skewY) { fbb_.AddElement<float>(Node::VT_SKEWY, skewY, 0.0f); }
  void add_tag(int32_t tag) { fbb_.AddElement<int32_t>(Node::VT_TAG, tag, 0); }
  void add_anim(flatbuffers::Offset<AnimationRef> anim) { fbb_.AddOffset(Node::VT_ANIM, anim); }
  void add_colliders(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Collider>>> colliders) { fbb_.AddOffset(Node::VT_COLLIDERS, colliders); }
  void add_groupIndex(int32_t groupIndex) { fbb_.AddElement<int32_t>(Node::VT_GROUPINDEX, groupIndex, 0); }
  NodeBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  NodeBuilder &operator=(const NodeBuilder &);
  flatbuffers::Offset<Node> Finish() {
    auto o = flatbuffers::Offset<Node>(fbb_.EndTable(start_, 21));
    return o;
  }
};

inline flatbuffers::Offset<Node> CreateNode(flatbuffers::FlatBufferBuilder &_fbb,
    const Size *contentSize = 0,
    bool enabled = true,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    const Vec2 *anchorPoint = 0,
    bool cascadeOpacityEnabled = true,
    const ColorRGB *color = 0,
    float globalZOrder = 0.0f,
    int32_t localZOrder = 0,
    uint8_t opacity = 255,
    bool opacityModifyRGB = true,
    const Vec2 *position = 0,
    float rotationSkewX = 0.0f,
    float rotationSkewY = 0.0f,
    float scaleX = 1.0f,
    float scaleY = 1.0f,
    float skewX = 0.0f,
    float skewY = 0.0f,
    int32_t tag = 0,
    flatbuffers::Offset<AnimationRef> anim = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Collider>>> colliders = 0,
    int32_t groupIndex = 0) {
  NodeBuilder builder_(_fbb);
  builder_.add_groupIndex(groupIndex);
  builder_.add_colliders(colliders);
  builder_.add_anim(anim);
  builder_.add_tag(tag);
  builder_.add_skewY(skewY);
  builder_.add_skewX(skewX);
  builder_.add_scaleY(scaleY);
  builder_.add_scaleX(scaleX);
  builder_.add_rotationSkewY(rotationSkewY);
  builder_.add_rotationSkewX(rotationSkewX);
  builder_.add_position(position);
  builder_.add_localZOrder(localZOrder);
  builder_.add_globalZOrder(globalZOrder);
  builder_.add_color(color);
  builder_.add_anchorPoint(anchorPoint);
  builder_.add_name(name);
  builder_.add_contentSize(contentSize);
  builder_.add_opacityModifyRGB(opacityModifyRGB);
  builder_.add_opacity(opacity);
  builder_.add_cascadeOpacityEnabled(cascadeOpacityEnabled);
  builder_.add_enabled(enabled);
  return builder_.Finish();
}

inline flatbuffers::Offset<Node> CreateNodeDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const Size *contentSize = 0,
    bool enabled = true,
    const char *name = nullptr,
    const Vec2 *anchorPoint = 0,
    bool cascadeOpacityEnabled = true,
    const ColorRGB *color = 0,
    float globalZOrder = 0.0f,
    int32_t localZOrder = 0,
    uint8_t opacity = 255,
    bool opacityModifyRGB = true,
    const Vec2 *position = 0,
    float rotationSkewX = 0.0f,
    float rotationSkewY = 0.0f,
    float scaleX = 1.0f,
    float scaleY = 1.0f,
    float skewX = 0.0f,
    float skewY = 0.0f,
    int32_t tag = 0,
    flatbuffers::Offset<AnimationRef> anim = 0,
    const std::vector<flatbuffers::Offset<Collider>> *colliders = nullptr,
    int32_t groupIndex = 0) {
  return CreateNode(_fbb, contentSize, enabled, name ? _fbb.CreateString(name) : 0, anchorPoint, cascadeOpacityEnabled, color, globalZOrder, localZOrder, opacity, opacityModifyRGB, position, rotationSkewX, rotationSkewY, scaleX, scaleY, skewX, skewY, tag, anim, colliders ? _fbb.CreateVector<flatbuffers::Offset<Collider>>(*colliders) : 0, groupIndex);
}

struct Sprite FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_SPRITEFRAMENAME = 6,
    VT_SPRITETYPE = 8,
    VT_SRCBLEND = 10,
    VT_DSTBLEND = 12,
    VT_TRIMENABLED = 14,
    VT_SIZEMODE = 16
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *spriteFrameName() const { return GetPointer<const flatbuffers::String *>(VT_SPRITEFRAMENAME); }
  SpriteType spriteType() const { return static_cast<SpriteType>(GetField<int8_t>(VT_SPRITETYPE, 0)); }
  int32_t srcBlend() const { return GetField<int32_t>(VT_SRCBLEND, 770); }
  int32_t dstBlend() const { return GetField<int32_t>(VT_DSTBLEND, 771); }
  bool trimEnabled() const { return GetField<uint8_t>(VT_TRIMENABLED, 0) != 0; }
  SpriteSizeMode sizeMode() const { return static_cast<SpriteSizeMode>(GetField<int8_t>(VT_SIZEMODE, 0)); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SPRITEFRAMENAME) &&
           verifier.Verify(spriteFrameName()) &&
           VerifyField<int8_t>(verifier, VT_SPRITETYPE) &&
           VerifyField<int32_t>(verifier, VT_SRCBLEND) &&
           VerifyField<int32_t>(verifier, VT_DSTBLEND) &&
           VerifyField<uint8_t>(verifier, VT_TRIMENABLED) &&
           VerifyField<int8_t>(verifier, VT_SIZEMODE) &&
           verifier.EndTable();
  }
};

struct SpriteBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(Sprite::VT_NODE, node); }
  void add_spriteFrameName(flatbuffers::Offset<flatbuffers::String> spriteFrameName) { fbb_.AddOffset(Sprite::VT_SPRITEFRAMENAME, spriteFrameName); }
  void add_spriteType(SpriteType spriteType) { fbb_.AddElement<int8_t>(Sprite::VT_SPRITETYPE, static_cast<int8_t>(spriteType), 0); }
  void add_srcBlend(int32_t srcBlend) { fbb_.AddElement<int32_t>(Sprite::VT_SRCBLEND, srcBlend, 770); }
  void add_dstBlend(int32_t dstBlend) { fbb_.AddElement<int32_t>(Sprite::VT_DSTBLEND, dstBlend, 771); }
  void add_trimEnabled(bool trimEnabled) { fbb_.AddElement<uint8_t>(Sprite::VT_TRIMENABLED, static_cast<uint8_t>(trimEnabled), 0); }
  void add_sizeMode(SpriteSizeMode sizeMode) { fbb_.AddElement<int8_t>(Sprite::VT_SIZEMODE, static_cast<int8_t>(sizeMode), 0); }
  SpriteBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SpriteBuilder &operator=(const SpriteBuilder &);
  flatbuffers::Offset<Sprite> Finish() {
    auto o = flatbuffers::Offset<Sprite>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<Sprite> CreateSprite(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> spriteFrameName = 0,
    SpriteType spriteType = SpriteType_Simple,
    int32_t srcBlend = 770,
    int32_t dstBlend = 771,
    bool trimEnabled = false,
    SpriteSizeMode sizeMode = SpriteSizeMode_Custom) {
  SpriteBuilder builder_(_fbb);
  builder_.add_dstBlend(dstBlend);
  builder_.add_srcBlend(srcBlend);
  builder_.add_spriteFrameName(spriteFrameName);
  builder_.add_node(node);
  builder_.add_sizeMode(sizeMode);
  builder_.add_trimEnabled(trimEnabled);
  builder_.add_spriteType(spriteType);
  return builder_.Finish();
}

inline flatbuffers::Offset<Sprite> CreateSpriteDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *spriteFrameName = nullptr,
    SpriteType spriteType = SpriteType_Simple,
    int32_t srcBlend = 770,
    int32_t dstBlend = 771,
    bool trimEnabled = false,
    SpriteSizeMode sizeMode = SpriteSizeMode_Custom) {
  return CreateSprite(_fbb, node, spriteFrameName ? _fbb.CreateString(spriteFrameName) : 0, spriteType, srcBlend, dstBlend, trimEnabled, sizeMode);
}

struct Label FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_LABELTEXT = 6,
    VT_HORIZONTALALIGNMENT = 8,
    VT_VERTICALALIGNMENT = 10,
    VT_LINEHEIGHT = 12,
    VT_FONTNAME = 14,
    VT_FONTSIZE = 16,
    VT_FONTTYPE = 18,
    VT_OVERFLOWTYPE = 20,
    VT_ENABLEWRAP = 22,
    VT_OUTLINE = 24
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *labelText() const { return GetPointer<const flatbuffers::String *>(VT_LABELTEXT); }
  HorizontalAlignment horizontalAlignment() const { return static_cast<HorizontalAlignment>(GetField<int8_t>(VT_HORIZONTALALIGNMENT, 0)); }
  VerticalAlignment verticalAlignment() const { return static_cast<VerticalAlignment>(GetField<int8_t>(VT_VERTICALALIGNMENT, 0)); }
  float lineHeight() const { return GetField<float>(VT_LINEHEIGHT, 0.0f); }
  const flatbuffers::String *fontName() const { return GetPointer<const flatbuffers::String *>(VT_FONTNAME); }
  float fontSize() const { return GetField<float>(VT_FONTSIZE, 0.0f); }
  FontType fontType() const { return static_cast<FontType>(GetField<int8_t>(VT_FONTTYPE, 0)); }
  LabelOverflowType overflowType() const { return static_cast<LabelOverflowType>(GetField<int8_t>(VT_OVERFLOWTYPE, 0)); }
  bool enableWrap() const { return GetField<uint8_t>(VT_ENABLEWRAP, 0) != 0; }
  const LabelOutline *outline() const { return GetPointer<const LabelOutline *>(VT_OUTLINE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_LABELTEXT) &&
           verifier.Verify(labelText()) &&
           VerifyField<int8_t>(verifier, VT_HORIZONTALALIGNMENT) &&
           VerifyField<int8_t>(verifier, VT_VERTICALALIGNMENT) &&
           VerifyField<float>(verifier, VT_LINEHEIGHT) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FONTNAME) &&
           verifier.Verify(fontName()) &&
           VerifyField<float>(verifier, VT_FONTSIZE) &&
           VerifyField<int8_t>(verifier, VT_FONTTYPE) &&
           VerifyField<int8_t>(verifier, VT_OVERFLOWTYPE) &&
           VerifyField<uint8_t>(verifier, VT_ENABLEWRAP) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_OUTLINE) &&
           verifier.VerifyTable(outline()) &&
           verifier.EndTable();
  }
};

struct LabelBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(Label::VT_NODE, node); }
  void add_labelText(flatbuffers::Offset<flatbuffers::String> labelText) { fbb_.AddOffset(Label::VT_LABELTEXT, labelText); }
  void add_horizontalAlignment(HorizontalAlignment horizontalAlignment) { fbb_.AddElement<int8_t>(Label::VT_HORIZONTALALIGNMENT, static_cast<int8_t>(horizontalAlignment), 0); }
  void add_verticalAlignment(VerticalAlignment verticalAlignment) { fbb_.AddElement<int8_t>(Label::VT_VERTICALALIGNMENT, static_cast<int8_t>(verticalAlignment), 0); }
  void add_lineHeight(float lineHeight) { fbb_.AddElement<float>(Label::VT_LINEHEIGHT, lineHeight, 0.0f); }
  void add_fontName(flatbuffers::Offset<flatbuffers::String> fontName) { fbb_.AddOffset(Label::VT_FONTNAME, fontName); }
  void add_fontSize(float fontSize) { fbb_.AddElement<float>(Label::VT_FONTSIZE, fontSize, 0.0f); }
  void add_fontType(FontType fontType) { fbb_.AddElement<int8_t>(Label::VT_FONTTYPE, static_cast<int8_t>(fontType), 0); }
  void add_overflowType(LabelOverflowType overflowType) { fbb_.AddElement<int8_t>(Label::VT_OVERFLOWTYPE, static_cast<int8_t>(overflowType), 0); }
  void add_enableWrap(bool enableWrap) { fbb_.AddElement<uint8_t>(Label::VT_ENABLEWRAP, static_cast<uint8_t>(enableWrap), 0); }
  void add_outline(flatbuffers::Offset<LabelOutline> outline) { fbb_.AddOffset(Label::VT_OUTLINE, outline); }
  LabelBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LabelBuilder &operator=(const LabelBuilder &);
  flatbuffers::Offset<Label> Finish() {
    auto o = flatbuffers::Offset<Label>(fbb_.EndTable(start_, 11));
    return o;
  }
};

inline flatbuffers::Offset<Label> CreateLabel(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> labelText = 0,
    HorizontalAlignment horizontalAlignment = HorizontalAlignment_Left,
    VerticalAlignment verticalAlignment = VerticalAlignment_Top,
    float lineHeight = 0.0f,
    flatbuffers::Offset<flatbuffers::String> fontName = 0,
    float fontSize = 0.0f,
    FontType fontType = FontType_System,
    LabelOverflowType overflowType = LabelOverflowType_None,
    bool enableWrap = false,
    flatbuffers::Offset<LabelOutline> outline = 0) {
  LabelBuilder builder_(_fbb);
  builder_.add_outline(outline);
  builder_.add_fontSize(fontSize);
  builder_.add_fontName(fontName);
  builder_.add_lineHeight(lineHeight);
  builder_.add_labelText(labelText);
  builder_.add_node(node);
  builder_.add_enableWrap(enableWrap);
  builder_.add_overflowType(overflowType);
  builder_.add_fontType(fontType);
  builder_.add_verticalAlignment(verticalAlignment);
  builder_.add_horizontalAlignment(horizontalAlignment);
  return builder_.Finish();
}

inline flatbuffers::Offset<Label> CreateLabelDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *labelText = nullptr,
    HorizontalAlignment horizontalAlignment = HorizontalAlignment_Left,
    VerticalAlignment verticalAlignment = VerticalAlignment_Top,
    float lineHeight = 0.0f,
    const char *fontName = nullptr,
    float fontSize = 0.0f,
    FontType fontType = FontType_System,
    LabelOverflowType overflowType = LabelOverflowType_None,
    bool enableWrap = false,
    flatbuffers::Offset<LabelOutline> outline = 0) {
  return CreateLabel(_fbb, node, labelText ? _fbb.CreateString(labelText) : 0, horizontalAlignment, verticalAlignment, lineHeight, fontName ? _fbb.CreateString(fontName) : 0, fontSize, fontType, overflowType, enableWrap, outline);
}

struct RichText FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_TEXT = 6,
    VT_HORIZONTALALIGNMENT = 8,
    VT_FONTSIZE = 10,
    VT_MAXWIDTH = 12,
    VT_LINEHEIGHT = 14,
    VT_FONTFILENAME = 16
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *text() const { return GetPointer<const flatbuffers::String *>(VT_TEXT); }
  HorizontalAlignment horizontalAlignment() const { return static_cast<HorizontalAlignment>(GetField<int8_t>(VT_HORIZONTALALIGNMENT, 0)); }
  float fontSize() const { return GetField<float>(VT_FONTSIZE, 0.0f); }
  float maxWidth() const { return GetField<float>(VT_MAXWIDTH, 0.0f); }
  float lineHeight() const { return GetField<float>(VT_LINEHEIGHT, 0.0f); }
  const flatbuffers::String *fontFilename() const { return GetPointer<const flatbuffers::String *>(VT_FONTFILENAME); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TEXT) &&
           verifier.Verify(text()) &&
           VerifyField<int8_t>(verifier, VT_HORIZONTALALIGNMENT) &&
           VerifyField<float>(verifier, VT_FONTSIZE) &&
           VerifyField<float>(verifier, VT_MAXWIDTH) &&
           VerifyField<float>(verifier, VT_LINEHEIGHT) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_FONTFILENAME) &&
           verifier.Verify(fontFilename()) &&
           verifier.EndTable();
  }
};

struct RichTextBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(RichText::VT_NODE, node); }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) { fbb_.AddOffset(RichText::VT_TEXT, text); }
  void add_horizontalAlignment(HorizontalAlignment horizontalAlignment) { fbb_.AddElement<int8_t>(RichText::VT_HORIZONTALALIGNMENT, static_cast<int8_t>(horizontalAlignment), 0); }
  void add_fontSize(float fontSize) { fbb_.AddElement<float>(RichText::VT_FONTSIZE, fontSize, 0.0f); }
  void add_maxWidth(float maxWidth) { fbb_.AddElement<float>(RichText::VT_MAXWIDTH, maxWidth, 0.0f); }
  void add_lineHeight(float lineHeight) { fbb_.AddElement<float>(RichText::VT_LINEHEIGHT, lineHeight, 0.0f); }
  void add_fontFilename(flatbuffers::Offset<flatbuffers::String> fontFilename) { fbb_.AddOffset(RichText::VT_FONTFILENAME, fontFilename); }
  RichTextBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  RichTextBuilder &operator=(const RichTextBuilder &);
  flatbuffers::Offset<RichText> Finish() {
    auto o = flatbuffers::Offset<RichText>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<RichText> CreateRichText(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> text = 0,
    HorizontalAlignment horizontalAlignment = HorizontalAlignment_Left,
    float fontSize = 0.0f,
    float maxWidth = 0.0f,
    float lineHeight = 0.0f,
    flatbuffers::Offset<flatbuffers::String> fontFilename = 0) {
  RichTextBuilder builder_(_fbb);
  builder_.add_fontFilename(fontFilename);
  builder_.add_lineHeight(lineHeight);
  builder_.add_maxWidth(maxWidth);
  builder_.add_fontSize(fontSize);
  builder_.add_text(text);
  builder_.add_node(node);
  builder_.add_horizontalAlignment(horizontalAlignment);
  return builder_.Finish();
}

inline flatbuffers::Offset<RichText> CreateRichTextDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *text = nullptr,
    HorizontalAlignment horizontalAlignment = HorizontalAlignment_Left,
    float fontSize = 0.0f,
    float maxWidth = 0.0f,
    float lineHeight = 0.0f,
    const char *fontFilename = nullptr) {
  return CreateRichText(_fbb, node, text ? _fbb.CreateString(text) : 0, horizontalAlignment, fontSize, maxWidth, lineHeight, fontFilename ? _fbb.CreateString(fontFilename) : 0);
}

struct Particle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_PARTICLEFILENAME = 6,
    VT_TEXTUREPATH = 8
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *particleFilename() const { return GetPointer<const flatbuffers::String *>(VT_PARTICLEFILENAME); }
  const flatbuffers::String *texturePath() const { return GetPointer<const flatbuffers::String *>(VT_TEXTUREPATH); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PARTICLEFILENAME) &&
           verifier.Verify(particleFilename()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TEXTUREPATH) &&
           verifier.Verify(texturePath()) &&
           verifier.EndTable();
  }
};

struct ParticleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(Particle::VT_NODE, node); }
  void add_particleFilename(flatbuffers::Offset<flatbuffers::String> particleFilename) { fbb_.AddOffset(Particle::VT_PARTICLEFILENAME, particleFilename); }
  void add_texturePath(flatbuffers::Offset<flatbuffers::String> texturePath) { fbb_.AddOffset(Particle::VT_TEXTUREPATH, texturePath); }
  ParticleBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ParticleBuilder &operator=(const ParticleBuilder &);
  flatbuffers::Offset<Particle> Finish() {
    auto o = flatbuffers::Offset<Particle>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<Particle> CreateParticle(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> particleFilename = 0,
    flatbuffers::Offset<flatbuffers::String> texturePath = 0) {
  ParticleBuilder builder_(_fbb);
  builder_.add_texturePath(texturePath);
  builder_.add_particleFilename(particleFilename);
  builder_.add_node(node);
  return builder_.Finish();
}

inline flatbuffers::Offset<Particle> CreateParticleDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *particleFilename = nullptr,
    const char *texturePath = nullptr) {
  return CreateParticle(_fbb, node, particleFilename ? _fbb.CreateString(particleFilename) : 0, texturePath ? _fbb.CreateString(texturePath) : 0);
}

struct TileMap FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_TMXFILENAME = 6,
    VT_DESIREDCONTENTSIZE = 8
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *tmxFilename() const { return GetPointer<const flatbuffers::String *>(VT_TMXFILENAME); }
  const Size *desiredContentSize() const { return GetStruct<const Size *>(VT_DESIREDCONTENTSIZE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TMXFILENAME) &&
           verifier.Verify(tmxFilename()) &&
           VerifyField<Size>(verifier, VT_DESIREDCONTENTSIZE) &&
           verifier.EndTable();
  }
};

struct TileMapBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(TileMap::VT_NODE, node); }
  void add_tmxFilename(flatbuffers::Offset<flatbuffers::String> tmxFilename) { fbb_.AddOffset(TileMap::VT_TMXFILENAME, tmxFilename); }
  void add_desiredContentSize(const Size *desiredContentSize) { fbb_.AddStruct(TileMap::VT_DESIREDCONTENTSIZE, desiredContentSize); }
  TileMapBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  TileMapBuilder &operator=(const TileMapBuilder &);
  flatbuffers::Offset<TileMap> Finish() {
    auto o = flatbuffers::Offset<TileMap>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<TileMap> CreateTileMap(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> tmxFilename = 0,
    const Size *desiredContentSize = 0) {
  TileMapBuilder builder_(_fbb);
  builder_.add_desiredContentSize(desiredContentSize);
  builder_.add_tmxFilename(tmxFilename);
  builder_.add_node(node);
  return builder_.Finish();
}

inline flatbuffers::Offset<TileMap> CreateTileMapDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *tmxFilename = nullptr,
    const Size *desiredContentSize = 0) {
  return CreateTileMap(_fbb, node, tmxFilename ? _fbb.CreateString(tmxFilename) : 0, desiredContentSize);
}

struct Scene FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           verifier.EndTable();
  }
};

struct SceneBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(Scene::VT_NODE, node); }
  SceneBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SceneBuilder &operator=(const SceneBuilder &);
  flatbuffers::Offset<Scene> Finish() {
    auto o = flatbuffers::Offset<Scene>(fbb_.EndTable(start_, 1));
    return o;
  }
};

inline flatbuffers::Offset<Scene> CreateScene(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0) {
  SceneBuilder builder_(_fbb);
  builder_.add_node(node);
  return builder_.Finish();
}

struct Button FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_TRANSITION = 6,
    VT_ZOOMSCALE = 8,
    VT_SPRITEFRAMENAME = 10,
    VT_PRESSEDSPRITEFRAMENAME = 12,
    VT_DISABLEDSPRITEFRAMENAME = 14,
    VT_IGNORECONTENTADAPTWITHSIZE = 16
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  int32_t transition() const { return GetField<int32_t>(VT_TRANSITION, 0); }
  float zoomScale() const { return GetField<float>(VT_ZOOMSCALE, 0.0f); }
  const flatbuffers::String *spriteFrameName() const { return GetPointer<const flatbuffers::String *>(VT_SPRITEFRAMENAME); }
  const flatbuffers::String *pressedSpriteFrameName() const { return GetPointer<const flatbuffers::String *>(VT_PRESSEDSPRITEFRAMENAME); }
  const flatbuffers::String *disabledSpriteFrameName() const { return GetPointer<const flatbuffers::String *>(VT_DISABLEDSPRITEFRAMENAME); }
  bool ignoreContentAdaptWithSize() const { return GetField<uint8_t>(VT_IGNORECONTENTADAPTWITHSIZE, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<int32_t>(verifier, VT_TRANSITION) &&
           VerifyField<float>(verifier, VT_ZOOMSCALE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SPRITEFRAMENAME) &&
           verifier.Verify(spriteFrameName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PRESSEDSPRITEFRAMENAME) &&
           verifier.Verify(pressedSpriteFrameName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DISABLEDSPRITEFRAMENAME) &&
           verifier.Verify(disabledSpriteFrameName()) &&
           VerifyField<uint8_t>(verifier, VT_IGNORECONTENTADAPTWITHSIZE) &&
           verifier.EndTable();
  }
};

struct ButtonBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(Button::VT_NODE, node); }
  void add_transition(int32_t transition) { fbb_.AddElement<int32_t>(Button::VT_TRANSITION, transition, 0); }
  void add_zoomScale(float zoomScale) { fbb_.AddElement<float>(Button::VT_ZOOMSCALE, zoomScale, 0.0f); }
  void add_spriteFrameName(flatbuffers::Offset<flatbuffers::String> spriteFrameName) { fbb_.AddOffset(Button::VT_SPRITEFRAMENAME, spriteFrameName); }
  void add_pressedSpriteFrameName(flatbuffers::Offset<flatbuffers::String> pressedSpriteFrameName) { fbb_.AddOffset(Button::VT_PRESSEDSPRITEFRAMENAME, pressedSpriteFrameName); }
  void add_disabledSpriteFrameName(flatbuffers::Offset<flatbuffers::String> disabledSpriteFrameName) { fbb_.AddOffset(Button::VT_DISABLEDSPRITEFRAMENAME, disabledSpriteFrameName); }
  void add_ignoreContentAdaptWithSize(bool ignoreContentAdaptWithSize) { fbb_.AddElement<uint8_t>(Button::VT_IGNORECONTENTADAPTWITHSIZE, static_cast<uint8_t>(ignoreContentAdaptWithSize), 0); }
  ButtonBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ButtonBuilder &operator=(const ButtonBuilder &);
  flatbuffers::Offset<Button> Finish() {
    auto o = flatbuffers::Offset<Button>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<Button> CreateButton(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    int32_t transition = 0,
    float zoomScale = 0.0f,
    flatbuffers::Offset<flatbuffers::String> spriteFrameName = 0,
    flatbuffers::Offset<flatbuffers::String> pressedSpriteFrameName = 0,
    flatbuffers::Offset<flatbuffers::String> disabledSpriteFrameName = 0,
    bool ignoreContentAdaptWithSize = false) {
  ButtonBuilder builder_(_fbb);
  builder_.add_disabledSpriteFrameName(disabledSpriteFrameName);
  builder_.add_pressedSpriteFrameName(pressedSpriteFrameName);
  builder_.add_spriteFrameName(spriteFrameName);
  builder_.add_zoomScale(zoomScale);
  builder_.add_transition(transition);
  builder_.add_node(node);
  builder_.add_ignoreContentAdaptWithSize(ignoreContentAdaptWithSize);
  return builder_.Finish();
}

inline flatbuffers::Offset<Button> CreateButtonDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    int32_t transition = 0,
    float zoomScale = 0.0f,
    const char *spriteFrameName = nullptr,
    const char *pressedSpriteFrameName = nullptr,
    const char *disabledSpriteFrameName = nullptr,
    bool ignoreContentAdaptWithSize = false) {
  return CreateButton(_fbb, node, transition, zoomScale, spriteFrameName ? _fbb.CreateString(spriteFrameName) : 0, pressedSpriteFrameName ? _fbb.CreateString(pressedSpriteFrameName) : 0, disabledSpriteFrameName ? _fbb.CreateString(disabledSpriteFrameName) : 0, ignoreContentAdaptWithSize);
}

struct ProgressBar FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_PERCENT = 6,
    VT_BACKGROUNDSPRITEFRAMENAME = 8,
    VT_BARSPRITEFRAMENAME = 10,
    VT_BARSPRITETYPE = 12,
    VT_REVERSE = 14
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  float percent() const { return GetField<float>(VT_PERCENT, 0.0f); }
  const flatbuffers::String *backgroundSpriteFrameName() const { return GetPointer<const flatbuffers::String *>(VT_BACKGROUNDSPRITEFRAMENAME); }
  const flatbuffers::String *barSpriteFrameName() const { return GetPointer<const flatbuffers::String *>(VT_BARSPRITEFRAMENAME); }
  int32_t barSpriteType() const { return GetField<int32_t>(VT_BARSPRITETYPE, 0); }
  bool reverse() const { return GetField<uint8_t>(VT_REVERSE, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<float>(verifier, VT_PERCENT) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BACKGROUNDSPRITEFRAMENAME) &&
           verifier.Verify(backgroundSpriteFrameName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BARSPRITEFRAMENAME) &&
           verifier.Verify(barSpriteFrameName()) &&
           VerifyField<int32_t>(verifier, VT_BARSPRITETYPE) &&
           VerifyField<uint8_t>(verifier, VT_REVERSE) &&
           verifier.EndTable();
  }
};

struct ProgressBarBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(ProgressBar::VT_NODE, node); }
  void add_percent(float percent) { fbb_.AddElement<float>(ProgressBar::VT_PERCENT, percent, 0.0f); }
  void add_backgroundSpriteFrameName(flatbuffers::Offset<flatbuffers::String> backgroundSpriteFrameName) { fbb_.AddOffset(ProgressBar::VT_BACKGROUNDSPRITEFRAMENAME, backgroundSpriteFrameName); }
  void add_barSpriteFrameName(flatbuffers::Offset<flatbuffers::String> barSpriteFrameName) { fbb_.AddOffset(ProgressBar::VT_BARSPRITEFRAMENAME, barSpriteFrameName); }
  void add_barSpriteType(int32_t barSpriteType) { fbb_.AddElement<int32_t>(ProgressBar::VT_BARSPRITETYPE, barSpriteType, 0); }
  void add_reverse(bool reverse) { fbb_.AddElement<uint8_t>(ProgressBar::VT_REVERSE, static_cast<uint8_t>(reverse), 0); }
  ProgressBarBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ProgressBarBuilder &operator=(const ProgressBarBuilder &);
  flatbuffers::Offset<ProgressBar> Finish() {
    auto o = flatbuffers::Offset<ProgressBar>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<ProgressBar> CreateProgressBar(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    float percent = 0.0f,
    flatbuffers::Offset<flatbuffers::String> backgroundSpriteFrameName = 0,
    flatbuffers::Offset<flatbuffers::String> barSpriteFrameName = 0,
    int32_t barSpriteType = 0,
    bool reverse = false) {
  ProgressBarBuilder builder_(_fbb);
  builder_.add_barSpriteType(barSpriteType);
  builder_.add_barSpriteFrameName(barSpriteFrameName);
  builder_.add_backgroundSpriteFrameName(backgroundSpriteFrameName);
  builder_.add_percent(percent);
  builder_.add_node(node);
  builder_.add_reverse(reverse);
  return builder_.Finish();
}

inline flatbuffers::Offset<ProgressBar> CreateProgressBarDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    float percent = 0.0f,
    const char *backgroundSpriteFrameName = nullptr,
    const char *barSpriteFrameName = nullptr,
    int32_t barSpriteType = 0,
    bool reverse = false) {
  return CreateProgressBar(_fbb, node, percent, backgroundSpriteFrameName ? _fbb.CreateString(backgroundSpriteFrameName) : 0, barSpriteFrameName ? _fbb.CreateString(barSpriteFrameName) : 0, barSpriteType, reverse);
}

struct ScrollView FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_BACKGROUNDIMAGE = 6,
    VT_BACKGROUNDIMAGESCALE9ENABLED = 8,
    VT_BACKGROUNDIMAGECOLOR = 10,
    VT_DIRECTION = 12,
    VT_BOUNCEENABLED = 14,
    VT_INNERCONTAINERSIZE = 16
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *backgroundImage() const { return GetPointer<const flatbuffers::String *>(VT_BACKGROUNDIMAGE); }
  bool backgroundImageScale9Enabled() const { return GetField<uint8_t>(VT_BACKGROUNDIMAGESCALE9ENABLED, 0) != 0; }
  const ColorRGB *backgroundImageColor() const { return GetStruct<const ColorRGB *>(VT_BACKGROUNDIMAGECOLOR); }
  ScrollViewDirection direction() const { return static_cast<ScrollViewDirection>(GetField<int8_t>(VT_DIRECTION, 0)); }
  bool bounceEnabled() const { return GetField<uint8_t>(VT_BOUNCEENABLED, 0) != 0; }
  const Size *innerContainerSize() const { return GetStruct<const Size *>(VT_INNERCONTAINERSIZE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BACKGROUNDIMAGE) &&
           verifier.Verify(backgroundImage()) &&
           VerifyField<uint8_t>(verifier, VT_BACKGROUNDIMAGESCALE9ENABLED) &&
           VerifyField<ColorRGB>(verifier, VT_BACKGROUNDIMAGECOLOR) &&
           VerifyField<int8_t>(verifier, VT_DIRECTION) &&
           VerifyField<uint8_t>(verifier, VT_BOUNCEENABLED) &&
           VerifyField<Size>(verifier, VT_INNERCONTAINERSIZE) &&
           verifier.EndTable();
  }
};

struct ScrollViewBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(ScrollView::VT_NODE, node); }
  void add_backgroundImage(flatbuffers::Offset<flatbuffers::String> backgroundImage) { fbb_.AddOffset(ScrollView::VT_BACKGROUNDIMAGE, backgroundImage); }
  void add_backgroundImageScale9Enabled(bool backgroundImageScale9Enabled) { fbb_.AddElement<uint8_t>(ScrollView::VT_BACKGROUNDIMAGESCALE9ENABLED, static_cast<uint8_t>(backgroundImageScale9Enabled), 0); }
  void add_backgroundImageColor(const ColorRGB *backgroundImageColor) { fbb_.AddStruct(ScrollView::VT_BACKGROUNDIMAGECOLOR, backgroundImageColor); }
  void add_direction(ScrollViewDirection direction) { fbb_.AddElement<int8_t>(ScrollView::VT_DIRECTION, static_cast<int8_t>(direction), 0); }
  void add_bounceEnabled(bool bounceEnabled) { fbb_.AddElement<uint8_t>(ScrollView::VT_BOUNCEENABLED, static_cast<uint8_t>(bounceEnabled), 0); }
  void add_innerContainerSize(const Size *innerContainerSize) { fbb_.AddStruct(ScrollView::VT_INNERCONTAINERSIZE, innerContainerSize); }
  ScrollViewBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ScrollViewBuilder &operator=(const ScrollViewBuilder &);
  flatbuffers::Offset<ScrollView> Finish() {
    auto o = flatbuffers::Offset<ScrollView>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<ScrollView> CreateScrollView(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> backgroundImage = 0,
    bool backgroundImageScale9Enabled = false,
    const ColorRGB *backgroundImageColor = 0,
    ScrollViewDirection direction = ScrollViewDirection_None,
    bool bounceEnabled = false,
    const Size *innerContainerSize = 0) {
  ScrollViewBuilder builder_(_fbb);
  builder_.add_innerContainerSize(innerContainerSize);
  builder_.add_backgroundImageColor(backgroundImageColor);
  builder_.add_backgroundImage(backgroundImage);
  builder_.add_node(node);
  builder_.add_bounceEnabled(bounceEnabled);
  builder_.add_direction(direction);
  builder_.add_backgroundImageScale9Enabled(backgroundImageScale9Enabled);
  return builder_.Finish();
}

inline flatbuffers::Offset<ScrollView> CreateScrollViewDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *backgroundImage = nullptr,
    bool backgroundImageScale9Enabled = false,
    const ColorRGB *backgroundImageColor = 0,
    ScrollViewDirection direction = ScrollViewDirection_None,
    bool bounceEnabled = false,
    const Size *innerContainerSize = 0) {
  return CreateScrollView(_fbb, node, backgroundImage ? _fbb.CreateString(backgroundImage) : 0, backgroundImageScale9Enabled, backgroundImageColor, direction, bounceEnabled, innerContainerSize);
}

struct EditBox FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_BACKGROUNDIMAGE = 6,
    VT_RETURNTYPE = 8,
    VT_INPUTFLAG = 10,
    VT_INPUTMODE = 12,
    VT_FONTSIZE = 14,
    VT_FONTCOLOR = 16,
    VT_PLACEHOLDER = 18,
    VT_PLACEHOLDERFONTSIZE = 20,
    VT_PLACEHOLDERFONTCOLOR = 22,
    VT_MAXLENGTH = 24,
    VT_TEXT = 26
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *backgroundImage() const { return GetPointer<const flatbuffers::String *>(VT_BACKGROUNDIMAGE); }
  EditBoxReturnType returnType() const { return static_cast<EditBoxReturnType>(GetField<int8_t>(VT_RETURNTYPE, 0)); }
  EditBoxInputFlag inputFlag() const { return static_cast<EditBoxInputFlag>(GetField<int8_t>(VT_INPUTFLAG, 0)); }
  EditBoxInputMode inputMode() const { return static_cast<EditBoxInputMode>(GetField<int8_t>(VT_INPUTMODE, 0)); }
  int32_t fontSize() const { return GetField<int32_t>(VT_FONTSIZE, 0); }
  const ColorRGB *fontColor() const { return GetStruct<const ColorRGB *>(VT_FONTCOLOR); }
  const flatbuffers::String *placeholder() const { return GetPointer<const flatbuffers::String *>(VT_PLACEHOLDER); }
  int32_t placeholderFontSize() const { return GetField<int32_t>(VT_PLACEHOLDERFONTSIZE, 0); }
  const ColorRGB *placeholderFontColor() const { return GetStruct<const ColorRGB *>(VT_PLACEHOLDERFONTCOLOR); }
  int32_t maxLength() const { return GetField<int32_t>(VT_MAXLENGTH, 0); }
  const flatbuffers::String *text() const { return GetPointer<const flatbuffers::String *>(VT_TEXT); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BACKGROUNDIMAGE) &&
           verifier.Verify(backgroundImage()) &&
           VerifyField<int8_t>(verifier, VT_RETURNTYPE) &&
           VerifyField<int8_t>(verifier, VT_INPUTFLAG) &&
           VerifyField<int8_t>(verifier, VT_INPUTMODE) &&
           VerifyField<int32_t>(verifier, VT_FONTSIZE) &&
           VerifyField<ColorRGB>(verifier, VT_FONTCOLOR) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PLACEHOLDER) &&
           verifier.Verify(placeholder()) &&
           VerifyField<int32_t>(verifier, VT_PLACEHOLDERFONTSIZE) &&
           VerifyField<ColorRGB>(verifier, VT_PLACEHOLDERFONTCOLOR) &&
           VerifyField<int32_t>(verifier, VT_MAXLENGTH) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TEXT) &&
           verifier.Verify(text()) &&
           verifier.EndTable();
  }
};

struct EditBoxBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(EditBox::VT_NODE, node); }
  void add_backgroundImage(flatbuffers::Offset<flatbuffers::String> backgroundImage) { fbb_.AddOffset(EditBox::VT_BACKGROUNDIMAGE, backgroundImage); }
  void add_returnType(EditBoxReturnType returnType) { fbb_.AddElement<int8_t>(EditBox::VT_RETURNTYPE, static_cast<int8_t>(returnType), 0); }
  void add_inputFlag(EditBoxInputFlag inputFlag) { fbb_.AddElement<int8_t>(EditBox::VT_INPUTFLAG, static_cast<int8_t>(inputFlag), 0); }
  void add_inputMode(EditBoxInputMode inputMode) { fbb_.AddElement<int8_t>(EditBox::VT_INPUTMODE, static_cast<int8_t>(inputMode), 0); }
  void add_fontSize(int32_t fontSize) { fbb_.AddElement<int32_t>(EditBox::VT_FONTSIZE, fontSize, 0); }
  void add_fontColor(const ColorRGB *fontColor) { fbb_.AddStruct(EditBox::VT_FONTCOLOR, fontColor); }
  void add_placeholder(flatbuffers::Offset<flatbuffers::String> placeholder) { fbb_.AddOffset(EditBox::VT_PLACEHOLDER, placeholder); }
  void add_placeholderFontSize(int32_t placeholderFontSize) { fbb_.AddElement<int32_t>(EditBox::VT_PLACEHOLDERFONTSIZE, placeholderFontSize, 0); }
  void add_placeholderFontColor(const ColorRGB *placeholderFontColor) { fbb_.AddStruct(EditBox::VT_PLACEHOLDERFONTCOLOR, placeholderFontColor); }
  void add_maxLength(int32_t maxLength) { fbb_.AddElement<int32_t>(EditBox::VT_MAXLENGTH, maxLength, 0); }
  void add_text(flatbuffers::Offset<flatbuffers::String> text) { fbb_.AddOffset(EditBox::VT_TEXT, text); }
  EditBoxBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  EditBoxBuilder &operator=(const EditBoxBuilder &);
  flatbuffers::Offset<EditBox> Finish() {
    auto o = flatbuffers::Offset<EditBox>(fbb_.EndTable(start_, 12));
    return o;
  }
};

inline flatbuffers::Offset<EditBox> CreateEditBox(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> backgroundImage = 0,
    EditBoxReturnType returnType = EditBoxReturnType_Default,
    EditBoxInputFlag inputFlag = EditBoxInputFlag_Password,
    EditBoxInputMode inputMode = EditBoxInputMode_Any,
    int32_t fontSize = 0,
    const ColorRGB *fontColor = 0,
    flatbuffers::Offset<flatbuffers::String> placeholder = 0,
    int32_t placeholderFontSize = 0,
    const ColorRGB *placeholderFontColor = 0,
    int32_t maxLength = 0,
    flatbuffers::Offset<flatbuffers::String> text = 0) {
  EditBoxBuilder builder_(_fbb);
  builder_.add_text(text);
  builder_.add_maxLength(maxLength);
  builder_.add_placeholderFontColor(placeholderFontColor);
  builder_.add_placeholderFontSize(placeholderFontSize);
  builder_.add_placeholder(placeholder);
  builder_.add_fontColor(fontColor);
  builder_.add_fontSize(fontSize);
  builder_.add_backgroundImage(backgroundImage);
  builder_.add_node(node);
  builder_.add_inputMode(inputMode);
  builder_.add_inputFlag(inputFlag);
  builder_.add_returnType(returnType);
  return builder_.Finish();
}

inline flatbuffers::Offset<EditBox> CreateEditBoxDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *backgroundImage = nullptr,
    EditBoxReturnType returnType = EditBoxReturnType_Default,
    EditBoxInputFlag inputFlag = EditBoxInputFlag_Password,
    EditBoxInputMode inputMode = EditBoxInputMode_Any,
    int32_t fontSize = 0,
    const ColorRGB *fontColor = 0,
    const char *placeholder = nullptr,
    int32_t placeholderFontSize = 0,
    const ColorRGB *placeholderFontColor = 0,
    int32_t maxLength = 0,
    const char *text = nullptr) {
  return CreateEditBox(_fbb, node, backgroundImage ? _fbb.CreateString(backgroundImage) : 0, returnType, inputFlag, inputMode, fontSize, fontColor, placeholder ? _fbb.CreateString(placeholder) : 0, placeholderFontSize, placeholderFontColor, maxLength, text ? _fbb.CreateString(text) : 0);
}

struct VideoPlayer FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_ISLOCAL = 6,
    VT_URL = 8,
    VT_FULLSCREEN = 10,
    VT_KEEPASPECT = 12
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  bool isLocal() const { return GetField<uint8_t>(VT_ISLOCAL, 0) != 0; }
  const flatbuffers::String *url() const { return GetPointer<const flatbuffers::String *>(VT_URL); }
  bool fullScreen() const { return GetField<uint8_t>(VT_FULLSCREEN, 0) != 0; }
  bool keepAspect() const { return GetField<uint8_t>(VT_KEEPASPECT, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<uint8_t>(verifier, VT_ISLOCAL) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_URL) &&
           verifier.Verify(url()) &&
           VerifyField<uint8_t>(verifier, VT_FULLSCREEN) &&
           VerifyField<uint8_t>(verifier, VT_KEEPASPECT) &&
           verifier.EndTable();
  }
};

struct VideoPlayerBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(VideoPlayer::VT_NODE, node); }
  void add_isLocal(bool isLocal) { fbb_.AddElement<uint8_t>(VideoPlayer::VT_ISLOCAL, static_cast<uint8_t>(isLocal), 0); }
  void add_url(flatbuffers::Offset<flatbuffers::String> url) { fbb_.AddOffset(VideoPlayer::VT_URL, url); }
  void add_fullScreen(bool fullScreen) { fbb_.AddElement<uint8_t>(VideoPlayer::VT_FULLSCREEN, static_cast<uint8_t>(fullScreen), 0); }
  void add_keepAspect(bool keepAspect) { fbb_.AddElement<uint8_t>(VideoPlayer::VT_KEEPASPECT, static_cast<uint8_t>(keepAspect), 0); }
  VideoPlayerBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  VideoPlayerBuilder &operator=(const VideoPlayerBuilder &);
  flatbuffers::Offset<VideoPlayer> Finish() {
    auto o = flatbuffers::Offset<VideoPlayer>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<VideoPlayer> CreateVideoPlayer(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    bool isLocal = false,
    flatbuffers::Offset<flatbuffers::String> url = 0,
    bool fullScreen = false,
    bool keepAspect = false) {
  VideoPlayerBuilder builder_(_fbb);
  builder_.add_url(url);
  builder_.add_node(node);
  builder_.add_keepAspect(keepAspect);
  builder_.add_fullScreen(fullScreen);
  builder_.add_isLocal(isLocal);
  return builder_.Finish();
}

inline flatbuffers::Offset<VideoPlayer> CreateVideoPlayerDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    bool isLocal = false,
    const char *url = nullptr,
    bool fullScreen = false,
    bool keepAspect = false) {
  return CreateVideoPlayer(_fbb, node, isLocal, url ? _fbb.CreateString(url) : 0, fullScreen, keepAspect);
}

struct WebView FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_URL = 6
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *url() const { return GetPointer<const flatbuffers::String *>(VT_URL); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_URL) &&
           verifier.Verify(url()) &&
           verifier.EndTable();
  }
};

struct WebViewBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(WebView::VT_NODE, node); }
  void add_url(flatbuffers::Offset<flatbuffers::String> url) { fbb_.AddOffset(WebView::VT_URL, url); }
  WebViewBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  WebViewBuilder &operator=(const WebViewBuilder &);
  flatbuffers::Offset<WebView> Finish() {
    auto o = flatbuffers::Offset<WebView>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<WebView> CreateWebView(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> url = 0) {
  WebViewBuilder builder_(_fbb);
  builder_.add_url(url);
  builder_.add_node(node);
  return builder_.Finish();
}

inline flatbuffers::Offset<WebView> CreateWebViewDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *url = nullptr) {
  return CreateWebView(_fbb, node, url ? _fbb.CreateString(url) : 0);
}

struct Slider FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_PERCENT = 6,
    VT_BARTEXTUREPATH = 8,
    VT_BARSIZE = 10,
    VT_NORMALTEXTUREPATH = 12,
    VT_PRESSEDTEXTUREPATH = 14,
    VT_DISABLEDTEXTUREPATH = 16,
    VT_BALLSIZE = 18
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  int32_t percent() const { return GetField<int32_t>(VT_PERCENT, 0); }
  const flatbuffers::String *barTexturePath() const { return GetPointer<const flatbuffers::String *>(VT_BARTEXTUREPATH); }
  const Size *barSize() const { return GetStruct<const Size *>(VT_BARSIZE); }
  const flatbuffers::String *normalTexturePath() const { return GetPointer<const flatbuffers::String *>(VT_NORMALTEXTUREPATH); }
  const flatbuffers::String *pressedTexturePath() const { return GetPointer<const flatbuffers::String *>(VT_PRESSEDTEXTUREPATH); }
  const flatbuffers::String *disabledTexturePath() const { return GetPointer<const flatbuffers::String *>(VT_DISABLEDTEXTUREPATH); }
  const Size *ballSize() const { return GetStruct<const Size *>(VT_BALLSIZE); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<int32_t>(verifier, VT_PERCENT) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BARTEXTUREPATH) &&
           verifier.Verify(barTexturePath()) &&
           VerifyField<Size>(verifier, VT_BARSIZE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NORMALTEXTUREPATH) &&
           verifier.Verify(normalTexturePath()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PRESSEDTEXTUREPATH) &&
           verifier.Verify(pressedTexturePath()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DISABLEDTEXTUREPATH) &&
           verifier.Verify(disabledTexturePath()) &&
           VerifyField<Size>(verifier, VT_BALLSIZE) &&
           verifier.EndTable();
  }
};

struct SliderBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(Slider::VT_NODE, node); }
  void add_percent(int32_t percent) { fbb_.AddElement<int32_t>(Slider::VT_PERCENT, percent, 0); }
  void add_barTexturePath(flatbuffers::Offset<flatbuffers::String> barTexturePath) { fbb_.AddOffset(Slider::VT_BARTEXTUREPATH, barTexturePath); }
  void add_barSize(const Size *barSize) { fbb_.AddStruct(Slider::VT_BARSIZE, barSize); }
  void add_normalTexturePath(flatbuffers::Offset<flatbuffers::String> normalTexturePath) { fbb_.AddOffset(Slider::VT_NORMALTEXTUREPATH, normalTexturePath); }
  void add_pressedTexturePath(flatbuffers::Offset<flatbuffers::String> pressedTexturePath) { fbb_.AddOffset(Slider::VT_PRESSEDTEXTUREPATH, pressedTexturePath); }
  void add_disabledTexturePath(flatbuffers::Offset<flatbuffers::String> disabledTexturePath) { fbb_.AddOffset(Slider::VT_DISABLEDTEXTUREPATH, disabledTexturePath); }
  void add_ballSize(const Size *ballSize) { fbb_.AddStruct(Slider::VT_BALLSIZE, ballSize); }
  SliderBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SliderBuilder &operator=(const SliderBuilder &);
  flatbuffers::Offset<Slider> Finish() {
    auto o = flatbuffers::Offset<Slider>(fbb_.EndTable(start_, 8));
    return o;
  }
};

inline flatbuffers::Offset<Slider> CreateSlider(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    int32_t percent = 0,
    flatbuffers::Offset<flatbuffers::String> barTexturePath = 0,
    const Size *barSize = 0,
    flatbuffers::Offset<flatbuffers::String> normalTexturePath = 0,
    flatbuffers::Offset<flatbuffers::String> pressedTexturePath = 0,
    flatbuffers::Offset<flatbuffers::String> disabledTexturePath = 0,
    const Size *ballSize = 0) {
  SliderBuilder builder_(_fbb);
  builder_.add_ballSize(ballSize);
  builder_.add_disabledTexturePath(disabledTexturePath);
  builder_.add_pressedTexturePath(pressedTexturePath);
  builder_.add_normalTexturePath(normalTexturePath);
  builder_.add_barSize(barSize);
  builder_.add_barTexturePath(barTexturePath);
  builder_.add_percent(percent);
  builder_.add_node(node);
  return builder_.Finish();
}

inline flatbuffers::Offset<Slider> CreateSliderDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    int32_t percent = 0,
    const char *barTexturePath = nullptr,
    const Size *barSize = 0,
    const char *normalTexturePath = nullptr,
    const char *pressedTexturePath = nullptr,
    const char *disabledTexturePath = nullptr,
    const Size *ballSize = 0) {
  return CreateSlider(_fbb, node, percent, barTexturePath ? _fbb.CreateString(barTexturePath) : 0, barSize, normalTexturePath ? _fbb.CreateString(normalTexturePath) : 0, pressedTexturePath ? _fbb.CreateString(pressedTexturePath) : 0, disabledTexturePath ? _fbb.CreateString(disabledTexturePath) : 0, ballSize);
}

struct Toggle FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_INTERACTABLE = 6,
    VT_ENABLEAUTOGRAYEFFECT = 8,
    VT_ISCHECKED = 10,
    VT_BACKGROUNDSPRITEPATH = 12,
    VT_CHECKMARKSPRITEPATH = 14,
    VT_ZOOMSCALE = 16
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  bool interactable() const { return GetField<uint8_t>(VT_INTERACTABLE, 0) != 0; }
  bool enableAutoGrayEffect() const { return GetField<uint8_t>(VT_ENABLEAUTOGRAYEFFECT, 0) != 0; }
  bool isChecked() const { return GetField<uint8_t>(VT_ISCHECKED, 0) != 0; }
  const flatbuffers::String *backgroundSpritePath() const { return GetPointer<const flatbuffers::String *>(VT_BACKGROUNDSPRITEPATH); }
  const flatbuffers::String *checkMarkSpritePath() const { return GetPointer<const flatbuffers::String *>(VT_CHECKMARKSPRITEPATH); }
  float zoomScale() const { return GetField<float>(VT_ZOOMSCALE, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<uint8_t>(verifier, VT_INTERACTABLE) &&
           VerifyField<uint8_t>(verifier, VT_ENABLEAUTOGRAYEFFECT) &&
           VerifyField<uint8_t>(verifier, VT_ISCHECKED) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BACKGROUNDSPRITEPATH) &&
           verifier.Verify(backgroundSpritePath()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CHECKMARKSPRITEPATH) &&
           verifier.Verify(checkMarkSpritePath()) &&
           VerifyField<float>(verifier, VT_ZOOMSCALE) &&
           verifier.EndTable();
  }
};

struct ToggleBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(Toggle::VT_NODE, node); }
  void add_interactable(bool interactable) { fbb_.AddElement<uint8_t>(Toggle::VT_INTERACTABLE, static_cast<uint8_t>(interactable), 0); }
  void add_enableAutoGrayEffect(bool enableAutoGrayEffect) { fbb_.AddElement<uint8_t>(Toggle::VT_ENABLEAUTOGRAYEFFECT, static_cast<uint8_t>(enableAutoGrayEffect), 0); }
  void add_isChecked(bool isChecked) { fbb_.AddElement<uint8_t>(Toggle::VT_ISCHECKED, static_cast<uint8_t>(isChecked), 0); }
  void add_backgroundSpritePath(flatbuffers::Offset<flatbuffers::String> backgroundSpritePath) { fbb_.AddOffset(Toggle::VT_BACKGROUNDSPRITEPATH, backgroundSpritePath); }
  void add_checkMarkSpritePath(flatbuffers::Offset<flatbuffers::String> checkMarkSpritePath) { fbb_.AddOffset(Toggle::VT_CHECKMARKSPRITEPATH, checkMarkSpritePath); }
  void add_zoomScale(float zoomScale) { fbb_.AddElement<float>(Toggle::VT_ZOOMSCALE, zoomScale, 0.0f); }
  ToggleBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ToggleBuilder &operator=(const ToggleBuilder &);
  flatbuffers::Offset<Toggle> Finish() {
    auto o = flatbuffers::Offset<Toggle>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<Toggle> CreateToggle(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    bool interactable = false,
    bool enableAutoGrayEffect = false,
    bool isChecked = false,
    flatbuffers::Offset<flatbuffers::String> backgroundSpritePath = 0,
    flatbuffers::Offset<flatbuffers::String> checkMarkSpritePath = 0,
    float zoomScale = 0.0f) {
  ToggleBuilder builder_(_fbb);
  builder_.add_zoomScale(zoomScale);
  builder_.add_checkMarkSpritePath(checkMarkSpritePath);
  builder_.add_backgroundSpritePath(backgroundSpritePath);
  builder_.add_node(node);
  builder_.add_isChecked(isChecked);
  builder_.add_enableAutoGrayEffect(enableAutoGrayEffect);
  builder_.add_interactable(interactable);
  return builder_.Finish();
}

inline flatbuffers::Offset<Toggle> CreateToggleDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    bool interactable = false,
    bool enableAutoGrayEffect = false,
    bool isChecked = false,
    const char *backgroundSpritePath = nullptr,
    const char *checkMarkSpritePath = nullptr,
    float zoomScale = 0.0f) {
  return CreateToggle(_fbb, node, interactable, enableAutoGrayEffect, isChecked, backgroundSpritePath ? _fbb.CreateString(backgroundSpritePath) : 0, checkMarkSpritePath ? _fbb.CreateString(checkMarkSpritePath) : 0, zoomScale);
}

struct ToggleGroup FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_ALLOWSWITCHOFF = 6,
    VT_TOGGLES = 8
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  bool allowSwitchOff() const { return GetField<uint8_t>(VT_ALLOWSWITCHOFF, 0) != 0; }
  const flatbuffers::Vector<flatbuffers::Offset<Toggle>> *toggles() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<Toggle>> *>(VT_TOGGLES); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<uint8_t>(verifier, VT_ALLOWSWITCHOFF) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TOGGLES) &&
           verifier.Verify(toggles()) &&
           verifier.VerifyVectorOfTables(toggles()) &&
           verifier.EndTable();
  }
};

struct ToggleGroupBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(ToggleGroup::VT_NODE, node); }
  void add_allowSwitchOff(bool allowSwitchOff) { fbb_.AddElement<uint8_t>(ToggleGroup::VT_ALLOWSWITCHOFF, static_cast<uint8_t>(allowSwitchOff), 0); }
  void add_toggles(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Toggle>>> toggles) { fbb_.AddOffset(ToggleGroup::VT_TOGGLES, toggles); }
  ToggleGroupBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ToggleGroupBuilder &operator=(const ToggleGroupBuilder &);
  flatbuffers::Offset<ToggleGroup> Finish() {
    auto o = flatbuffers::Offset<ToggleGroup>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<ToggleGroup> CreateToggleGroup(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    bool allowSwitchOff = false,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<Toggle>>> toggles = 0) {
  ToggleGroupBuilder builder_(_fbb);
  builder_.add_toggles(toggles);
  builder_.add_node(node);
  builder_.add_allowSwitchOff(allowSwitchOff);
  return builder_.Finish();
}

inline flatbuffers::Offset<ToggleGroup> CreateToggleGroupDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    bool allowSwitchOff = false,
    const std::vector<flatbuffers::Offset<Toggle>> *toggles = nullptr) {
  return CreateToggleGroup(_fbb, node, allowSwitchOff, toggles ? _fbb.CreateVector<flatbuffers::Offset<Toggle>>(*toggles) : 0);
}

struct Mask FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_TYPE = 6,
    VT_INVERTED = 8,
    VT_SEGMENTS = 10,
    VT_ALPHATHRESHOLD = 12,
    VT_SPRITEFRAME = 14
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  MaskType type() const { return static_cast<MaskType>(GetField<int8_t>(VT_TYPE, 0)); }
  bool inverted() const { return GetField<uint8_t>(VT_INVERTED, 0) != 0; }
  int32_t segments() const { return GetField<int32_t>(VT_SEGMENTS, 0); }
  float alphaThreshold() const { return GetField<float>(VT_ALPHATHRESHOLD, 0.0f); }
  const flatbuffers::String *spriteFrame() const { return GetPointer<const flatbuffers::String *>(VT_SPRITEFRAME); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<uint8_t>(verifier, VT_INVERTED) &&
           VerifyField<int32_t>(verifier, VT_SEGMENTS) &&
           VerifyField<float>(verifier, VT_ALPHATHRESHOLD) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SPRITEFRAME) &&
           verifier.Verify(spriteFrame()) &&
           verifier.EndTable();
  }
};

struct MaskBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(Mask::VT_NODE, node); }
  void add_type(MaskType type) { fbb_.AddElement<int8_t>(Mask::VT_TYPE, static_cast<int8_t>(type), 0); }
  void add_inverted(bool inverted) { fbb_.AddElement<uint8_t>(Mask::VT_INVERTED, static_cast<uint8_t>(inverted), 0); }
  void add_segments(int32_t segments) { fbb_.AddElement<int32_t>(Mask::VT_SEGMENTS, segments, 0); }
  void add_alphaThreshold(float alphaThreshold) { fbb_.AddElement<float>(Mask::VT_ALPHATHRESHOLD, alphaThreshold, 0.0f); }
  void add_spriteFrame(flatbuffers::Offset<flatbuffers::String> spriteFrame) { fbb_.AddOffset(Mask::VT_SPRITEFRAME, spriteFrame); }
  MaskBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MaskBuilder &operator=(const MaskBuilder &);
  flatbuffers::Offset<Mask> Finish() {
    auto o = flatbuffers::Offset<Mask>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<Mask> CreateMask(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    MaskType type = MaskType_Rect,
    bool inverted = false,
    int32_t segments = 0,
    float alphaThreshold = 0.0f,
    flatbuffers::Offset<flatbuffers::String> spriteFrame = 0) {
  MaskBuilder builder_(_fbb);
  builder_.add_spriteFrame(spriteFrame);
  builder_.add_alphaThreshold(alphaThreshold);
  builder_.add_segments(segments);
  builder_.add_node(node);
  builder_.add_inverted(inverted);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Mask> CreateMaskDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    MaskType type = MaskType_Rect,
    bool inverted = false,
    int32_t segments = 0,
    float alphaThreshold = 0.0f,
    const char *spriteFrame = nullptr) {
  return CreateMask(_fbb, node, type, inverted, segments, alphaThreshold, spriteFrame ? _fbb.CreateString(spriteFrame) : 0);
}

struct PageViewIndicator FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_POSITIONANCHOR = 4,
    VT_SPRITEFRAME = 6,
    VT_SPRITEFRAMEFROMTP = 8,
    VT_SPACE = 10,
    VT_DIRECTION = 12
  };
  const Vec2 *positionAnchor() const { return GetStruct<const Vec2 *>(VT_POSITIONANCHOR); }
  const flatbuffers::String *spriteFrame() const { return GetPointer<const flatbuffers::String *>(VT_SPRITEFRAME); }
  bool spriteFrameFromTP() const { return GetField<uint8_t>(VT_SPRITEFRAMEFROMTP, 0) != 0; }
  float space() const { return GetField<float>(VT_SPACE, 0.0f); }
  int32_t direction() const { return GetField<int32_t>(VT_DIRECTION, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<Vec2>(verifier, VT_POSITIONANCHOR) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SPRITEFRAME) &&
           verifier.Verify(spriteFrame()) &&
           VerifyField<uint8_t>(verifier, VT_SPRITEFRAMEFROMTP) &&
           VerifyField<float>(verifier, VT_SPACE) &&
           VerifyField<int32_t>(verifier, VT_DIRECTION) &&
           verifier.EndTable();
  }
};

struct PageViewIndicatorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_positionAnchor(const Vec2 *positionAnchor) { fbb_.AddStruct(PageViewIndicator::VT_POSITIONANCHOR, positionAnchor); }
  void add_spriteFrame(flatbuffers::Offset<flatbuffers::String> spriteFrame) { fbb_.AddOffset(PageViewIndicator::VT_SPRITEFRAME, spriteFrame); }
  void add_spriteFrameFromTP(bool spriteFrameFromTP) { fbb_.AddElement<uint8_t>(PageViewIndicator::VT_SPRITEFRAMEFROMTP, static_cast<uint8_t>(spriteFrameFromTP), 0); }
  void add_space(float space) { fbb_.AddElement<float>(PageViewIndicator::VT_SPACE, space, 0.0f); }
  void add_direction(int32_t direction) { fbb_.AddElement<int32_t>(PageViewIndicator::VT_DIRECTION, direction, 0); }
  PageViewIndicatorBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PageViewIndicatorBuilder &operator=(const PageViewIndicatorBuilder &);
  flatbuffers::Offset<PageViewIndicator> Finish() {
    auto o = flatbuffers::Offset<PageViewIndicator>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<PageViewIndicator> CreatePageViewIndicator(flatbuffers::FlatBufferBuilder &_fbb,
    const Vec2 *positionAnchor = 0,
    flatbuffers::Offset<flatbuffers::String> spriteFrame = 0,
    bool spriteFrameFromTP = false,
    float space = 0.0f,
    int32_t direction = 0) {
  PageViewIndicatorBuilder builder_(_fbb);
  builder_.add_direction(direction);
  builder_.add_space(space);
  builder_.add_spriteFrame(spriteFrame);
  builder_.add_positionAnchor(positionAnchor);
  builder_.add_spriteFrameFromTP(spriteFrameFromTP);
  return builder_.Finish();
}

inline flatbuffers::Offset<PageViewIndicator> CreatePageViewIndicatorDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const Vec2 *positionAnchor = 0,
    const char *spriteFrame = nullptr,
    bool spriteFrameFromTP = false,
    float space = 0.0f,
    int32_t direction = 0) {
  return CreatePageViewIndicator(_fbb, positionAnchor, spriteFrame ? _fbb.CreateString(spriteFrame) : 0, spriteFrameFromTP, space, direction);
}

struct PageViewPage FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_SPRITEFRAME = 6,
    VT_SPRITEFRAMEFROMTP = 8,
    VT_SCALE9ENABLED = 10
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *spriteFrame() const { return GetPointer<const flatbuffers::String *>(VT_SPRITEFRAME); }
  bool spriteFrameFromTP() const { return GetField<uint8_t>(VT_SPRITEFRAMEFROMTP, 0) != 0; }
  bool scale9Enabled() const { return GetField<uint8_t>(VT_SCALE9ENABLED, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SPRITEFRAME) &&
           verifier.Verify(spriteFrame()) &&
           VerifyField<uint8_t>(verifier, VT_SPRITEFRAMEFROMTP) &&
           VerifyField<uint8_t>(verifier, VT_SCALE9ENABLED) &&
           verifier.EndTable();
  }
};

struct PageViewPageBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(PageViewPage::VT_NODE, node); }
  void add_spriteFrame(flatbuffers::Offset<flatbuffers::String> spriteFrame) { fbb_.AddOffset(PageViewPage::VT_SPRITEFRAME, spriteFrame); }
  void add_spriteFrameFromTP(bool spriteFrameFromTP) { fbb_.AddElement<uint8_t>(PageViewPage::VT_SPRITEFRAMEFROMTP, static_cast<uint8_t>(spriteFrameFromTP), 0); }
  void add_scale9Enabled(bool scale9Enabled) { fbb_.AddElement<uint8_t>(PageViewPage::VT_SCALE9ENABLED, static_cast<uint8_t>(scale9Enabled), 0); }
  PageViewPageBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PageViewPageBuilder &operator=(const PageViewPageBuilder &);
  flatbuffers::Offset<PageViewPage> Finish() {
    auto o = flatbuffers::Offset<PageViewPage>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<PageViewPage> CreatePageViewPage(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> spriteFrame = 0,
    bool spriteFrameFromTP = false,
    bool scale9Enabled = false) {
  PageViewPageBuilder builder_(_fbb);
  builder_.add_spriteFrame(spriteFrame);
  builder_.add_node(node);
  builder_.add_scale9Enabled(scale9Enabled);
  builder_.add_spriteFrameFromTP(spriteFrameFromTP);
  return builder_.Finish();
}

inline flatbuffers::Offset<PageViewPage> CreatePageViewPageDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *spriteFrame = nullptr,
    bool spriteFrameFromTP = false,
    bool scale9Enabled = false) {
  return CreatePageViewPage(_fbb, node, spriteFrame ? _fbb.CreateString(spriteFrame) : 0, spriteFrameFromTP, scale9Enabled);
}

struct PageViewBackground FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_SPRITEFRAME = 4,
    VT_SPRITEFRAMEFROMTP = 6
  };
  const flatbuffers::String *spriteFrame() const { return GetPointer<const flatbuffers::String *>(VT_SPRITEFRAME); }
  bool spriteFrameFromTP() const { return GetField<uint8_t>(VT_SPRITEFRAMEFROMTP, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SPRITEFRAME) &&
           verifier.Verify(spriteFrame()) &&
           VerifyField<uint8_t>(verifier, VT_SPRITEFRAMEFROMTP) &&
           verifier.EndTable();
  }
};

struct PageViewBackgroundBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_spriteFrame(flatbuffers::Offset<flatbuffers::String> spriteFrame) { fbb_.AddOffset(PageViewBackground::VT_SPRITEFRAME, spriteFrame); }
  void add_spriteFrameFromTP(bool spriteFrameFromTP) { fbb_.AddElement<uint8_t>(PageViewBackground::VT_SPRITEFRAMEFROMTP, static_cast<uint8_t>(spriteFrameFromTP), 0); }
  PageViewBackgroundBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PageViewBackgroundBuilder &operator=(const PageViewBackgroundBuilder &);
  flatbuffers::Offset<PageViewBackground> Finish() {
    auto o = flatbuffers::Offset<PageViewBackground>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<PageViewBackground> CreatePageViewBackground(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> spriteFrame = 0,
    bool spriteFrameFromTP = false) {
  PageViewBackgroundBuilder builder_(_fbb);
  builder_.add_spriteFrame(spriteFrame);
  builder_.add_spriteFrameFromTP(spriteFrameFromTP);
  return builder_.Finish();
}

inline flatbuffers::Offset<PageViewBackground> CreatePageViewBackgroundDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *spriteFrame = nullptr,
    bool spriteFrameFromTP = false) {
  return CreatePageViewBackground(_fbb, spriteFrame ? _fbb.CreateString(spriteFrame) : 0, spriteFrameFromTP);
}

struct PageView FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_INERTIA = 6,
    VT_BOUNCEENABLED = 8,
    VT_DIRECTION = 10,
    VT_INDICATOR = 12,
    VT_PAGES = 14,
    VT_BACKGROUND = 16
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  bool inertia() const { return GetField<uint8_t>(VT_INERTIA, 0) != 0; }
  bool bounceEnabled() const { return GetField<uint8_t>(VT_BOUNCEENABLED, 0) != 0; }
  ScrollViewDirection direction() const { return static_cast<ScrollViewDirection>(GetField<int8_t>(VT_DIRECTION, 0)); }
  const PageViewIndicator *indicator() const { return GetPointer<const PageViewIndicator *>(VT_INDICATOR); }
  const flatbuffers::Vector<flatbuffers::Offset<PageViewPage>> *pages() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<PageViewPage>> *>(VT_PAGES); }
  const PageViewBackground *background() const { return GetPointer<const PageViewBackground *>(VT_BACKGROUND); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<uint8_t>(verifier, VT_INERTIA) &&
           VerifyField<uint8_t>(verifier, VT_BOUNCEENABLED) &&
           VerifyField<int8_t>(verifier, VT_DIRECTION) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_INDICATOR) &&
           verifier.VerifyTable(indicator()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PAGES) &&
           verifier.Verify(pages()) &&
           verifier.VerifyVectorOfTables(pages()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BACKGROUND) &&
           verifier.VerifyTable(background()) &&
           verifier.EndTable();
  }
};

struct PageViewBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(PageView::VT_NODE, node); }
  void add_inertia(bool inertia) { fbb_.AddElement<uint8_t>(PageView::VT_INERTIA, static_cast<uint8_t>(inertia), 0); }
  void add_bounceEnabled(bool bounceEnabled) { fbb_.AddElement<uint8_t>(PageView::VT_BOUNCEENABLED, static_cast<uint8_t>(bounceEnabled), 0); }
  void add_direction(ScrollViewDirection direction) { fbb_.AddElement<int8_t>(PageView::VT_DIRECTION, static_cast<int8_t>(direction), 0); }
  void add_indicator(flatbuffers::Offset<PageViewIndicator> indicator) { fbb_.AddOffset(PageView::VT_INDICATOR, indicator); }
  void add_pages(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PageViewPage>>> pages) { fbb_.AddOffset(PageView::VT_PAGES, pages); }
  void add_background(flatbuffers::Offset<PageViewBackground> background) { fbb_.AddOffset(PageView::VT_BACKGROUND, background); }
  PageViewBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  PageViewBuilder &operator=(const PageViewBuilder &);
  flatbuffers::Offset<PageView> Finish() {
    auto o = flatbuffers::Offset<PageView>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<PageView> CreatePageView(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    bool inertia = false,
    bool bounceEnabled = false,
    ScrollViewDirection direction = ScrollViewDirection_None,
    flatbuffers::Offset<PageViewIndicator> indicator = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<PageViewPage>>> pages = 0,
    flatbuffers::Offset<PageViewBackground> background = 0) {
  PageViewBuilder builder_(_fbb);
  builder_.add_background(background);
  builder_.add_pages(pages);
  builder_.add_indicator(indicator);
  builder_.add_node(node);
  builder_.add_direction(direction);
  builder_.add_bounceEnabled(bounceEnabled);
  builder_.add_inertia(inertia);
  return builder_.Finish();
}

inline flatbuffers::Offset<PageView> CreatePageViewDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    bool inertia = false,
    bool bounceEnabled = false,
    ScrollViewDirection direction = ScrollViewDirection_None,
    flatbuffers::Offset<PageViewIndicator> indicator = 0,
    const std::vector<flatbuffers::Offset<PageViewPage>> *pages = nullptr,
    flatbuffers::Offset<PageViewBackground> background = 0) {
  return CreatePageView(_fbb, node, inertia, bounceEnabled, direction, indicator, pages ? _fbb.CreateVector<flatbuffers::Offset<PageViewPage>>(*pages) : 0, background);
}

struct MotionStreak FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_TIMETOFADE = 6,
    VT_MINSEG = 8,
    VT_STROKEWIDTH = 10,
    VT_STROKECOLOR = 12,
    VT_TEXTUREPATH = 14,
    VT_FASTMODE = 16
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  float timeToFade() const { return GetField<float>(VT_TIMETOFADE, 0.0f); }
  float minSeg() const { return GetField<float>(VT_MINSEG, 0.0f); }
  float strokeWidth() const { return GetField<float>(VT_STROKEWIDTH, 0.0f); }
  const ColorRGB *strokeColor() const { return GetStruct<const ColorRGB *>(VT_STROKECOLOR); }
  const flatbuffers::String *texturePath() const { return GetPointer<const flatbuffers::String *>(VT_TEXTUREPATH); }
  bool fastMode() const { return GetField<uint8_t>(VT_FASTMODE, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<float>(verifier, VT_TIMETOFADE) &&
           VerifyField<float>(verifier, VT_MINSEG) &&
           VerifyField<float>(verifier, VT_STROKEWIDTH) &&
           VerifyField<ColorRGB>(verifier, VT_STROKECOLOR) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TEXTUREPATH) &&
           verifier.Verify(texturePath()) &&
           VerifyField<uint8_t>(verifier, VT_FASTMODE) &&
           verifier.EndTable();
  }
};

struct MotionStreakBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(MotionStreak::VT_NODE, node); }
  void add_timeToFade(float timeToFade) { fbb_.AddElement<float>(MotionStreak::VT_TIMETOFADE, timeToFade, 0.0f); }
  void add_minSeg(float minSeg) { fbb_.AddElement<float>(MotionStreak::VT_MINSEG, minSeg, 0.0f); }
  void add_strokeWidth(float strokeWidth) { fbb_.AddElement<float>(MotionStreak::VT_STROKEWIDTH, strokeWidth, 0.0f); }
  void add_strokeColor(const ColorRGB *strokeColor) { fbb_.AddStruct(MotionStreak::VT_STROKECOLOR, strokeColor); }
  void add_texturePath(flatbuffers::Offset<flatbuffers::String> texturePath) { fbb_.AddOffset(MotionStreak::VT_TEXTUREPATH, texturePath); }
  void add_fastMode(bool fastMode) { fbb_.AddElement<uint8_t>(MotionStreak::VT_FASTMODE, static_cast<uint8_t>(fastMode), 0); }
  MotionStreakBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  MotionStreakBuilder &operator=(const MotionStreakBuilder &);
  flatbuffers::Offset<MotionStreak> Finish() {
    auto o = flatbuffers::Offset<MotionStreak>(fbb_.EndTable(start_, 7));
    return o;
  }
};

inline flatbuffers::Offset<MotionStreak> CreateMotionStreak(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    float timeToFade = 0.0f,
    float minSeg = 0.0f,
    float strokeWidth = 0.0f,
    const ColorRGB *strokeColor = 0,
    flatbuffers::Offset<flatbuffers::String> texturePath = 0,
    bool fastMode = false) {
  MotionStreakBuilder builder_(_fbb);
  builder_.add_texturePath(texturePath);
  builder_.add_strokeColor(strokeColor);
  builder_.add_strokeWidth(strokeWidth);
  builder_.add_minSeg(minSeg);
  builder_.add_timeToFade(timeToFade);
  builder_.add_node(node);
  builder_.add_fastMode(fastMode);
  return builder_.Finish();
}

inline flatbuffers::Offset<MotionStreak> CreateMotionStreakDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    float timeToFade = 0.0f,
    float minSeg = 0.0f,
    float strokeWidth = 0.0f,
    const ColorRGB *strokeColor = 0,
    const char *texturePath = nullptr,
    bool fastMode = false) {
  return CreateMotionStreak(_fbb, node, timeToFade, minSeg, strokeWidth, strokeColor, texturePath ? _fbb.CreateString(texturePath) : 0, fastMode);
}

struct SpineSkeleton FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_JSONFILE = 6,
    VT_ATLASFILE = 8,
    VT_DEFAULTSKIN = 10,
    VT_DEFAULTANIMATION = 12,
    VT_LOOP = 14,
    VT_PREMULTIPLIEDALPHA = 16,
    VT_TIMESCALE = 18,
    VT_DEBUGSLOTS = 20,
    VT_DEBUGBONES = 22
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *jsonFile() const { return GetPointer<const flatbuffers::String *>(VT_JSONFILE); }
  const flatbuffers::String *atlasFile() const { return GetPointer<const flatbuffers::String *>(VT_ATLASFILE); }
  const flatbuffers::String *defaultSkin() const { return GetPointer<const flatbuffers::String *>(VT_DEFAULTSKIN); }
  const flatbuffers::String *defaultAnimation() const { return GetPointer<const flatbuffers::String *>(VT_DEFAULTANIMATION); }
  bool loop() const { return GetField<uint8_t>(VT_LOOP, 0) != 0; }
  bool premultipliedAlpha() const { return GetField<uint8_t>(VT_PREMULTIPLIEDALPHA, 0) != 0; }
  float timeScale() const { return GetField<float>(VT_TIMESCALE, 1.0f); }
  bool debugSlots() const { return GetField<uint8_t>(VT_DEBUGSLOTS, 0) != 0; }
  bool debugBones() const { return GetField<uint8_t>(VT_DEBUGBONES, 0) != 0; }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_JSONFILE) &&
           verifier.Verify(jsonFile()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ATLASFILE) &&
           verifier.Verify(atlasFile()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DEFAULTSKIN) &&
           verifier.Verify(defaultSkin()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DEFAULTANIMATION) &&
           verifier.Verify(defaultAnimation()) &&
           VerifyField<uint8_t>(verifier, VT_LOOP) &&
           VerifyField<uint8_t>(verifier, VT_PREMULTIPLIEDALPHA) &&
           VerifyField<float>(verifier, VT_TIMESCALE) &&
           VerifyField<uint8_t>(verifier, VT_DEBUGSLOTS) &&
           VerifyField<uint8_t>(verifier, VT_DEBUGBONES) &&
           verifier.EndTable();
  }
};

struct SpineSkeletonBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(SpineSkeleton::VT_NODE, node); }
  void add_jsonFile(flatbuffers::Offset<flatbuffers::String> jsonFile) { fbb_.AddOffset(SpineSkeleton::VT_JSONFILE, jsonFile); }
  void add_atlasFile(flatbuffers::Offset<flatbuffers::String> atlasFile) { fbb_.AddOffset(SpineSkeleton::VT_ATLASFILE, atlasFile); }
  void add_defaultSkin(flatbuffers::Offset<flatbuffers::String> defaultSkin) { fbb_.AddOffset(SpineSkeleton::VT_DEFAULTSKIN, defaultSkin); }
  void add_defaultAnimation(flatbuffers::Offset<flatbuffers::String> defaultAnimation) { fbb_.AddOffset(SpineSkeleton::VT_DEFAULTANIMATION, defaultAnimation); }
  void add_loop(bool loop) { fbb_.AddElement<uint8_t>(SpineSkeleton::VT_LOOP, static_cast<uint8_t>(loop), 0); }
  void add_premultipliedAlpha(bool premultipliedAlpha) { fbb_.AddElement<uint8_t>(SpineSkeleton::VT_PREMULTIPLIEDALPHA, static_cast<uint8_t>(premultipliedAlpha), 0); }
  void add_timeScale(float timeScale) { fbb_.AddElement<float>(SpineSkeleton::VT_TIMESCALE, timeScale, 1.0f); }
  void add_debugSlots(bool debugSlots) { fbb_.AddElement<uint8_t>(SpineSkeleton::VT_DEBUGSLOTS, static_cast<uint8_t>(debugSlots), 0); }
  void add_debugBones(bool debugBones) { fbb_.AddElement<uint8_t>(SpineSkeleton::VT_DEBUGBONES, static_cast<uint8_t>(debugBones), 0); }
  SpineSkeletonBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  SpineSkeletonBuilder &operator=(const SpineSkeletonBuilder &);
  flatbuffers::Offset<SpineSkeleton> Finish() {
    auto o = flatbuffers::Offset<SpineSkeleton>(fbb_.EndTable(start_, 10));
    return o;
  }
};

inline flatbuffers::Offset<SpineSkeleton> CreateSpineSkeleton(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> jsonFile = 0,
    flatbuffers::Offset<flatbuffers::String> atlasFile = 0,
    flatbuffers::Offset<flatbuffers::String> defaultSkin = 0,
    flatbuffers::Offset<flatbuffers::String> defaultAnimation = 0,
    bool loop = false,
    bool premultipliedAlpha = false,
    float timeScale = 1.0f,
    bool debugSlots = false,
    bool debugBones = false) {
  SpineSkeletonBuilder builder_(_fbb);
  builder_.add_timeScale(timeScale);
  builder_.add_defaultAnimation(defaultAnimation);
  builder_.add_defaultSkin(defaultSkin);
  builder_.add_atlasFile(atlasFile);
  builder_.add_jsonFile(jsonFile);
  builder_.add_node(node);
  builder_.add_debugBones(debugBones);
  builder_.add_debugSlots(debugSlots);
  builder_.add_premultipliedAlpha(premultipliedAlpha);
  builder_.add_loop(loop);
  return builder_.Finish();
}

inline flatbuffers::Offset<SpineSkeleton> CreateSpineSkeletonDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *jsonFile = nullptr,
    const char *atlasFile = nullptr,
    const char *defaultSkin = nullptr,
    const char *defaultAnimation = nullptr,
    bool loop = false,
    bool premultipliedAlpha = false,
    float timeScale = 1.0f,
    bool debugSlots = false,
    bool debugBones = false) {
  return CreateSpineSkeleton(_fbb, node, jsonFile ? _fbb.CreateString(jsonFile) : 0, atlasFile ? _fbb.CreateString(atlasFile) : 0, defaultSkin ? _fbb.CreateString(defaultSkin) : 0, defaultAnimation ? _fbb.CreateString(defaultAnimation) : 0, loop, premultipliedAlpha, timeScale, debugSlots, debugBones);
}

struct AnimationRef FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_CLIPS = 4,
    VT_PLAYONLOAD = 6,
    VT_DEFAULTCLIP = 8
  };
  const flatbuffers::Vector<flatbuffers::Offset<AnimationClip>> *clips() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimationClip>> *>(VT_CLIPS); }
  bool playOnLoad() const { return GetField<uint8_t>(VT_PLAYONLOAD, 0) != 0; }
  const flatbuffers::String *defaultClip() const { return GetPointer<const flatbuffers::String *>(VT_DEFAULTCLIP); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CLIPS) &&
           verifier.Verify(clips()) &&
           verifier.VerifyVectorOfTables(clips()) &&
           VerifyField<uint8_t>(verifier, VT_PLAYONLOAD) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_DEFAULTCLIP) &&
           verifier.Verify(defaultClip()) &&
           verifier.EndTable();
  }
};

struct AnimationRefBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_clips(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationClip>>> clips) { fbb_.AddOffset(AnimationRef::VT_CLIPS, clips); }
  void add_playOnLoad(bool playOnLoad) { fbb_.AddElement<uint8_t>(AnimationRef::VT_PLAYONLOAD, static_cast<uint8_t>(playOnLoad), 0); }
  void add_defaultClip(flatbuffers::Offset<flatbuffers::String> defaultClip) { fbb_.AddOffset(AnimationRef::VT_DEFAULTCLIP, defaultClip); }
  AnimationRefBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimationRefBuilder &operator=(const AnimationRefBuilder &);
  flatbuffers::Offset<AnimationRef> Finish() {
    auto o = flatbuffers::Offset<AnimationRef>(fbb_.EndTable(start_, 3));
    return o;
  }
};

inline flatbuffers::Offset<AnimationRef> CreateAnimationRef(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimationClip>>> clips = 0,
    bool playOnLoad = false,
    flatbuffers::Offset<flatbuffers::String> defaultClip = 0) {
  AnimationRefBuilder builder_(_fbb);
  builder_.add_defaultClip(defaultClip);
  builder_.add_clips(clips);
  builder_.add_playOnLoad(playOnLoad);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimationRef> CreateAnimationRefDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AnimationClip>> *clips = nullptr,
    bool playOnLoad = false,
    const char *defaultClip = nullptr) {
  return CreateAnimationRef(_fbb, clips ? _fbb.CreateVector<flatbuffers::Offset<AnimationClip>>(*clips) : 0, playOnLoad, defaultClip ? _fbb.CreateString(defaultClip) : 0);
}

struct Collider FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_TYPE = 4,
    VT_OFFSET = 6,
    VT_SIZE = 8,
    VT_POINTS = 10,
    VT_RADIUS = 12
  };
  ColliderType type() const { return static_cast<ColliderType>(GetField<int8_t>(VT_TYPE, 0)); }
  const Vec2 *offset() const { return GetStruct<const Vec2 *>(VT_OFFSET); }
  const Size *size() const { return GetStruct<const Size *>(VT_SIZE); }
  const flatbuffers::Vector<const Vec2 *> *points() const { return GetPointer<const flatbuffers::Vector<const Vec2 *> *>(VT_POINTS); }
  float radius() const { return GetField<float>(VT_RADIUS, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<int8_t>(verifier, VT_TYPE) &&
           VerifyField<Vec2>(verifier, VT_OFFSET) &&
           VerifyField<Size>(verifier, VT_SIZE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_POINTS) &&
           verifier.Verify(points()) &&
           VerifyField<float>(verifier, VT_RADIUS) &&
           verifier.EndTable();
  }
};

struct ColliderBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_type(ColliderType type) { fbb_.AddElement<int8_t>(Collider::VT_TYPE, static_cast<int8_t>(type), 0); }
  void add_offset(const Vec2 *offset) { fbb_.AddStruct(Collider::VT_OFFSET, offset); }
  void add_size(const Size *size) { fbb_.AddStruct(Collider::VT_SIZE, size); }
  void add_points(flatbuffers::Offset<flatbuffers::Vector<const Vec2 *>> points) { fbb_.AddOffset(Collider::VT_POINTS, points); }
  void add_radius(float radius) { fbb_.AddElement<float>(Collider::VT_RADIUS, radius, 0.0f); }
  ColliderBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  ColliderBuilder &operator=(const ColliderBuilder &);
  flatbuffers::Offset<Collider> Finish() {
    auto o = flatbuffers::Offset<Collider>(fbb_.EndTable(start_, 5));
    return o;
  }
};

inline flatbuffers::Offset<Collider> CreateCollider(flatbuffers::FlatBufferBuilder &_fbb,
    ColliderType type = ColliderType_BoxCollider,
    const Vec2 *offset = 0,
    const Size *size = 0,
    flatbuffers::Offset<flatbuffers::Vector<const Vec2 *>> points = 0,
    float radius = 0.0f) {
  ColliderBuilder builder_(_fbb);
  builder_.add_radius(radius);
  builder_.add_points(points);
  builder_.add_size(size);
  builder_.add_offset(offset);
  builder_.add_type(type);
  return builder_.Finish();
}

inline flatbuffers::Offset<Collider> CreateColliderDirect(flatbuffers::FlatBufferBuilder &_fbb,
    ColliderType type = ColliderType_BoxCollider,
    const Vec2 *offset = 0,
    const Size *size = 0,
    const std::vector<const Vec2 *> *points = nullptr,
    float radius = 0.0f) {
  return CreateCollider(_fbb, type, offset, size, points ? _fbb.CreateVector<const Vec2 *>(*points) : 0, radius);
}

struct DragonBones FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NODE = 4,
    VT_BONEDATAPATH = 6,
    VT_BONEDATANAME = 8,
    VT_TEXTUREDATAPATH = 10,
    VT_ARMATURE = 12,
    VT_ANIMATION = 14,
    VT_TIMESCALE = 16,
    VT_PLAYTIMES = 18
  };
  const Node *node() const { return GetPointer<const Node *>(VT_NODE); }
  const flatbuffers::String *boneDataPath() const { return GetPointer<const flatbuffers::String *>(VT_BONEDATAPATH); }
  const flatbuffers::String *boneDataName() const { return GetPointer<const flatbuffers::String *>(VT_BONEDATANAME); }
  const flatbuffers::String *textureDataPath() const { return GetPointer<const flatbuffers::String *>(VT_TEXTUREDATAPATH); }
  const flatbuffers::String *armature() const { return GetPointer<const flatbuffers::String *>(VT_ARMATURE); }
  const flatbuffers::String *animation() const { return GetPointer<const flatbuffers::String *>(VT_ANIMATION); }
  float timeScale() const { return GetField<float>(VT_TIMESCALE, 0.0f); }
  int32_t playTimes() const { return GetField<int32_t>(VT_PLAYTIMES, 0); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NODE) &&
           verifier.VerifyTable(node()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BONEDATAPATH) &&
           verifier.Verify(boneDataPath()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_BONEDATANAME) &&
           verifier.Verify(boneDataName()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_TEXTUREDATAPATH) &&
           verifier.Verify(textureDataPath()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ARMATURE) &&
           verifier.Verify(armature()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ANIMATION) &&
           verifier.Verify(animation()) &&
           VerifyField<float>(verifier, VT_TIMESCALE) &&
           VerifyField<int32_t>(verifier, VT_PLAYTIMES) &&
           verifier.EndTable();
  }
};

struct DragonBonesBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_node(flatbuffers::Offset<Node> node) { fbb_.AddOffset(DragonBones::VT_NODE, node); }
  void add_boneDataPath(flatbuffers::Offset<flatbuffers::String> boneDataPath) { fbb_.AddOffset(DragonBones::VT_BONEDATAPATH, boneDataPath); }
  void add_boneDataName(flatbuffers::Offset<flatbuffers::String> boneDataName) { fbb_.AddOffset(DragonBones::VT_BONEDATANAME, boneDataName); }
  void add_textureDataPath(flatbuffers::Offset<flatbuffers::String> textureDataPath) { fbb_.AddOffset(DragonBones::VT_TEXTUREDATAPATH, textureDataPath); }
  void add_armature(flatbuffers::Offset<flatbuffers::String> armature) { fbb_.AddOffset(DragonBones::VT_ARMATURE, armature); }
  void add_animation(flatbuffers::Offset<flatbuffers::String> animation) { fbb_.AddOffset(DragonBones::VT_ANIMATION, animation); }
  void add_timeScale(float timeScale) { fbb_.AddElement<float>(DragonBones::VT_TIMESCALE, timeScale, 0.0f); }
  void add_playTimes(int32_t playTimes) { fbb_.AddElement<int32_t>(DragonBones::VT_PLAYTIMES, playTimes, 0); }
  DragonBonesBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  DragonBonesBuilder &operator=(const DragonBonesBuilder &);
  flatbuffers::Offset<DragonBones> Finish() {
    auto o = flatbuffers::Offset<DragonBones>(fbb_.EndTable(start_, 8));
    return o;
  }
};

inline flatbuffers::Offset<DragonBones> CreateDragonBones(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    flatbuffers::Offset<flatbuffers::String> boneDataPath = 0,
    flatbuffers::Offset<flatbuffers::String> boneDataName = 0,
    flatbuffers::Offset<flatbuffers::String> textureDataPath = 0,
    flatbuffers::Offset<flatbuffers::String> armature = 0,
    flatbuffers::Offset<flatbuffers::String> animation = 0,
    float timeScale = 0.0f,
    int32_t playTimes = 0) {
  DragonBonesBuilder builder_(_fbb);
  builder_.add_playTimes(playTimes);
  builder_.add_timeScale(timeScale);
  builder_.add_animation(animation);
  builder_.add_armature(armature);
  builder_.add_textureDataPath(textureDataPath);
  builder_.add_boneDataName(boneDataName);
  builder_.add_boneDataPath(boneDataPath);
  builder_.add_node(node);
  return builder_.Finish();
}

inline flatbuffers::Offset<DragonBones> CreateDragonBonesDirect(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<Node> node = 0,
    const char *boneDataPath = nullptr,
    const char *boneDataName = nullptr,
    const char *textureDataPath = nullptr,
    const char *armature = nullptr,
    const char *animation = nullptr,
    float timeScale = 0.0f,
    int32_t playTimes = 0) {
  return CreateDragonBones(_fbb, node, boneDataPath ? _fbb.CreateString(boneDataPath) : 0, boneDataName ? _fbb.CreateString(boneDataName) : 0, textureDataPath ? _fbb.CreateString(textureDataPath) : 0, armature ? _fbb.CreateString(armature) : 0, animation ? _fbb.CreateString(animation) : 0, timeScale, playTimes);
}

struct AnimationClip FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_NAME = 4,
    VT_DURATION = 6,
    VT_SAMPLE = 8,
    VT_SPEED = 10,
    VT_WRAPMODE = 12,
    VT_CURVEDATA = 14
  };
  const flatbuffers::String *name() const { return GetPointer<const flatbuffers::String *>(VT_NAME); }
  float duration() const { return GetField<float>(VT_DURATION, 0.0f); }
  float sample() const { return GetField<float>(VT_SAMPLE, 0.0f); }
  float speed() const { return GetField<float>(VT_SPEED, 0.0f); }
  AnimWrapMode wrapMode() const { return static_cast<AnimWrapMode>(GetField<int8_t>(VT_WRAPMODE, 0)); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimCurveData>> *curveData() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimCurveData>> *>(VT_CURVEDATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_NAME) &&
           verifier.Verify(name()) &&
           VerifyField<float>(verifier, VT_DURATION) &&
           VerifyField<float>(verifier, VT_SAMPLE) &&
           VerifyField<float>(verifier, VT_SPEED) &&
           VerifyField<int8_t>(verifier, VT_WRAPMODE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVEDATA) &&
           verifier.Verify(curveData()) &&
           verifier.VerifyVectorOfTables(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimationClipBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_name(flatbuffers::Offset<flatbuffers::String> name) { fbb_.AddOffset(AnimationClip::VT_NAME, name); }
  void add_duration(float duration) { fbb_.AddElement<float>(AnimationClip::VT_DURATION, duration, 0.0f); }
  void add_sample(float sample) { fbb_.AddElement<float>(AnimationClip::VT_SAMPLE, sample, 0.0f); }
  void add_speed(float speed) { fbb_.AddElement<float>(AnimationClip::VT_SPEED, speed, 0.0f); }
  void add_wrapMode(AnimWrapMode wrapMode) { fbb_.AddElement<int8_t>(AnimationClip::VT_WRAPMODE, static_cast<int8_t>(wrapMode), 0); }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimCurveData>>> curveData) { fbb_.AddOffset(AnimationClip::VT_CURVEDATA, curveData); }
  AnimationClipBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimationClipBuilder &operator=(const AnimationClipBuilder &);
  flatbuffers::Offset<AnimationClip> Finish() {
    auto o = flatbuffers::Offset<AnimationClip>(fbb_.EndTable(start_, 6));
    return o;
  }
};

inline flatbuffers::Offset<AnimationClip> CreateAnimationClip(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> name = 0,
    float duration = 0.0f,
    float sample = 0.0f,
    float speed = 0.0f,
    AnimWrapMode wrapMode = AnimWrapMode_Default,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimCurveData>>> curveData = 0) {
  AnimationClipBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_speed(speed);
  builder_.add_sample(sample);
  builder_.add_duration(duration);
  builder_.add_name(name);
  builder_.add_wrapMode(wrapMode);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimationClip> CreateAnimationClipDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *name = nullptr,
    float duration = 0.0f,
    float sample = 0.0f,
    float speed = 0.0f,
    AnimWrapMode wrapMode = AnimWrapMode_Default,
    const std::vector<flatbuffers::Offset<AnimCurveData>> *curveData = nullptr) {
  return CreateAnimationClip(_fbb, name ? _fbb.CreateString(name) : 0, duration, sample, speed, wrapMode, curveData ? _fbb.CreateVector<flatbuffers::Offset<AnimCurveData>>(*curveData) : 0);
}

struct AnimCurveData FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_PATH = 4,
    VT_PROPS = 6
  };
  const flatbuffers::String *path() const { return GetPointer<const flatbuffers::String *>(VT_PATH); }
  const AnimProps *props() const { return GetPointer<const AnimProps *>(VT_PROPS); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PATH) &&
           verifier.Verify(path()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_PROPS) &&
           verifier.VerifyTable(props()) &&
           verifier.EndTable();
  }
};

struct AnimCurveDataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_path(flatbuffers::Offset<flatbuffers::String> path) { fbb_.AddOffset(AnimCurveData::VT_PATH, path); }
  void add_props(flatbuffers::Offset<AnimProps> props) { fbb_.AddOffset(AnimCurveData::VT_PROPS, props); }
  AnimCurveDataBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimCurveDataBuilder &operator=(const AnimCurveDataBuilder &);
  flatbuffers::Offset<AnimCurveData> Finish() {
    auto o = flatbuffers::Offset<AnimCurveData>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<AnimCurveData> CreateAnimCurveData(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::String> path = 0,
    flatbuffers::Offset<AnimProps> props = 0) {
  AnimCurveDataBuilder builder_(_fbb);
  builder_.add_props(props);
  builder_.add_path(path);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimCurveData> CreateAnimCurveDataDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const char *path = nullptr,
    flatbuffers::Offset<AnimProps> props = 0) {
  return CreateAnimCurveData(_fbb, path ? _fbb.CreateString(path) : 0, props);
}

struct AnimProps FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_ROTATION = 4,
    VT_POSITION = 6,
    VT_POSITIONX = 8,
    VT_POSITIONY = 10,
    VT_ANCHORX = 12,
    VT_ANCHORY = 14,
    VT_COLOR = 16,
    VT_OPACITY = 18,
    VT_WIDTH = 20,
    VT_HEIGHT = 22,
    VT_SCALEX = 24,
    VT_SCALEY = 26,
    VT_SKEWX = 28,
    VT_SKEWY = 30
  };
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropRotation>> *rotation() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropRotation>> *>(VT_ROTATION); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropPosition>> *position() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropPosition>> *>(VT_POSITION); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionX>> *positionX() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionX>> *>(VT_POSITIONX); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionY>> *positionY() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionY>> *>(VT_POSITIONY); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorX>> *anchorX() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorX>> *>(VT_ANCHORX); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorY>> *anchorY() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorY>> *>(VT_ANCHORY); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropColor>> *color() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropColor>> *>(VT_COLOR); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropOpacity>> *opacity() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropOpacity>> *>(VT_OPACITY); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropWidth>> *width() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropWidth>> *>(VT_WIDTH); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropHeight>> *height() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropHeight>> *>(VT_HEIGHT); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleX>> *scaleX() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleX>> *>(VT_SCALEX); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleY>> *scaleY() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleY>> *>(VT_SCALEY); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewX>> *skewX() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewX>> *>(VT_SKEWX); }
  const flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewY>> *skewY() const { return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewY>> *>(VT_SKEWY); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ROTATION) &&
           verifier.Verify(rotation()) &&
           verifier.VerifyVectorOfTables(rotation()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_POSITION) &&
           verifier.Verify(position()) &&
           verifier.VerifyVectorOfTables(position()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_POSITIONX) &&
           verifier.Verify(positionX()) &&
           verifier.VerifyVectorOfTables(positionX()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_POSITIONY) &&
           verifier.Verify(positionY()) &&
           verifier.VerifyVectorOfTables(positionY()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ANCHORX) &&
           verifier.Verify(anchorX()) &&
           verifier.VerifyVectorOfTables(anchorX()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_ANCHORY) &&
           verifier.Verify(anchorY()) &&
           verifier.VerifyVectorOfTables(anchorY()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_COLOR) &&
           verifier.Verify(color()) &&
           verifier.VerifyVectorOfTables(color()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_OPACITY) &&
           verifier.Verify(opacity()) &&
           verifier.VerifyVectorOfTables(opacity()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_WIDTH) &&
           verifier.Verify(width()) &&
           verifier.VerifyVectorOfTables(width()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_HEIGHT) &&
           verifier.Verify(height()) &&
           verifier.VerifyVectorOfTables(height()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SCALEX) &&
           verifier.Verify(scaleX()) &&
           verifier.VerifyVectorOfTables(scaleX()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SCALEY) &&
           verifier.Verify(scaleY()) &&
           verifier.VerifyVectorOfTables(scaleY()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SKEWX) &&
           verifier.Verify(skewX()) &&
           verifier.VerifyVectorOfTables(skewX()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_SKEWY) &&
           verifier.Verify(skewY()) &&
           verifier.VerifyVectorOfTables(skewY()) &&
           verifier.EndTable();
  }
};

struct AnimPropsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_rotation(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropRotation>>> rotation) { fbb_.AddOffset(AnimProps::VT_ROTATION, rotation); }
  void add_position(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropPosition>>> position) { fbb_.AddOffset(AnimProps::VT_POSITION, position); }
  void add_positionX(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionX>>> positionX) { fbb_.AddOffset(AnimProps::VT_POSITIONX, positionX); }
  void add_positionY(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionY>>> positionY) { fbb_.AddOffset(AnimProps::VT_POSITIONY, positionY); }
  void add_anchorX(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorX>>> anchorX) { fbb_.AddOffset(AnimProps::VT_ANCHORX, anchorX); }
  void add_anchorY(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorY>>> anchorY) { fbb_.AddOffset(AnimProps::VT_ANCHORY, anchorY); }
  void add_color(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropColor>>> color) { fbb_.AddOffset(AnimProps::VT_COLOR, color); }
  void add_opacity(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropOpacity>>> opacity) { fbb_.AddOffset(AnimProps::VT_OPACITY, opacity); }
  void add_width(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropWidth>>> width) { fbb_.AddOffset(AnimProps::VT_WIDTH, width); }
  void add_height(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropHeight>>> height) { fbb_.AddOffset(AnimProps::VT_HEIGHT, height); }
  void add_scaleX(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleX>>> scaleX) { fbb_.AddOffset(AnimProps::VT_SCALEX, scaleX); }
  void add_scaleY(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleY>>> scaleY) { fbb_.AddOffset(AnimProps::VT_SCALEY, scaleY); }
  void add_skewX(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewX>>> skewX) { fbb_.AddOffset(AnimProps::VT_SKEWX, skewX); }
  void add_skewY(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewY>>> skewY) { fbb_.AddOffset(AnimProps::VT_SKEWY, skewY); }
  AnimPropsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropsBuilder &operator=(const AnimPropsBuilder &);
  flatbuffers::Offset<AnimProps> Finish() {
    auto o = flatbuffers::Offset<AnimProps>(fbb_.EndTable(start_, 14));
    return o;
  }
};

inline flatbuffers::Offset<AnimProps> CreateAnimProps(flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropRotation>>> rotation = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropPosition>>> position = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionX>>> positionX = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropPositionY>>> positionY = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorX>>> anchorX = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropAnchorY>>> anchorY = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropColor>>> color = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropOpacity>>> opacity = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropWidth>>> width = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropHeight>>> height = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleX>>> scaleX = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropScaleY>>> scaleY = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewX>>> skewX = 0,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<AnimPropSkewY>>> skewY = 0) {
  AnimPropsBuilder builder_(_fbb);
  builder_.add_skewY(skewY);
  builder_.add_skewX(skewX);
  builder_.add_scaleY(scaleY);
  builder_.add_scaleX(scaleX);
  builder_.add_height(height);
  builder_.add_width(width);
  builder_.add_opacity(opacity);
  builder_.add_color(color);
  builder_.add_anchorY(anchorY);
  builder_.add_anchorX(anchorX);
  builder_.add_positionY(positionY);
  builder_.add_positionX(positionX);
  builder_.add_position(position);
  builder_.add_rotation(rotation);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimProps> CreateAnimPropsDirect(flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<AnimPropRotation>> *rotation = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropPosition>> *position = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropPositionX>> *positionX = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropPositionY>> *positionY = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropAnchorX>> *anchorX = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropAnchorY>> *anchorY = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropColor>> *color = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropOpacity>> *opacity = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropWidth>> *width = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropHeight>> *height = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropScaleX>> *scaleX = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropScaleY>> *scaleY = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropSkewX>> *skewX = nullptr,
    const std::vector<flatbuffers::Offset<AnimPropSkewY>> *skewY = nullptr) {
  return CreateAnimProps(_fbb, rotation ? _fbb.CreateVector<flatbuffers::Offset<AnimPropRotation>>(*rotation) : 0, position ? _fbb.CreateVector<flatbuffers::Offset<AnimPropPosition>>(*position) : 0, positionX ? _fbb.CreateVector<flatbuffers::Offset<AnimPropPositionX>>(*positionX) : 0, positionY ? _fbb.CreateVector<flatbuffers::Offset<AnimPropPositionY>>(*positionY) : 0, anchorX ? _fbb.CreateVector<flatbuffers::Offset<AnimPropAnchorX>>(*anchorX) : 0, anchorY ? _fbb.CreateVector<flatbuffers::Offset<AnimPropAnchorY>>(*anchorY) : 0, color ? _fbb.CreateVector<flatbuffers::Offset<AnimPropColor>>(*color) : 0, opacity ? _fbb.CreateVector<flatbuffers::Offset<AnimPropOpacity>>(*opacity) : 0, width ? _fbb.CreateVector<flatbuffers::Offset<AnimPropWidth>>(*width) : 0, height ? _fbb.CreateVector<flatbuffers::Offset<AnimPropHeight>>(*height) : 0, scaleX ? _fbb.CreateVector<flatbuffers::Offset<AnimPropScaleX>>(*scaleX) : 0, scaleY ? _fbb.CreateVector<flatbuffers::Offset<AnimPropScaleY>>(*scaleY) : 0, skewX ? _fbb.CreateVector<flatbuffers::Offset<AnimPropSkewX>>(*skewX) : 0, skewY ? _fbb.CreateVector<flatbuffers::Offset<AnimPropSkewY>>(*skewY) : 0);
}

struct AnimEvents FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           verifier.EndTable();
  }
};

struct AnimEventsBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  AnimEventsBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimEventsBuilder &operator=(const AnimEventsBuilder &);
  flatbuffers::Offset<AnimEvents> Finish() {
    auto o = flatbuffers::Offset<AnimEvents>(fbb_.EndTable(start_, 0));
    return o;
  }
};

inline flatbuffers::Offset<AnimEvents> CreateAnimEvents(flatbuffers::FlatBufferBuilder &_fbb) {
  AnimEventsBuilder builder_(_fbb);
  return builder_.Finish();
}

struct AnimPropRotation FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  const flatbuffers::String *curveType() const { return GetPointer<const flatbuffers::String *>(VT_CURVETYPE); }
  const flatbuffers::Vector<float> *curveData() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVETYPE) &&
           verifier.Verify(curveType()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVEDATA) &&
           verifier.Verify(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropRotationBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropRotation::VT_FRAME, frame, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(AnimPropRotation::VT_VALUE, value, 0.0f); }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) { fbb_.AddOffset(AnimPropRotation::VT_CURVETYPE, curveType); }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) { fbb_.AddOffset(AnimPropRotation::VT_CURVEDATA, curveData); }
  AnimPropRotationBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropRotationBuilder &operator=(const AnimPropRotationBuilder &);
  flatbuffers::Offset<AnimPropRotation> Finish() {
    auto o = flatbuffers::Offset<AnimPropRotation>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropRotation> CreateAnimPropRotation(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropRotationBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropRotation> CreateAnimPropRotationDirect(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return CreateAnimPropRotation(_fbb, frame, value, curveType ? _fbb.CreateString(curveType) : 0, curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropPosition FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  const Vec2 *value() const { return GetStruct<const Vec2 *>(VT_VALUE); }
  const flatbuffers::String *curveType() const { return GetPointer<const flatbuffers::String *>(VT_CURVETYPE); }
  const flatbuffers::Vector<float> *curveData() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<Vec2>(verifier, VT_VALUE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVETYPE) &&
           verifier.Verify(curveType()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVEDATA) &&
           verifier.Verify(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropPositionBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropPosition::VT_FRAME, frame, 0.0f); }
  void add_value(const Vec2 *value) { fbb_.AddStruct(AnimPropPosition::VT_VALUE, value); }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) { fbb_.AddOffset(AnimPropPosition::VT_CURVETYPE, curveType); }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) { fbb_.AddOffset(AnimPropPosition::VT_CURVEDATA, curveData); }
  AnimPropPositionBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropPositionBuilder &operator=(const AnimPropPositionBuilder &);
  flatbuffers::Offset<AnimPropPosition> Finish() {
    auto o = flatbuffers::Offset<AnimPropPosition>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropPosition> CreateAnimPropPosition(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    const Vec2 *value = 0,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropPositionBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropPosition> CreateAnimPropPositionDirect(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    const Vec2 *value = 0,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return CreateAnimPropPosition(_fbb, frame, value, curveType ? _fbb.CreateString(curveType) : 0, curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropPositionX FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  const flatbuffers::String *curveType() const { return GetPointer<const flatbuffers::String *>(VT_CURVETYPE); }
  const flatbuffers::Vector<float> *curveData() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVETYPE) &&
           verifier.Verify(curveType()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVEDATA) &&
           verifier.Verify(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropPositionXBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropPositionX::VT_FRAME, frame, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(AnimPropPositionX::VT_VALUE, value, 0.0f); }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) { fbb_.AddOffset(AnimPropPositionX::VT_CURVETYPE, curveType); }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) { fbb_.AddOffset(AnimPropPositionX::VT_CURVEDATA, curveData); }
  AnimPropPositionXBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropPositionXBuilder &operator=(const AnimPropPositionXBuilder &);
  flatbuffers::Offset<AnimPropPositionX> Finish() {
    auto o = flatbuffers::Offset<AnimPropPositionX>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropPositionX> CreateAnimPropPositionX(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropPositionXBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropPositionX> CreateAnimPropPositionXDirect(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return CreateAnimPropPositionX(_fbb, frame, value, curveType ? _fbb.CreateString(curveType) : 0, curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropPositionY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  const flatbuffers::String *curveType() const { return GetPointer<const flatbuffers::String *>(VT_CURVETYPE); }
  const flatbuffers::Vector<float> *curveData() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVETYPE) &&
           verifier.Verify(curveType()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVEDATA) &&
           verifier.Verify(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropPositionYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropPositionY::VT_FRAME, frame, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(AnimPropPositionY::VT_VALUE, value, 0.0f); }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) { fbb_.AddOffset(AnimPropPositionY::VT_CURVETYPE, curveType); }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) { fbb_.AddOffset(AnimPropPositionY::VT_CURVEDATA, curveData); }
  AnimPropPositionYBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropPositionYBuilder &operator=(const AnimPropPositionYBuilder &);
  flatbuffers::Offset<AnimPropPositionY> Finish() {
    auto o = flatbuffers::Offset<AnimPropPositionY>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropPositionY> CreateAnimPropPositionY(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropPositionYBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropPositionY> CreateAnimPropPositionYDirect(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return CreateAnimPropPositionY(_fbb, frame, value, curveType ? _fbb.CreateString(curveType) : 0, curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropScaleX FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  const flatbuffers::String *curveType() const { return GetPointer<const flatbuffers::String *>(VT_CURVETYPE); }
  const flatbuffers::Vector<float> *curveData() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVETYPE) &&
           verifier.Verify(curveType()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVEDATA) &&
           verifier.Verify(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropScaleXBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropScaleX::VT_FRAME, frame, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(AnimPropScaleX::VT_VALUE, value, 0.0f); }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) { fbb_.AddOffset(AnimPropScaleX::VT_CURVETYPE, curveType); }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) { fbb_.AddOffset(AnimPropScaleX::VT_CURVEDATA, curveData); }
  AnimPropScaleXBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropScaleXBuilder &operator=(const AnimPropScaleXBuilder &);
  flatbuffers::Offset<AnimPropScaleX> Finish() {
    auto o = flatbuffers::Offset<AnimPropScaleX>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropScaleX> CreateAnimPropScaleX(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropScaleXBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropScaleX> CreateAnimPropScaleXDirect(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return CreateAnimPropScaleX(_fbb, frame, value, curveType ? _fbb.CreateString(curveType) : 0, curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropScaleY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  const flatbuffers::String *curveType() const { return GetPointer<const flatbuffers::String *>(VT_CURVETYPE); }
  const flatbuffers::Vector<float> *curveData() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVETYPE) &&
           verifier.Verify(curveType()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVEDATA) &&
           verifier.Verify(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropScaleYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropScaleY::VT_FRAME, frame, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(AnimPropScaleY::VT_VALUE, value, 0.0f); }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) { fbb_.AddOffset(AnimPropScaleY::VT_CURVETYPE, curveType); }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) { fbb_.AddOffset(AnimPropScaleY::VT_CURVEDATA, curveData); }
  AnimPropScaleYBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropScaleYBuilder &operator=(const AnimPropScaleYBuilder &);
  flatbuffers::Offset<AnimPropScaleY> Finish() {
    auto o = flatbuffers::Offset<AnimPropScaleY>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropScaleY> CreateAnimPropScaleY(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropScaleYBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropScaleY> CreateAnimPropScaleYDirect(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return CreateAnimPropScaleY(_fbb, frame, value, curveType ? _fbb.CreateString(curveType) : 0, curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropWidth FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  const flatbuffers::String *curveType() const { return GetPointer<const flatbuffers::String *>(VT_CURVETYPE); }
  const flatbuffers::Vector<float> *curveData() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVETYPE) &&
           verifier.Verify(curveType()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVEDATA) &&
           verifier.Verify(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropWidthBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropWidth::VT_FRAME, frame, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(AnimPropWidth::VT_VALUE, value, 0.0f); }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) { fbb_.AddOffset(AnimPropWidth::VT_CURVETYPE, curveType); }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) { fbb_.AddOffset(AnimPropWidth::VT_CURVEDATA, curveData); }
  AnimPropWidthBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropWidthBuilder &operator=(const AnimPropWidthBuilder &);
  flatbuffers::Offset<AnimPropWidth> Finish() {
    auto o = flatbuffers::Offset<AnimPropWidth>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropWidth> CreateAnimPropWidth(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropWidthBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropWidth> CreateAnimPropWidthDirect(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return CreateAnimPropWidth(_fbb, frame, value, curveType ? _fbb.CreateString(curveType) : 0, curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropHeight FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  const flatbuffers::String *curveType() const { return GetPointer<const flatbuffers::String *>(VT_CURVETYPE); }
  const flatbuffers::Vector<float> *curveData() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVETYPE) &&
           verifier.Verify(curveType()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVEDATA) &&
           verifier.Verify(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropHeightBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropHeight::VT_FRAME, frame, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(AnimPropHeight::VT_VALUE, value, 0.0f); }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) { fbb_.AddOffset(AnimPropHeight::VT_CURVETYPE, curveType); }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) { fbb_.AddOffset(AnimPropHeight::VT_CURVEDATA, curveData); }
  AnimPropHeightBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropHeightBuilder &operator=(const AnimPropHeightBuilder &);
  flatbuffers::Offset<AnimPropHeight> Finish() {
    auto o = flatbuffers::Offset<AnimPropHeight>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropHeight> CreateAnimPropHeight(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropHeightBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropHeight> CreateAnimPropHeightDirect(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return CreateAnimPropHeight(_fbb, frame, value, curveType ? _fbb.CreateString(curveType) : 0, curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropColor FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  const ColorRGBA *value() const { return GetStruct<const ColorRGBA *>(VT_VALUE); }
  const flatbuffers::String *curveType() const { return GetPointer<const flatbuffers::String *>(VT_CURVETYPE); }
  const flatbuffers::Vector<float> *curveData() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<ColorRGBA>(verifier, VT_VALUE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVETYPE) &&
           verifier.Verify(curveType()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVEDATA) &&
           verifier.Verify(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropColorBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropColor::VT_FRAME, frame, 0.0f); }
  void add_value(const ColorRGBA *value) { fbb_.AddStruct(AnimPropColor::VT_VALUE, value); }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) { fbb_.AddOffset(AnimPropColor::VT_CURVETYPE, curveType); }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) { fbb_.AddOffset(AnimPropColor::VT_CURVEDATA, curveData); }
  AnimPropColorBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropColorBuilder &operator=(const AnimPropColorBuilder &);
  flatbuffers::Offset<AnimPropColor> Finish() {
    auto o = flatbuffers::Offset<AnimPropColor>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropColor> CreateAnimPropColor(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    const ColorRGBA *value = 0,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropColorBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropColor> CreateAnimPropColorDirect(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    const ColorRGBA *value = 0,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return CreateAnimPropColor(_fbb, frame, value, curveType ? _fbb.CreateString(curveType) : 0, curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropOpacity FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  const flatbuffers::String *curveType() const { return GetPointer<const flatbuffers::String *>(VT_CURVETYPE); }
  const flatbuffers::Vector<float> *curveData() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVETYPE) &&
           verifier.Verify(curveType()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVEDATA) &&
           verifier.Verify(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropOpacityBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropOpacity::VT_FRAME, frame, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(AnimPropOpacity::VT_VALUE, value, 0.0f); }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) { fbb_.AddOffset(AnimPropOpacity::VT_CURVETYPE, curveType); }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) { fbb_.AddOffset(AnimPropOpacity::VT_CURVEDATA, curveData); }
  AnimPropOpacityBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropOpacityBuilder &operator=(const AnimPropOpacityBuilder &);
  flatbuffers::Offset<AnimPropOpacity> Finish() {
    auto o = flatbuffers::Offset<AnimPropOpacity>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropOpacity> CreateAnimPropOpacity(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropOpacityBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropOpacity> CreateAnimPropOpacityDirect(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return CreateAnimPropOpacity(_fbb, frame, value, curveType ? _fbb.CreateString(curveType) : 0, curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropAnchorX FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  const flatbuffers::String *curveType() const { return GetPointer<const flatbuffers::String *>(VT_CURVETYPE); }
  const flatbuffers::Vector<float> *curveData() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVETYPE) &&
           verifier.Verify(curveType()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVEDATA) &&
           verifier.Verify(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropAnchorXBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropAnchorX::VT_FRAME, frame, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(AnimPropAnchorX::VT_VALUE, value, 0.0f); }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) { fbb_.AddOffset(AnimPropAnchorX::VT_CURVETYPE, curveType); }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) { fbb_.AddOffset(AnimPropAnchorX::VT_CURVEDATA, curveData); }
  AnimPropAnchorXBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropAnchorXBuilder &operator=(const AnimPropAnchorXBuilder &);
  flatbuffers::Offset<AnimPropAnchorX> Finish() {
    auto o = flatbuffers::Offset<AnimPropAnchorX>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropAnchorX> CreateAnimPropAnchorX(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropAnchorXBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropAnchorX> CreateAnimPropAnchorXDirect(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return CreateAnimPropAnchorX(_fbb, frame, value, curveType ? _fbb.CreateString(curveType) : 0, curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropAnchorY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  const flatbuffers::String *curveType() const { return GetPointer<const flatbuffers::String *>(VT_CURVETYPE); }
  const flatbuffers::Vector<float> *curveData() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVETYPE) &&
           verifier.Verify(curveType()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVEDATA) &&
           verifier.Verify(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropAnchorYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropAnchorY::VT_FRAME, frame, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(AnimPropAnchorY::VT_VALUE, value, 0.0f); }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) { fbb_.AddOffset(AnimPropAnchorY::VT_CURVETYPE, curveType); }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) { fbb_.AddOffset(AnimPropAnchorY::VT_CURVEDATA, curveData); }
  AnimPropAnchorYBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropAnchorYBuilder &operator=(const AnimPropAnchorYBuilder &);
  flatbuffers::Offset<AnimPropAnchorY> Finish() {
    auto o = flatbuffers::Offset<AnimPropAnchorY>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropAnchorY> CreateAnimPropAnchorY(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropAnchorYBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropAnchorY> CreateAnimPropAnchorYDirect(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return CreateAnimPropAnchorY(_fbb, frame, value, curveType ? _fbb.CreateString(curveType) : 0, curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropSkewX FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  const flatbuffers::String *curveType() const { return GetPointer<const flatbuffers::String *>(VT_CURVETYPE); }
  const flatbuffers::Vector<float> *curveData() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVETYPE) &&
           verifier.Verify(curveType()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVEDATA) &&
           verifier.Verify(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropSkewXBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropSkewX::VT_FRAME, frame, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(AnimPropSkewX::VT_VALUE, value, 0.0f); }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) { fbb_.AddOffset(AnimPropSkewX::VT_CURVETYPE, curveType); }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) { fbb_.AddOffset(AnimPropSkewX::VT_CURVEDATA, curveData); }
  AnimPropSkewXBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropSkewXBuilder &operator=(const AnimPropSkewXBuilder &);
  flatbuffers::Offset<AnimPropSkewX> Finish() {
    auto o = flatbuffers::Offset<AnimPropSkewX>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropSkewX> CreateAnimPropSkewX(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropSkewXBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropSkewX> CreateAnimPropSkewXDirect(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return CreateAnimPropSkewX(_fbb, frame, value, curveType ? _fbb.CreateString(curveType) : 0, curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct AnimPropSkewY FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_FRAME = 4,
    VT_VALUE = 6,
    VT_CURVETYPE = 8,
    VT_CURVEDATA = 10
  };
  float frame() const { return GetField<float>(VT_FRAME, 0.0f); }
  float value() const { return GetField<float>(VT_VALUE, 0.0f); }
  const flatbuffers::String *curveType() const { return GetPointer<const flatbuffers::String *>(VT_CURVETYPE); }
  const flatbuffers::Vector<float> *curveData() const { return GetPointer<const flatbuffers::Vector<float> *>(VT_CURVEDATA); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<float>(verifier, VT_FRAME) &&
           VerifyField<float>(verifier, VT_VALUE) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVETYPE) &&
           verifier.Verify(curveType()) &&
           VerifyField<flatbuffers::uoffset_t>(verifier, VT_CURVEDATA) &&
           verifier.Verify(curveData()) &&
           verifier.EndTable();
  }
};

struct AnimPropSkewYBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_frame(float frame) { fbb_.AddElement<float>(AnimPropSkewY::VT_FRAME, frame, 0.0f); }
  void add_value(float value) { fbb_.AddElement<float>(AnimPropSkewY::VT_VALUE, value, 0.0f); }
  void add_curveType(flatbuffers::Offset<flatbuffers::String> curveType) { fbb_.AddOffset(AnimPropSkewY::VT_CURVETYPE, curveType); }
  void add_curveData(flatbuffers::Offset<flatbuffers::Vector<float>> curveData) { fbb_.AddOffset(AnimPropSkewY::VT_CURVEDATA, curveData); }
  AnimPropSkewYBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  AnimPropSkewYBuilder &operator=(const AnimPropSkewYBuilder &);
  flatbuffers::Offset<AnimPropSkewY> Finish() {
    auto o = flatbuffers::Offset<AnimPropSkewY>(fbb_.EndTable(start_, 4));
    return o;
  }
};

inline flatbuffers::Offset<AnimPropSkewY> CreateAnimPropSkewY(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    flatbuffers::Offset<flatbuffers::String> curveType = 0,
    flatbuffers::Offset<flatbuffers::Vector<float>> curveData = 0) {
  AnimPropSkewYBuilder builder_(_fbb);
  builder_.add_curveData(curveData);
  builder_.add_curveType(curveType);
  builder_.add_value(value);
  builder_.add_frame(frame);
  return builder_.Finish();
}

inline flatbuffers::Offset<AnimPropSkewY> CreateAnimPropSkewYDirect(flatbuffers::FlatBufferBuilder &_fbb,
    float frame = 0.0f,
    float value = 0.0f,
    const char *curveType = nullptr,
    const std::vector<float> *curveData = nullptr) {
  return CreateAnimPropSkewY(_fbb, frame, value, curveType ? _fbb.CreateString(curveType) : 0, curveData ? _fbb.CreateVector<float>(*curveData) : 0);
}

struct LabelOutline FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum {
    VT_COLOR = 4,
    VT_WIDTH = 6
  };
  const ColorRGBA *color() const { return GetStruct<const ColorRGBA *>(VT_COLOR); }
  float width() const { return GetField<float>(VT_WIDTH, 0.0f); }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyField<ColorRGBA>(verifier, VT_COLOR) &&
           VerifyField<float>(verifier, VT_WIDTH) &&
           verifier.EndTable();
  }
};

struct LabelOutlineBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_color(const ColorRGBA *color) { fbb_.AddStruct(LabelOutline::VT_COLOR, color); }
  void add_width(float width) { fbb_.AddElement<float>(LabelOutline::VT_WIDTH, width, 0.0f); }
  LabelOutlineBuilder(flatbuffers::FlatBufferBuilder &_fbb) : fbb_(_fbb) { start_ = fbb_.StartTable(); }
  LabelOutlineBuilder &operator=(const LabelOutlineBuilder &);
  flatbuffers::Offset<LabelOutline> Finish() {
    auto o = flatbuffers::Offset<LabelOutline>(fbb_.EndTable(start_, 2));
    return o;
  }
};

inline flatbuffers::Offset<LabelOutline> CreateLabelOutline(flatbuffers::FlatBufferBuilder &_fbb,
    const ColorRGBA *color = 0,
    float width = 0.0f) {
  LabelOutlineBuilder builder_(_fbb);
  builder_.add_width(width);
  builder_.add_color(color);
  return builder_.Finish();
}

inline bool VerifyAnyNode(flatbuffers::Verifier &verifier, const void *union_obj, AnyNode type) {
  switch (type) {
    case AnyNode_NONE: return true;
    case AnyNode_Scene: return verifier.VerifyTable(reinterpret_cast<const Scene *>(union_obj));
    case AnyNode_Sprite: return verifier.VerifyTable(reinterpret_cast<const Sprite *>(union_obj));
    case AnyNode_Label: return verifier.VerifyTable(reinterpret_cast<const Label *>(union_obj));
    case AnyNode_Particle: return verifier.VerifyTable(reinterpret_cast<const Particle *>(union_obj));
    case AnyNode_TileMap: return verifier.VerifyTable(reinterpret_cast<const TileMap *>(union_obj));
    case AnyNode_Node: return verifier.VerifyTable(reinterpret_cast<const Node *>(union_obj));
    case AnyNode_Button: return verifier.VerifyTable(reinterpret_cast<const Button *>(union_obj));
    case AnyNode_ProgressBar: return verifier.VerifyTable(reinterpret_cast<const ProgressBar *>(union_obj));
    case AnyNode_ScrollView: return verifier.VerifyTable(reinterpret_cast<const ScrollView *>(union_obj));
    case AnyNode_CreatorScene: return verifier.VerifyTable(reinterpret_cast<const CreatorScene *>(union_obj));
    case AnyNode_EditBox: return verifier.VerifyTable(reinterpret_cast<const EditBox *>(union_obj));
    case AnyNode_RichText: return verifier.VerifyTable(reinterpret_cast<const RichText *>(union_obj));
    case AnyNode_SpineSkeleton: return verifier.VerifyTable(reinterpret_cast<const SpineSkeleton *>(union_obj));
    case AnyNode_VideoPlayer: return verifier.VerifyTable(reinterpret_cast<const VideoPlayer *>(union_obj));
    case AnyNode_WebView: return verifier.VerifyTable(reinterpret_cast<const WebView *>(union_obj));
    case AnyNode_Slider: return verifier.VerifyTable(reinterpret_cast<const Slider *>(union_obj));
    case AnyNode_Toggle: return verifier.VerifyTable(reinterpret_cast<const Toggle *>(union_obj));
    case AnyNode_ToggleGroup: return verifier.VerifyTable(reinterpret_cast<const ToggleGroup *>(union_obj));
    case AnyNode_PageView: return verifier.VerifyTable(reinterpret_cast<const PageView *>(union_obj));
    case AnyNode_Mask: return verifier.VerifyTable(reinterpret_cast<const Mask *>(union_obj));
    case AnyNode_DragonBones: return verifier.VerifyTable(reinterpret_cast<const DragonBones *>(union_obj));
    case AnyNode_MotionStreak: return verifier.VerifyTable(reinterpret_cast<const MotionStreak *>(union_obj));
    default: return false;
  }
}

inline const creator::buffers::SceneGraph *GetSceneGraph(const void *buf) {
  return flatbuffers::GetRoot<creator::buffers::SceneGraph>(buf);
}

inline const char *SceneGraphIdentifier() {
  return "CCRE";
}

inline bool SceneGraphBufferHasIdentifier(const void *buf) {
  return flatbuffers::BufferHasIdentifier(buf, SceneGraphIdentifier());
}

inline bool VerifySceneGraphBuffer(flatbuffers::Verifier &verifier) {
  return verifier.VerifyBuffer<creator::buffers::SceneGraph>(SceneGraphIdentifier());
}

inline const char *SceneGraphExtension() { return "ccreator"; }

inline void FinishSceneGraphBuffer(flatbuffers::FlatBufferBuilder &fbb, flatbuffers::Offset<creator::buffers::SceneGraph> root) {
  fbb.Finish(root, SceneGraphIdentifier());
}

}  // namespace buffers
}  // namespace creator

#endif  // FLATBUFFERS_GENERATED_CREATORREADER_CREATOR_BUFFERS_H_

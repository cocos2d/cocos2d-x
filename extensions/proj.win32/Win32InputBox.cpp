#include "Win32InputBox.h"

#if (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32)

#include <stdio.h>

#pragma warning (disable: 4312)

typedef struct _MSDN_DLGTEMPLATEEX 
{
  WORD dlgVer;
  WORD signature;
  DWORD helpID;
  DWORD exStyle;
  DWORD style;
  WORD cDlgItems;
  short x;
  short y;
  short cx;
  short cy;
  BYTE  _rest[1]; // rest of structure
} MSDN_DLGTEMPLATEEX;

static bool IsDlgTemplateExtended(DLGTEMPLATE *dlgTemplate)
{
  MSDN_DLGTEMPLATEEX *dgExTemplate = (MSDN_DLGTEMPLATEEX *) dlgTemplate;

  // MSDN excerpt:
  //* dlgVer
  //  Specifies the version number of the extended dialog box template. This member must be 1. 
  //* signature
  //  Indicates whether a template is an extended dialog box template. 
  // If signature is 0xFFFF, this is an extended dialog box template. 
  // In this case, the dlgVer member specifies the template version number. 
  // If signature is any value other than 0xFFFF, this is a standard dialog box template that uses the DLGTEMPLATE and DLGITEMTEMPLATE structures. 

  return (dgExTemplate->dlgVer == 1) && (dgExTemplate->signature == 0xFFFF);
}

// Use alignment if supported by the compiler
#ifdef _MSC_VER
  #if _MSC_VER > 1200
    __declspec(align(4)) 
  #endif
#endif

// per the MSDN, the DLGTEMPLATE must be DWORD aligned
// this was generated by the DlgResToDlgTemplate tool
static unsigned char definputbox_dlg[] =
{
  0x01,0x00,0xff,0xff,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0xc8,0x00,0xc8,0x00,0x06,
    0x00,0x16,0x00,0x11,0x00,0xe7,0x00,0x6d,0x00,0x00,0x00,0x00,0x00,0x57,0x00,0x69,
    0x00,0x6e,0x00,0x33,0x00,0x32,0x00,0x49,0x00,0x6e,0x00,0x70,0x00,0x75,0x00,0x74,
    0x00,0x42,0x00,0x6f,0x00,0x78,0x00,0x00,0x00,0x08,0x00,0xbc,0x02,0x00,0x00,0x4d,
    0x00,0x53,0x00,0x20,0x00,0x53,0x00,0x68,0x00,0x65,0x00,0x6c,0x00,0x6c,0x00,0x20,
    0x00,0x44,0x00,0x6c,0x00,0x67,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x80,0x00,0x02,0x50,0x06,0x00,0x04,0x00,0x9d,0x00,0x21,0x00,0xe8,
    0x03,0x00,0x00,0xff,0xff,0x82,0x00,0x50,0x00,0x72,0x00,0x6f,0x00,0x6d,0x00,0x70,
    0x00,0x74,0x00,0x3a,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x80,0x00,0x81,0x50,0x06,0x00,0x25,0x00,0xd8,0x00,0x0e,0x00,0xe9,
    0x03,0x00,0x00,0xff,0xff,0x81,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x84,0x10,0xa1,0x50,0x06,0x00,0x37,0x00,0xd8,0x00,0x31,0x00,0xea,
    0x03,0x00,0x00,0xff,0xff,0x81,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x01,0x00,0x03,0x50,0xab,0x00,0x04,0x00,0x33,0x00,0x0e,0x00,0x01,
    0x00,0x00,0x00,0xff,0xff,0x80,0x00,0x4f,0x00,0x4b,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x03,0x50,0xab,0x00,0x15,0x00,0x33,
    0x00,0x0e,0x00,0x02,0x00,0x00,0x00,0xff,0xff,0x80,0x00,0x43,0x00,0x41,0x00,0x4e,
    0x00,0x43,0x00,0x45,0x00,0x4c,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,0x00,
    0x00,0x00,0x00,0x00,0x00,0x02,0x40,0x00,0x00,0x27,0x00,0x08,0x00,0x08,0x00,0xff,
    0xff,0xff,0xff,0xff,0xff,0x82,0x00,0x00,0x00,0x00,0x00
};

static LPCTSTR definputbox_buttonnames[] = { _T("OK"), _T("CANCEL") };
static const INT_PTR definputbox_buttonids[] = { IDOK, IDCANCEL };

static const INT 
  definputbox_id_prompt = 1000,
  definputbox_id_edit1 = 1001,
  definputbox_id_edit2 = 1002;

WIN32INPUTBOX_PARAM::WIN32INPUTBOX_PARAM()
{
  bMultiline = false;
  hwndOwner = 0;
  DlgTemplateName = 0;
  hInstance = (HINSTANCE) ::GetModuleHandle(0);
  DlgTemplateData = definputbox_dlg;

  bCenter = true;

  dwStylesPlus = 0;
  dwExStylesPlus = 0;
  dwStylesMinus = 0xFFFFFFFF;
  dwExStylesMinus = 0xFFFFFFFF;

  xPos = yPos = -1;

  szResult = 0;
  nResultSize = 0;
}

CWin32InputBox::CWin32InputBox(WIN32INPUTBOX_PARAM *param)
{
  _param = param;
  _hwndEditCtrl = NULL;
  _depth = 0;
}

CWin32InputBox::~CWin32InputBox()
{

}

void CWin32InputBox::SetParam(WIN32INPUTBOX_PARAM *param)
{
  _param = param;
}

WIN32INPUTBOX_PARAM *CWin32InputBox::GetParam()
{
  return _param;
}

INT_PTR CWin32InputBox::Run()
{
  // Check mandatory parameters
  if (_param->szResult == 0)
  {
    ::SetLastError(ERROR_INVALID_PARAMETER);
    return 0;
  }

  LPDLGTEMPLATE dlgTemplate;

  if (_param->DlgTemplateName != 0)
  {
    HMODULE hModule = (HMODULE)_param->hInstance;
#ifdef __MINGW32__
    HRSRC rcDlg = ::FindResource(hModule, (LPWSTR)(ULONG_PTR)(size_t)(_param->DlgTemplateName), RT_DIALOG);
#else
    HRSRC rcDlg = ::FindResource(hModule, MAKEINTRESOURCE(_param->DlgTemplateName), RT_DIALOG);
#endif
    if (rcDlg == nullptr)
      return 0;

    HGLOBAL hglobalDlg = ::LoadResource(hModule, rcDlg);
    if (hglobalDlg == nullptr)
      return 0;

    dlgTemplate = (LPDLGTEMPLATE) hglobalDlg;
  }
  else if (_param->DlgTemplateData != 0)
  {
    dlgTemplate = (LPDLGTEMPLATE) _param->DlgTemplateData;
  }

  MSDN_DLGTEMPLATEEX *dlgTemplateEx = 
    IsDlgTemplateExtended((LPDLGTEMPLATE) dlgTemplate) ? (MSDN_DLGTEMPLATEEX *) dlgTemplate : 0;

  if (dlgTemplateEx != 0)
  {
    dlgTemplateEx->exStyle |= _param->dwExStylesPlus;
    dlgTemplateEx->style   |= _param->dwStylesPlus;
    dlgTemplateEx->exStyle &= _param->dwExStylesMinus;
    dlgTemplateEx->style   &= _param->dwStylesMinus;

    if (_param->bCenter)
      dlgTemplateEx->style |= DS_CENTER;

    if (_param->xPos != -1)
      dlgTemplateEx->x = _param->xPos;
    if (_param->yPos != -1)
      dlgTemplateEx->y = _param->yPos;
  }
  else
  {
    dlgTemplate->dwExtendedStyle  |= _param->dwExStylesPlus;
    dlgTemplate->style            |= _param->dwStylesPlus;
    dlgTemplate->dwExtendedStyle  &= _param->dwExStylesMinus;
    dlgTemplate->style            &= _param->dwStylesMinus;

    if (_param->bCenter)
      dlgTemplate->style |= DS_CENTER;

    if (_param->xPos != -1)
      dlgTemplate->x = _param->xPos;

    if (_param->yPos != -1)
      dlgTemplate->y = _param->yPos;
  }

  // Resize dialog and SHOW or HIDE multiline
  INT_PTR r = ::DialogBoxIndirectParam(_param->hInstance, dlgTemplate, _param->hwndOwner, (DLGPROC)DlgProc, (LPARAM)this);

  return r;
}

void CWin32InputBox::InitDialog()
{
  // Set the button captions
  for (size_t i=0;i<sizeof(definputbox_buttonids)/sizeof(definputbox_buttonids[0]);i++)
    ::SetDlgItemText(_param->hDlg, (int) definputbox_buttonids[i], definputbox_buttonnames[i]);

  // Set other controls
  char* title = Utf8ToAnsi(_param->szTitle);
  if (title != NULL)
  {
    ::SetWindowTextA(_param->hDlg, title);
    free(title);
  }

  char* prompt = Utf8ToAnsi(_param->szPrompt);
  if (prompt != NULL)
  {
    ::SetDlgItemTextA(_param->hDlg, definputbox_id_prompt, prompt);
    free(prompt);
  }

  HWND hwndEdit1 = ::GetDlgItem(_param->hDlg, definputbox_id_edit1);
  HWND hwndEdit2 = ::GetDlgItem(_param->hDlg, definputbox_id_edit2);

  if (_param->bMultiline)
    _hwndEditCtrl = hwndEdit2;
  else
    _hwndEditCtrl = hwndEdit1;

  char* result = Utf8ToAnsi(_param->szResult);
  if (result != NULL)
  {
    ::SetWindowTextA(_hwndEditCtrl, result);
    free(result);
  }

  RECT rectDlg, rectEdit1, rectEdit2;

  ::GetWindowRect(_param->hDlg, &rectDlg);
  ::GetWindowRect(hwndEdit1, &rectEdit1);
  ::GetWindowRect(hwndEdit2, &rectEdit2);

  if (_param->bMultiline)
  {
    ::ShowWindow(hwndEdit1, SW_HIDE);
    ::SetWindowPos(
      hwndEdit2, 
      HWND_NOTOPMOST, 
      rectEdit1.left - rectDlg.left, 
      (rectEdit1.top - rectDlg.top) - (rectEdit1.bottom - rectEdit1.top), 
      0, 
      0, 
      SWP_NOSIZE | SWP_NOZORDER);

    ::SetWindowPos(
      _param->hDlg, 
      HWND_NOTOPMOST, 
      0, 
      0, 
      rectDlg.right - rectDlg.left, 
      rectDlg.bottom - rectDlg.top - (rectEdit1.bottom - rectEdit1.top), 
      SWP_NOMOVE);

  }
  else
  {
    ::SetWindowPos(
      _param->hDlg, 
      HWND_NOTOPMOST, 
      0, 
      0, 
      rectDlg.right - rectDlg.left, 
      rectEdit1.bottom - rectDlg.top + 5,
      SWP_NOMOVE);

    ::ShowWindow(hwndEdit2, SW_HIDE);
  }

  if (_param->nMaxLength > 0)
  {
    ::SendMessageA(hwndEdit1, EM_SETLIMITTEXT, (WPARAM)_param->nMaxLength, 0);
    ::SendMessageA(hwndEdit2, EM_SETLIMITTEXT, (WPARAM)_param->nMaxLength, 0);
  }

  switch (_param->eInputFlag)
  {
  case kWin32InputBoxPassword:
    ::SendMessageA(hwndEdit1, EM_SETPASSWORDCHAR, (WPARAM)'*', 0);
    ::SendMessageA(hwndEdit2, EM_SETPASSWORDCHAR, (WPARAM)'*', 0);
    break;
  case kWin32InputBoxCaps:
    ::SetWindowLongA(hwndEdit1, GWL_STYLE, ::GetWindowLongA(hwndEdit1, GWL_STYLE) | ES_UPPERCASE);
    ::SetWindowLongA(hwndEdit2, GWL_STYLE, ::GetWindowLongA(hwndEdit2, GWL_STYLE) | ES_UPPERCASE);
    break;
  default:
    break;
  }
}

// Message handler for about box.
LRESULT CALLBACK CWin32InputBox::DlgProc(HWND hDlg, UINT message, WPARAM wParam, LPARAM lParam)
{
  static const UINT_PTR dwId = 0x2000;
  CWin32InputBox *_this = (CWin32InputBox *) ::GetWindowLongPtr(hDlg, GWLP_USERDATA);
  WIN32INPUTBOX_PARAM *param = _this ? _this->GetParam() : 0;

  switch (message)
  {
    case WM_INITDIALOG:
    {
      SetWindowLongPtr(hDlg, GWLP_USERDATA, (LONG_PTR) lParam);
      
      _this = (CWin32InputBox *)  lParam;
      _this->_param->hDlg = hDlg;
      _this->InitDialog();
      SetTimer(hDlg, dwId, 1, NULL);
      return TRUE;
    }

    case WM_TIMER:
    {
      cocos2d::Director::getInstance()->mainLoop();
      return TRUE;
    }

    case WM_COMMAND:
    {
#ifdef _MY_DEBUG
      CHAR buf[1024];
      static int i=0;
      sprintf(buf, "WM_COMMAND: %09d wParam=%08X lParam=%08X\n", i++, wParam, lParam);
      OutputDebugString(buf);
#endif
      INT_PTR buttonId = LOWORD(wParam);
      for (size_t i=0;
           i<sizeof(definputbox_buttonids)/sizeof(definputbox_buttonids[0]);
           i++)
      {
        if (buttonId == definputbox_buttonids[i]) 
        {
          ::GetWindowTextA(
            _this->_hwndEditCtrl, 
            _this->_param->szResult, 
            _this->_param->nResultSize);

		  char* strUtf8 = AnsiToUtf8(_this->_param->szResult);
          if (strUtf8 != NULL)
          {
            memset(_this->_param->szResult, 0, _this->_param->nResultSize);
            strncpy(_this->_param->szResult, strUtf8, _this->_param->nResultSize - 1);
            free(strUtf8);
          }
          else
          {
            _this->_param->szResult[0] = '\0';
          }
          ::EndDialog(hDlg, buttonId);
          return TRUE;
        }
      }

      if (HIWORD(wParam) == EN_CHANGE && _this->_depth == 0 && _this->_param->lpfnCallBack != NULL)
      {
        HWND hwndEditCtrl = (HWND)lParam;
        char buf[100];
        ::GetWindowTextA(hwndEditCtrl, buf, 100);
        ++_this->_depth;
        char* utf8Str = AnsiToUtf8(buf);
        if (utf8Str != NULL)
        {
          _this->_param->lpfnCallBack(utf8Str, _this->_param->lpCtx);
          free(utf8Str);
        }
        else
        {
          _this->_param->lpfnCallBack("", _this->_param->lpCtx);
        }
        --_this->_depth;
        return TRUE;
      }
    }
    break;
  }
  return FALSE;
}

void CWin32InputBox::SetText(const char* pText)
{
  if (_hwndEditCtrl != NULL)
  {
    char* ansiStr = Utf8ToAnsi(pText);
    if (ansiStr != NULL)
    {
      size_t len = strlen(ansiStr);
      DWORD dwBegin, dwEnd;
      ::SendMessageA(_hwndEditCtrl, EM_GETSEL, (WPARAM)&dwBegin, (LPARAM)&dwEnd);
      ::SendMessageA(_hwndEditCtrl, WM_SETTEXT, 0, (LPARAM)ansiStr);
      ::SendMessageA(_hwndEditCtrl, EM_SETSEL, (WPARAM)MIN(dwBegin, len), (LPARAM)MIN(dwEnd, len));
      free(ansiStr);
    }
    else
    {
      ::SendMessageA(_hwndEditCtrl, WM_SETTEXT, 0, (LPARAM)"");
      ::SendMessageA(_hwndEditCtrl, EM_SETSEL, (WPARAM)0, (LPARAM)0);
    }
  }
}

char* CWin32InputBox::AnsiToUtf8(const char* strAnsi)
{
	char* ret;
    size_t lenAnsi = strlen(strAnsi);
    if (lenAnsi > 0)
	{	
		int nWideStrLength = MultiByteToWideChar(CP_ACP, 0, strAnsi, -1, nullptr, 0);
		WCHAR* pwszBuf = (WCHAR*)malloc((nWideStrLength+1)*sizeof(WCHAR));
		memset(pwszBuf, 0, (nWideStrLength+1)*sizeof(WCHAR));
		MultiByteToWideChar(CP_ACP, 0, strAnsi, -1, pwszBuf, nWideStrLength+1);

		int nUtf8Length = WideCharToMultiByte( CP_UTF8,0,pwszBuf,-1,nullptr,0,nullptr,FALSE );
		char* pszUtf8Buf = (char*)malloc((nUtf8Length+1)*sizeof(char));
		memset(pszUtf8Buf, 0, (nUtf8Length+1)*sizeof(char));

		WideCharToMultiByte(CP_UTF8, 0, pwszBuf, -1, pszUtf8Buf, (nUtf8Length+1)*sizeof(char), nullptr, FALSE);
		ret = pszUtf8Buf;

		free(pwszBuf);
	}
	return ret;
}

char* CWin32InputBox::Utf8ToAnsi(const char* strUTF8)
{
    char *ret = NULL;
    size_t lenUTF8 = strlen(strUTF8);
    if (lenUTF8 > 0)
	{
		int nWideStrLength = MultiByteToWideChar(CP_UTF8, 0, strUTF8, -1, nullptr, 0);
		WCHAR* pwszBuf = (WCHAR*)malloc((nWideStrLength+1)*sizeof(WCHAR));
		memset(pwszBuf, 0, (nWideStrLength+1)*sizeof(WCHAR));
		MultiByteToWideChar(CP_UTF8, 0, strUTF8, -1, pwszBuf, (nWideStrLength+1)*sizeof(WCHAR));

		int nAnsiStrLength = WideCharToMultiByte( CP_ACP,0,pwszBuf,-1,nullptr,0,nullptr,FALSE );
		char* pszAnsiBuf = (char*)malloc((nAnsiStrLength+1)*sizeof(char));
		memset(pszAnsiBuf, 0, (nAnsiStrLength+1)*sizeof(char));

		WideCharToMultiByte(CP_ACP, 0, pwszBuf, -1, pszAnsiBuf, (nAnsiStrLength+1)*sizeof(char), nullptr, FALSE);
		ret = pszAnsiBuf;

		free(pwszBuf);
	}

	return ret;
}



#endif /* #if (CC_TARGET_PLATFORM == CC_PLATFORM_WIN32) */
